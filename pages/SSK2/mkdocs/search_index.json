{
    "docs": [
        {
            "location": "/", 
            "text": "Super Starter Kit 2\n\n\n SUPERCHARGING \nCorona SDK\n game development every day.  \nGet It Now!\n\n\n\n\n\n\n\n\n(\nLatest Release:\n \n2016.001\n)\n\n\nWhat Is It?\n\n\nSuper Starter Kit 2 (aka SSK2) is a collection of libraries and utilities designed to take your \nCorona SDK\n development experience to a whole new level of efficiency and speed.\n\n\n\n\nSSK2\n is the culmination of over five years of programming effort and as such acts as the foundation for all of my projects.  I think you should make it your foundation too.\n\n\n~ \nThe Roaming Gamer\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGlobals\n\n\nVariables \n functions (optionally) added to the global namespace to speed up and simplify coding.\n\n\n\n\n\n\nExtensions\n\n\nAdds 60+ new and improved features to: \ndisplay.*\n, \nio.*\n, \nmath.*\n, \nstring.*\n, \ntable.*\n, \ntransition.*\n\n\n\n\n\n\nCore\n\n\nLibraries that I quite honestly \ncannot develop without\n: \n(Improved) Display Object Factories\n, \nColors\n, \nEasy Interfaces\n, \nSystem Variables \n Flags\n\n\n\n\n\n\nSolutions\n\n\nTop-shelf solutions for common development challenges: \nActions Library\n, \nAndroid Helpers\n, \n(Scene) Camera Library\n, \nCollision Calculator\n, \nEasy Inputs\n, \n2D Math\n, \nPersistent Data\n, \nPoints Library\n, \nSimple Security\n, \nEasy Social\n, \nShuffle Bags\n, \n... more\n\n\n\n\n\n\nExternal\n\n\nA few libraries by folks that I find useful. (\nAppropriate licenses listed and included.\n)\n\n\n\n\n\n\n\n\nWhere Can I Get It?\n\n\nYou can find \nSSK2\n here\n\n\n\n\nAlso coming soon to the ...\n\n\n\n(\nYou can also see my full list of products on \nRG Docs\n.\n)\n\n\nInstalling SSK2\n\n\nTo use SSK2, simply:\n\n\n\n\nCopy the ssk2 folder and its contents to the same folder as your main.lua file.\n\n\nAdd this to main.lua at or very near the top of the file:\n\n\n\n\nrequire \nssk2.loadSSK\n\n_G.ssk.init()\n\n\n\n\nTip:\n SSK2 adds extra features to Lua and Corona so it is best to initialize it \nprior\n to requiring any other libraries or modules.\n\n\nConfiguring SSK2\n\n\nThe initialization example shown above uses the default settings for SSK2.  You may want to change that.  \n\n\nssk.init()\n takes an optional table of key-value pairs \n{ key1=value1, ..., keyN=valueN }\n that allows you to configure the myriad options SSK2 provides.\n\n\nConfiguration Settings:\n\n\n\n\ndebugLevel\n (\n0\n) - Values higher than 0 turn on debug messaging in SSK2 modules and libraries.\n\n\nValid range: [0, 2]\n\n\n\n\n\n\nexportCore\n (\ntrue\n)  - If set to true, SSK2 'exports' a number of values into the global (\n_G\n) namespace.  \n\n\nSee SSK \nGlobals\n for more details.\n\n\n\n\n\n\nexportColors\n (\ntrue\n)  - If set to \ntrue\n, SSK2 'exports' a number of color values and functions into the global (\n_G\n) namespace.  \n\n\nSee SSK \nssk.colors.*\n for more details.\n\n\n\n\n\n\nexportSystem\n (\nfalse\n)  - If set to true, SSK2 'exports' a number of values into the global (\n_G\n) namespace.  \n\n\nSee \nssk.system.*\n for more details.\n\n\n\n\n\n\ngameFont\n (\nnative.systemFont\n) - SSK2 uses a 'default' font for buttons and some other features.  You can specify that default font by providing the name of a valid \nttf\n or \notf\n file in this setting.\n\n\nlaunchArgs\n (\nnil\n) - Takes the value \n...\n which is only available in main.lua.  If provided it is used to further refine SSK2 settings based on what Corona has discovered about the current 'device' and passed on to your app in the launch args.\n\n\nmath2DPlugin\n (\nfalse\n) - If set to \ntrue\n, SSK2 will try to use the native \nmath2d\n instead of the built-in Lua-only version.  If it cannot find the plugin, it will safely fall back to the Lua version.\n\n\nmeasure\n (\nfalse\n) - If set to \ntrue\n SSK2 will dump a listing of each library name and size to the console.\n\n\nuseExternal\n (\nfalse\n) - If set to \ntrue\n SSK2 will load \nexternal\n libraries.\n\n\nTip:\n This content must be \ndownloaded\n first!\n\n\n\n\n\n\n\n\nExample\n\n\n_G.ssk.init( { launchArgs = ..., \n               measure = true,  \n               gameFont = \nRaleway-Light.ttf\n, \n               math2DPlugin = true,\n               debugLevel = 2 } )\n\n\n\n\nValidation Sampler\n\n\nAs time proceeds, there will me more and more free and paid content available using SSK2... but for now you can take a look at the \nValidation Sampler\n that comes with SSK2.\n\n\nYou will find the \nValidation Sampler\n in the ZIP-file you downloaded under \n~/validation\n.\n\n\nTo run the sampler, do the following:\n\n\n\n\nCopy the \nssk2/\n folder (and all its contents) into \n~/validation/\n.\n\n\nOpen main.lua in the \nSIMULATOR\n.  This will display a menu of samples you can run.\n\n\nClick on any sample button to run that sample.\n\n\nRe-load simulator (CTRL+R or CMD+R) to see the menu again.\n\n\n\n\n(Although it will work, the sampler is not designed to run easily on a device.  i.e. You will need to quit the app to run a new sample.)\n\n\n[\n]\n\n\nMetrics\n\n\nFor those folks who love metrics (admit it, you do), here are a few interesting details about SSK2.\n\n\nLines Of Code \n Comments\n\n\nCounting with \ncloc\n I get these metrics:\n\n\n-------------------------------------------------------------------------------\nLanguage                     files          blank        comment           code\n-------------------------------------------------------------------------------\nLua                             68           2398           2580          10836\n-------------------------------------------------------------------------------\n\n\n\n\nMemory Footprint\n\n\nA measurement of memory used per-library and in total:\n\n\n--------------------------------------------------------------------------\n-- Initalizing SSK\n--------------------------------------------------------------------------\nssk2.core                                                    :       7 KB\nssk2.extensions.display                                      :       1 KB\nssk2.extensions.io                                           :       7 KB\nssk2.extensions.math                                         :       5 KB\nssk2.extensions.native                                       :       3 KB\nssk2.extensions.string                                       :      13 KB\nssk2.extensions.table                                        :      24 KB\nssk2.extensions.transition                                   :       3 KB\nssk2.system                                                  :       2 KB\nssk2.android                                                 :       1 KB\nssk2.colors                                                  :      16 KB\nssk2.security                                                :       9 KB\nssk2.persist                                                 :       2 KB\nssk2.math2d                                                  :      12 KB\nssk2.cc                                                      :       6 KB\nssk2.points                                                  :       4 KB\nssk2.actions.actions                                         :      22 KB\nssk2.soundMgr                                                :      15 KB\nssk2.easyDisplay                                             :      51 KB\nssk2.easyIFC                                                 :     121 KB\nssk2.easyInputs                                              :      70 KB\nssk2.easyCamera                                              :      12 KB\nssk2.easySocial                                              :       2 KB\nssk2.misc                                                    :      44 KB\nssk2.shuffleBag                                              :       4 KB\nssk2.meters                                                  :       7 KB\nssk2.external.mydevelopers.autolan.client                    :      26 KB\nssk2.external.mydevelopers.autolan.server                    :      23 KB\nssk2.external.proxy                                          :       1 KB\nssk2.external.wait                                           :       2 KB\nssk2.external.randomlua                                      :       7 KB\nssk2.external.30log                                          :       5 KB\nssk2.external.portableRandom                                 :       4 KB\n--------------------------------------------------------------------------\nSSK Total                                                    :  529.86 KB\n--------------------------------------------------------------------------\n\n\n\n\nTip:\n While I find it useful to have all parts of SSK2 present during development, I sometimes remove elements I'm not using during production.  \n\n\n\n\nTo teach you about this, I will be soon write an article called: \nSLIMMING DOWN SSK2\n \n\n\n~ \nThe Roaming Gamer\n\n\n\n\nHelp!\n\n\nDon't Panic\n\n\nAre you having a problem with SSK2?  If so, don't panic.\n\n\nI regularly update SSK2 and its co-products.  Most of the time problems can simply be traced back to not having the most up-to-date version of SSK2.\n\n\nAre You Using The Latest Version?\n\n\nAdd this code at the end of main.lua\n\n\nprint( \nSSK VERSION: \n .. ssk.getVersion() )\n\n\n\n\nIf this prints out \nSSK VERSION: 2016.001\n you have the latest version. \n\n\nIf not, then go download a new copy from your store page.\n\n\nTip:\n While you are checking, be sure to check that your co-products are up-to-date too.\n\n\nAre You Getting Errors?\n\n\nDid you get an error dialog, or are you seeing error/warning message in the console?  \n\n\nIf so, read them and see if you have made a mistake on the line indicated.\n\n\nIf you think its me and not you, post a question in the forums.  (See \nPosting Questions To Forums\n below.)\n\n\nAre you typing \nssk2\n?\n\n\nYou may have noticed that while this is called SSK \n2\n, I still use the old naming convention \nssk.someFunction()\n in my samples.  \n\n\n\"Why,\" you ask?\n\n\nI am a lazy coder and proud of it. Even one extra letter is too much repetetive typing for me.  Also, I'm and \nold dog\n, and as the saying goes, \n\"You can't teach an old dog new tricks.\"\n\n\nSo, if you have been doing this: \nssk2.someFunction()\n, get rid of the \n2\n and you will be good to go.\n\n\nSSK2 ~= SSK Legacy\n\n\nThis is the guide for SSK2.  If you are trying to use Legacy SSK and following this guide... well many things have changed.  Please consider getting SSK2.\n\n\n\n\nGet SSK2 Now!\n It will be worth every penny!  ~ \nThe Roaming Gamer\n\n\n\n\nPosting Questions To The Forums\n\n\nI will be providing help (exclusively) through the \nCorona SDK Forums\n.  (\nSorry: Direct e-mails will not be answered.\n)\n\n\nWhen posting a question in the forums, be sure to follow these guidelines:\n\n\n\n\nPost to this forum: \nhttps://forums.coronalabs.com/forum/553-other-third-party-tools/\n\n\nMake sure the \ntitle\n starts with: \nSSK2\n and includes a short and meaninful name for the the problem.\n\n\nExample Title: \nSSK2: newImageRect() Paint Fill Parameter Not Working\n\n\n\n\n\n\nIn the \nbody\n of the post tell me all of the following:\n\n\nVersions / Environment / Target\n\n\nVersion of SSK you are using.\n\n\nVersion of Corona SDK you are using.\n\n\nOS you are developing under.\n\n\nWhere you are encountering the issue (Simulator(s) and or Device(s)).\n\n\n\n\n\n\nError Message(s) (If Any)\n\n\nError messages (put them in a code block for legibility)\n\n\n\n\n\n\nSummary Of Problem\n\n\nWhat you are trying to do.\n\n\nWhat you expected to see.\n\n\nWhat you saw instead.\n\n\nWhy you think this is wrong (if there is no explicit error message.)\n\n\n\n\n\n\nHelp Thyself\n\n\nTell me what debugging steps you have tried.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBe clear, concise and precise.\n\nThe more effort you put into your post, the better I will be able to help you. \n\n\n~ \nThe Roaming Gamer\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "About"
        }, 
        {
            "location": "/#super-starter-kit-2", 
            "text": "SUPERCHARGING  Corona SDK  game development every day.   Get It Now!     ( Latest Release:   2016.001 )", 
            "title": "Super Starter Kit 2"
        }, 
        {
            "location": "/#what-is-it", 
            "text": "Super Starter Kit 2 (aka SSK2) is a collection of libraries and utilities designed to take your  Corona SDK  development experience to a whole new level of efficiency and speed.   SSK2  is the culmination of over five years of programming effort and as such acts as the foundation for all of my projects.  I think you should make it your foundation too.  ~  The Roaming Gamer            Globals  Variables   functions (optionally) added to the global namespace to speed up and simplify coding.    Extensions  Adds 60+ new and improved features to:  display.* ,  io.* ,  math.* ,  string.* ,  table.* ,  transition.*    Core  Libraries that I quite honestly  cannot develop without :  (Improved) Display Object Factories ,  Colors ,  Easy Interfaces ,  System Variables   Flags    Solutions  Top-shelf solutions for common development challenges:  Actions Library ,  Android Helpers ,  (Scene) Camera Library ,  Collision Calculator ,  Easy Inputs ,  2D Math ,  Persistent Data ,  Points Library ,  Simple Security ,  Easy Social ,  Shuffle Bags ,  ... more    External  A few libraries by folks that I find useful. ( Appropriate licenses listed and included. )", 
            "title": "What Is It?"
        }, 
        {
            "location": "/#where-can-i-get-it", 
            "text": "You can find  SSK2  here   Also coming soon to the ...  ( You can also see my full list of products on  RG Docs . )", 
            "title": "Where Can I Get It?"
        }, 
        {
            "location": "/#installing-ssk2", 
            "text": "To use SSK2, simply:   Copy the ssk2 folder and its contents to the same folder as your main.lua file.  Add this to main.lua at or very near the top of the file:   require  ssk2.loadSSK \n_G.ssk.init()  Tip:  SSK2 adds extra features to Lua and Corona so it is best to initialize it  prior  to requiring any other libraries or modules.", 
            "title": "Installing SSK2"
        }, 
        {
            "location": "/#configuring-ssk2", 
            "text": "The initialization example shown above uses the default settings for SSK2.  You may want to change that.    ssk.init()  takes an optional table of key-value pairs  { key1=value1, ..., keyN=valueN }  that allows you to configure the myriad options SSK2 provides.", 
            "title": "Configuring SSK2"
        }, 
        {
            "location": "/#configuration-settings", 
            "text": "debugLevel  ( 0 ) - Values higher than 0 turn on debug messaging in SSK2 modules and libraries.  Valid range: [0, 2]    exportCore  ( true )  - If set to true, SSK2 'exports' a number of values into the global ( _G ) namespace.    See SSK  Globals  for more details.    exportColors  ( true )  - If set to  true , SSK2 'exports' a number of color values and functions into the global ( _G ) namespace.    See SSK  ssk.colors.*  for more details.    exportSystem  ( false )  - If set to true, SSK2 'exports' a number of values into the global ( _G ) namespace.    See  ssk.system.*  for more details.    gameFont  ( native.systemFont ) - SSK2 uses a 'default' font for buttons and some other features.  You can specify that default font by providing the name of a valid  ttf  or  otf  file in this setting.  launchArgs  ( nil ) - Takes the value  ...  which is only available in main.lua.  If provided it is used to further refine SSK2 settings based on what Corona has discovered about the current 'device' and passed on to your app in the launch args.  math2DPlugin  ( false ) - If set to  true , SSK2 will try to use the native  math2d  instead of the built-in Lua-only version.  If it cannot find the plugin, it will safely fall back to the Lua version.  measure  ( false ) - If set to  true  SSK2 will dump a listing of each library name and size to the console.  useExternal  ( false ) - If set to  true  SSK2 will load  external  libraries.  Tip:  This content must be  downloaded  first!", 
            "title": "Configuration Settings:"
        }, 
        {
            "location": "/#example", 
            "text": "_G.ssk.init( { launchArgs = ..., \n               measure = true,  \n               gameFont =  Raleway-Light.ttf , \n               math2DPlugin = true,\n               debugLevel = 2 } )", 
            "title": "Example"
        }, 
        {
            "location": "/#validation-sampler", 
            "text": "As time proceeds, there will me more and more free and paid content available using SSK2... but for now you can take a look at the  Validation Sampler  that comes with SSK2.  You will find the  Validation Sampler  in the ZIP-file you downloaded under  ~/validation .  To run the sampler, do the following:   Copy the  ssk2/  folder (and all its contents) into  ~/validation/ .  Open main.lua in the  SIMULATOR .  This will display a menu of samples you can run.  Click on any sample button to run that sample.  Re-load simulator (CTRL+R or CMD+R) to see the menu again.   (Although it will work, the sampler is not designed to run easily on a device.  i.e. You will need to quit the app to run a new sample.)  [ ]", 
            "title": "Validation Sampler"
        }, 
        {
            "location": "/#metrics", 
            "text": "For those folks who love metrics (admit it, you do), here are a few interesting details about SSK2.", 
            "title": "Metrics"
        }, 
        {
            "location": "/#lines-of-code-comments", 
            "text": "Counting with  cloc  I get these metrics:  -------------------------------------------------------------------------------\nLanguage                     files          blank        comment           code\n-------------------------------------------------------------------------------\nLua                             68           2398           2580          10836\n-------------------------------------------------------------------------------", 
            "title": "Lines Of Code &amp; Comments"
        }, 
        {
            "location": "/#memory-footprint", 
            "text": "A measurement of memory used per-library and in total:  --------------------------------------------------------------------------\n-- Initalizing SSK\n--------------------------------------------------------------------------\nssk2.core                                                    :       7 KB\nssk2.extensions.display                                      :       1 KB\nssk2.extensions.io                                           :       7 KB\nssk2.extensions.math                                         :       5 KB\nssk2.extensions.native                                       :       3 KB\nssk2.extensions.string                                       :      13 KB\nssk2.extensions.table                                        :      24 KB\nssk2.extensions.transition                                   :       3 KB\nssk2.system                                                  :       2 KB\nssk2.android                                                 :       1 KB\nssk2.colors                                                  :      16 KB\nssk2.security                                                :       9 KB\nssk2.persist                                                 :       2 KB\nssk2.math2d                                                  :      12 KB\nssk2.cc                                                      :       6 KB\nssk2.points                                                  :       4 KB\nssk2.actions.actions                                         :      22 KB\nssk2.soundMgr                                                :      15 KB\nssk2.easyDisplay                                             :      51 KB\nssk2.easyIFC                                                 :     121 KB\nssk2.easyInputs                                              :      70 KB\nssk2.easyCamera                                              :      12 KB\nssk2.easySocial                                              :       2 KB\nssk2.misc                                                    :      44 KB\nssk2.shuffleBag                                              :       4 KB\nssk2.meters                                                  :       7 KB\nssk2.external.mydevelopers.autolan.client                    :      26 KB\nssk2.external.mydevelopers.autolan.server                    :      23 KB\nssk2.external.proxy                                          :       1 KB\nssk2.external.wait                                           :       2 KB\nssk2.external.randomlua                                      :       7 KB\nssk2.external.30log                                          :       5 KB\nssk2.external.portableRandom                                 :       4 KB\n--------------------------------------------------------------------------\nSSK Total                                                    :  529.86 KB\n--------------------------------------------------------------------------  Tip:  While I find it useful to have all parts of SSK2 present during development, I sometimes remove elements I'm not using during production.     To teach you about this, I will be soon write an article called:  SLIMMING DOWN SSK2    ~  The Roaming Gamer", 
            "title": "Memory Footprint"
        }, 
        {
            "location": "/#help", 
            "text": "", 
            "title": "Help!"
        }, 
        {
            "location": "/#dont-panic", 
            "text": "Are you having a problem with SSK2?  If so, don't panic.  I regularly update SSK2 and its co-products.  Most of the time problems can simply be traced back to not having the most up-to-date version of SSK2.", 
            "title": "Don't Panic"
        }, 
        {
            "location": "/#are-you-using-the-latest-version", 
            "text": "Add this code at the end of main.lua  print(  SSK VERSION:   .. ssk.getVersion() )  If this prints out  SSK VERSION: 2016.001  you have the latest version.   If not, then go download a new copy from your store page.  Tip:  While you are checking, be sure to check that your co-products are up-to-date too.", 
            "title": "Are You Using The Latest Version?"
        }, 
        {
            "location": "/#are-you-getting-errors", 
            "text": "Did you get an error dialog, or are you seeing error/warning message in the console?    If so, read them and see if you have made a mistake on the line indicated.  If you think its me and not you, post a question in the forums.  (See  Posting Questions To Forums  below.)", 
            "title": "Are You Getting Errors?"
        }, 
        {
            "location": "/#are-you-typing-ssk2", 
            "text": "You may have noticed that while this is called SSK  2 , I still use the old naming convention  ssk.someFunction()  in my samples.    \"Why,\" you ask?  I am a lazy coder and proud of it. Even one extra letter is too much repetetive typing for me.  Also, I'm and  old dog , and as the saying goes,  \"You can't teach an old dog new tricks.\"  So, if you have been doing this:  ssk2.someFunction() , get rid of the  2  and you will be good to go.", 
            "title": "Are you typing ssk2?"
        }, 
        {
            "location": "/#ssk2-ssk-legacy", 
            "text": "This is the guide for SSK2.  If you are trying to use Legacy SSK and following this guide... well many things have changed.  Please consider getting SSK2.   Get SSK2 Now!  It will be worth every penny!  ~  The Roaming Gamer", 
            "title": "SSK2 ~= SSK Legacy"
        }, 
        {
            "location": "/#posting-questions-to-the-forums", 
            "text": "I will be providing help (exclusively) through the  Corona SDK Forums .  ( Sorry: Direct e-mails will not be answered. )  When posting a question in the forums, be sure to follow these guidelines:   Post to this forum:  https://forums.coronalabs.com/forum/553-other-third-party-tools/  Make sure the  title  starts with:  SSK2  and includes a short and meaninful name for the the problem.  Example Title:  SSK2: newImageRect() Paint Fill Parameter Not Working    In the  body  of the post tell me all of the following:  Versions / Environment / Target  Version of SSK you are using.  Version of Corona SDK you are using.  OS you are developing under.  Where you are encountering the issue (Simulator(s) and or Device(s)).    Error Message(s) (If Any)  Error messages (put them in a code block for legibility)    Summary Of Problem  What you are trying to do.  What you expected to see.  What you saw instead.  Why you think this is wrong (if there is no explicit error message.)    Help Thyself  Tell me what debugging steps you have tried.        Be clear, concise and precise. \nThe more effort you put into your post, the better I will be able to help you.   ~  The Roaming Gamer     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Posting Questions To The Forums"
        }, 
        {
            "location": "/globals/", 
            "text": "Global Variables\n\n\nA set of (core) variables designed to save typing and time, period.\n\n\n\n\n\n\n\n\nVariable(s)\n\n\nEquivalent To\n\n\n\n\n\n\n\n\n\n\nw, h\n\n\ndisplay.contentWidth\n, \ndisplay.contentHeight\n\n\n\n\n\n\ncenterX, centerY\n\n\ndisplay.actualContentWidth\n, \ndisplay.actualContentWidth\n\n\n\n\n\n\nfullw, fullh\n\n\ndisplay.actualContentWidth\n, \ndisplay.actualContentWidth\n\n\n\n\n\n\nunusedWidth, unusedHeight\n\n\nfullw - w\n and \nfullh - h\n respetively.\n\n\n\n\n\n\nleft, right, top, bottom\n\n\nCalculated\n positions for the true edges of the screen, regardless of scaling used.\n\n\n\n\n\n\n\n\nGlobal Functions\n\n\nA set of (core) functions designed to save time writing common code.\n\n\nRuntime:* Improvements\n\n\nThe following functions improve on the Runtime:* event functions.\n\n\n\n\n\n\n\n\nSyntax\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\nlisten( name, listener )\n\n\nShorthand equivalent to \nRuntime:addEventListner( event, listener )\n\n\n\n\n\n\nignore( name, listener )\n\n\nShorthand equivalent to \nRuntime:removeEventListner( event, listener )\n\n\n\n\n\n\nignoreList( list, obj )\n\n\nRemoves all listeners in table \nlist\n if found on \nobj\n.\n\n\n\n\n\n\npost( name, [ params [, debuglvl ]] )\n\n\nDispatches \nname\n event with optional \nparams\n table.\n\n\n\n\n\n\nautoIgnore( name, obj )\n\n\nStop listening for \nname\n event if \nobj\n is \ninvalid\n.\n\n\n\n\n\n\n\n\nGeneral\n\n\nA (small) set of utility functions that I use very frequently.\n\n\n\n\n\n\n\n\nSyntax\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\nfnn( ... )\n\n\nReturn first argument from list that is not nil.\n\n\n\n\n\n\nround( val [ , n  ])\n\n\nRounds a number to the nearest decimal place.\n\n\n\n\n\n\nnextFrame( func )\n\n\nExecute func in new frame. (Credit: \nSergey Lerg\n)\n\n\n\n\n\n\n\n\nStop Exporting Globals\n\n\nThe functions and variables listed above are part of ssk.core.*.  \n\n\nI export them as globals (_G.*) because I find them extremely useful.\n\n\nIf, on the other hand, you feel this '\npollutes\n' the global space, you can disable exporting, during \ninitialization\n.\n\n\n_G.ssk.init( { exportCore = false } )\n\n\n\n\nTip:\n Just remember, if you stop exporting globals, you must use full names to access them (ick!):\n\n\n\nnewCircle( group, ssk.core.centerX, ssk.core.bottom - 20, { radius = 20, fill = _BRIGHTORANGE_ } )\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Globals"
        }, 
        {
            "location": "/globals/#global-variables", 
            "text": "A set of (core) variables designed to save typing and time, period.     Variable(s)  Equivalent To      w, h  display.contentWidth ,  display.contentHeight    centerX, centerY  display.actualContentWidth ,  display.actualContentWidth    fullw, fullh  display.actualContentWidth ,  display.actualContentWidth    unusedWidth, unusedHeight  fullw - w  and  fullh - h  respetively.    left, right, top, bottom  Calculated  positions for the true edges of the screen, regardless of scaling used.", 
            "title": "Global Variables"
        }, 
        {
            "location": "/globals/#global-functions", 
            "text": "A set of (core) functions designed to save time writing common code.", 
            "title": "Global Functions"
        }, 
        {
            "location": "/globals/#runtime-improvements", 
            "text": "The following functions improve on the Runtime:* event functions.     Syntax  Summary      listen( name, listener )  Shorthand equivalent to  Runtime:addEventListner( event, listener )    ignore( name, listener )  Shorthand equivalent to  Runtime:removeEventListner( event, listener )    ignoreList( list, obj )  Removes all listeners in table  list  if found on  obj .    post( name, [ params [, debuglvl ]] )  Dispatches  name  event with optional  params  table.    autoIgnore( name, obj )  Stop listening for  name  event if  obj  is  invalid .", 
            "title": "Runtime:* Improvements"
        }, 
        {
            "location": "/globals/#general", 
            "text": "A (small) set of utility functions that I use very frequently.     Syntax  Summary      fnn( ... )  Return first argument from list that is not nil.    round( val [ , n  ])  Rounds a number to the nearest decimal place.    nextFrame( func )  Execute func in new frame. (Credit:  Sergey Lerg )", 
            "title": "General"
        }, 
        {
            "location": "/globals/#stop-exporting-globals", 
            "text": "The functions and variables listed above are part of ssk.core.*.    I export them as globals (_G.*) because I find them extremely useful.  If, on the other hand, you feel this ' pollutes ' the global space, you can disable exporting, during  initialization .  _G.ssk.init( { exportCore = false } )  Tip:  Just remember, if you stop exporting globals, you must use full names to access them (ick!):  \nnewCircle( group, ssk.core.centerX, ssk.core.bottom - 20, { radius = 20, fill = _BRIGHTORANGE_ } )     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Stop Exporting Globals"
        }, 
        {
            "location": "/extensions/", 
            "text": "Extensions\n\n\nSSK extends a number of Lua and Corona libraries/functions.  \n\n\ndisplay.*\n\n\n\n\n\n\n\n\nFunction\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\nnewContainer( ... )\n\n\nAdds flags \n__isContainer = true\n and \n__isGroup = true\n to returned container.\n\n\n\n\n\n\nnewGroup( )\n\n\nAdds flags \n__isContainer = false\n and \n__isGroup = true\n to returned group.\n\n\n\n\n\n\n\n\nio.*\n\n\nNote:\n Unless otherwise specified, if a function takes the (optional) argument \nbase\n, it defaults to \nsystem.DocumentsDirectory\n\n\n\n\n\n\n\n\nFunction\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\nappendFile( dataToWrite, fileName [ , base ] )\n\n\nAppend the contents of string \ndataToWrite\n to the file \nfileName\n, creating file if it does not exist.\n\n\n\n\n\n\ncleanFileName( filename )\n\n\nCleans the string \nfilename\n to ensure it is safe for use as a file name in all OSes targted by Corona SDK.\n\n\n\n\n\n\nexists( fileName [, base ] )\n\n\nReturns \ntrue\n if path exists.\n\n\n\n\n\n\nmkdir( dirName [, base ] )\n\n\nMake a new directory with the name \ndirName\n.  (\nWarning:\n Parent folders must be created first for compound paths.)\n\n\n\n\n\n\nreadFile( fileName [, base ] )\n\n\nReturns contents of file at \nfileName\n as string.\n\n\n\n\n\n\nreadFileTable( fileName [, base ] )\n\n\nRead the contens of fileName and return it as a table, where each entry is a line from the file.  Lines are separated by newline (\n\\n\n).\n\n\n\n\n\n\nrepairPath( path )\n\n\nChanges 'slashes' in path to match current OS specifications.\n\n\n\n\n\n\nwriteFile( dataToWrite, fileName [ , base ] )\n\n\nWrite the contents of string \ndataToWrite\n to the file \nfileName\n.\n\n\n\n\n\n\n\n\nmath.*\n\n\n\n\n\n\n\n\nFunction\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\ngetUID( rlen )\n\n\nGenerates and returns a unique ID of length \nrlen\n.  \nWarning:\n With a \nrlen\n of 12 or higher, it is extremely unlikely you will get an id collision, but it is your responsibility to track your prior IDs and verify no collision occurs.\n\n\n\n\n\n\nhaversine_dist( lat1, lng1, lat2, lng2 [, R ] )\n\n\nCalculate the distance from GPS position to another. Distance is a multiple of R (default is 6373 kilometers == 3961 miles.)\n\n\n\n\n\n\nnormRot( toNorm )\n (number)\n\n\nModifies number \ntoNorm\n and returns equivalent angle in range [0,360).\n\n\n\n\n\n\nnormRot( toNorm )\n (display object)\n\n\nModifies display object \ntoNorm\n, such that \nrotation\n is an equivalent value in range [0,360).\n\n\n\n\n\n\n\n\nstring.*\n\n\n\n\n\n\n\n\nFunction\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\ncomma_value( num )\n\n\nReturns a nicely comma-separated string version of number \nnum\n.\n\n\n\n\n\n\nendswith( str, piece)\n\n\nReturn \ntrue\n if \nstr\n ends with \npiece\n. \nCredit: Sergey Lerg\n\n\n\n\n\n\nfirst_upper( str )\n\n\nConvert first letter in \nstr\n to upper-case.\n\n\n\n\n\n\nlpad( str, len [, char] )\n\n\nPlaces padding on left side of a string, such that the new string is at  least len characters long.\n\n\n\n\n\n\nmerge( t )\n\n\nReturn a string containing all entries in an indexed table concatenated together.\n\n\n\n\n\n\nprintf( ... )\n\n\nReplicates C-language printf().\n\n\n\n\n\n\nrpad( str, len [, char] )\n\n\nPlaces padding on right side of a string, such that the new string is at least len characters long.\n\n\n\n\n\n\nspaces2underbars( str )\n\n\nReturns string converting all spaces (\n) in \nstr\n to underbars (\n_\n).\n\n\n\n\n\n\nsplit( str, tok)\n\n\nSplit \nstr\n into a table, where elements in the string are separated by the token \ntok\n.\n\n\n\n\n\n\nstartswith( str, piece)\n\n\nReturn \ntrue\n if \nstr\n starts with \npiece\n. \nCredit: Sergey Lerg\n\n\n\n\n\n\ntrim( str )\n\n\nRemove all whitespace from beginning and end of \nstr\n.\n\n\n\n\n\n\ntruncate( str, maxLen [, appendMe ] )\n\n\nShorten \nstr\n to maxLen and optionally append \nappendMe\n to indicate string has been truncated.\n\n\n\n\n\n\nunderbars2spaces( str )\n\n\nReturns string converting all underbars (\n_\n) in \nstr\n to spaces (\n).\n\n\n\n\n\n\nurl_decode( str )\n\n\nReturns URL decoded version of \nstr\n.\n\n\n\n\n\n\nurl_encode( str )\n\n\nReturns URL encoded version of \nstr\n.\n\n\n\n\n\n\n\n\nTorque Derived String Functions\n\n\nI added a number of functions to string.* based on same-named functions from Torque.  These functions operate on:\n\n\n\n\nWords - Strings containing elements separated by a space (\n).\n\n\nFields - Strings containing elements separated by a tab (\n\\t\n)\n\n\nRecords - Strings containing elements separated by a newline (\n\\n\n)\n\n\n\n\n\n\n\n\n\n\nFunction\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\ngetWord( str [, index ] )\n\n\nReturns \nindex\n (\n1\n) word in \nstr\n.\n\n\n\n\n\n\ngetWordCount( str )\n\n\nCounts words in \nstr\n.\n\n\n\n\n\n\ngetWords( str, [ index [, endindex ]] )\n\n\nReturns a string containing all words in \nstr\n between \nindex\n (\n1\n) and \nendindex\n (\nlast word\n).\n\n\n\n\n\n\nsetWord( str, [ index [, replace ]] )\n\n\nReturns a string where the word in \nstr\n at \nindex\n (\n1\n) has been replaced with the string \nreplace\n (\nnil\n).\n\n\n\n\n\n\ngetField( str [, index ] )\n\n\nField\n equivalent of \ngetWord()\n\n\n\n\n\n\ngetFieldCount( str )\n\n\nField\n equivalent of \ngetWordCount()\n\n\n\n\n\n\ngetFields( str, [ index [, endindex ]] )\n\n\nField\n equivalent of \ngetWords()\n\n\n\n\n\n\nsetField( str, [ index [, replace ]] )\n\n\nField\n equivalent of \nsetWord()\n\n\n\n\n\n\ngetRecord( str [, index ] )\n\n\nRecord\n equivalent of \ngetWord()\n\n\n\n\n\n\ngetRecordCount( str )\n\n\nRecord\n equivalent of \ngetWordCount()\n\n\n\n\n\n\ngetRecords( str, [ index [, endindex ]] )\n\n\nRecord\n equivalent of \ngetWords()\n\n\n\n\n\n\nsetRecord( str, [ index [, replace ]] )\n\n\nRecord\n equivalent of \nsetWord()\n\n\n\n\n\n\n\n\ntable.*\n\n\nTable Debug Features\n\n\n\n\n\n\n\n\nFunction\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\ndump(theTable [ , padding [ , marker ]]  )\n\n\nDumps indexes and values inside single-level table (for debug) (SORTED).\n\n\n\n\n\n\ndumpu(theTable [ , padding [ , marker ]]  )\n\n\nDumps indexes and values inside single-level table (for debug) (UNSORTED).\n\n\n\n\n\n\nprint_r( t )\n\n\nDumps indexes and values inside multi-level table (for debug)\n\n\n\n\n\n\n\n\nSaving \n Loading Tables\n\n\nNote:\n Unless otherwise specified, if a function takes the (optional) argument \nbase\n, it defaults to \nsystem.DocumentsDirectory\n\n\n\n\n\n\n\n\nFunction\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\nload( fileName [ , base ] )\n\n\nReturns table loaded from file (Uses JSON library as intermediary)\n\n\n\n\n\n\nprettySave( theTable, fileName [ , base ] )\n\n\nSaves table to file as human readable JSON.\n\n\n\n\n\n\nrepairIndicies( theTable )\n\n\nRepair numeric indicies in table that uses numbers and other values for indexing.  Combining index types like this is bad practice if you are going to save() and load() the table.  This function repairs the indices after a load.\n\n\n\n\n\n\nsave( theTable, fileName [ , base ] )\n\n\nSaves table to file (Uses JSON library as intermediary)\n\n\n\n\n\n\nsecure_save( theTable, fileName [ , base ] )\n\n\nEquivalent to save(), but uses ssk.security.* to obfuscate save.\n\n\n\n\n\n\nsecure_load( theTable, fileName [ , base ] )\n\n\nEquivalent to load(), but uses ssk.security.* to obfuscate save.\n\n\n\n\n\n\nstripSave( theTable, fileName [ , base ] )\n\n\nSaves table to file (Uses JSON library as intermediary)\n\n\n\n\n\n\n\n\nTable Utilities\n\n\n\n\n\n\n\n\nFunction\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\ncombineUnique( ... )\n\n\nCombines n tables into a single table containing only unique members from each source table.\n\n\n\n\n\n\ncombineUnique_i( ... )\n\n\nCombines n tables into a single table containing only unique members from each source table.\n\n\n\n\n\n\ncount( t )\n\n\nCounts all entries in table (non-recursive).\n\n\n\n\n\n\ncount_r( t )\n\n\nCounts all entries in table (recursive).\n\n\n\n\n\n\ndeepCopy( src [ , dst ])\n\n\nCopies multi-level tables; handles non-integer indexes; does not copy metatable\n\n\n\n\n\n\ndeepStripCopy( src [ , dst ])\n\n\nCopies multi-level tables, but strips out metatable(s) and  Fields with these value types: functions or userdata; Fields with these these names: _class or __index.\n\n\n\n\n\n\ngetRandom( t )\n\n\nReturn randomly selected entry from table \nt\n.\n\n\n\n\n\n\nmaxIndex( t )\n\n\nDetermine the maximum index of a sparse table.\n\n\n\n\n\n\nremoveByRef( t, obj )\n\n\nLocate entry \nobj\n in numerically indexed table \nt\n and remove it.  \nCredit: Sergey Lerg\n\n\n\n\n\n\nserialize( t )\n\n\nTable Serializer: https://github.com/EmmanuelOga/columns/blob/master/utils/serialize.lua\n\n\n\n\n\n\nshallowCopy( src [ , dst ])\n\n\nCopies single-level tables; handles non-integer indexes; does not copy metatable\n\n\n\n\n\n\nshallowStripCopy( src, dst )\n\n\nCopies single-level tables; handles non-integer indexes; does not copy metatable\n\n\n\n\n\n\nshuffle( t [, iter ] )\n\n\nRandomizes the order of a numerically indexed (non-sparse) table.  Supply iteration value \niter\n (\n1\n) for better randomizing.\n\n\n\n\n\n\ntoString( t [, flat ]) )\n\n\nConverts table to string (serializes it). \nCredit: Jason Schroeder\n\n\n\n\n\n\n\n\ntransition.*\n\n\ncolor\n\n\nAdds ability to transition the color of display objects (including text objects) from \nfromColor\n to \ntoColor\n.\n\n\ntransition.color( obj, params )\n\n\n\n\n\n\nobj\n - Text or other display object that supports \nsetFillColor()\n.\n\n\nparams\n (\n{}\n) - Transition control parameters.\n\n\nfromColor\n (\n_W_\n) - Starting color.\n\n\ntoColor\n (\n_W_\n) - Ending color.\n\n\ndelay\n (\nnil\n) - Time to wait before transitioning in milliseconds.\n\n\ntime\n (\n_W_\n) - Time to transition in milliseconds.\n\n\ntransition\n (\n_W_\n) - \nEasing\n to use for transition.\n\n\nonComplete\n (\nnil\n) - Listener to call on completion of transition.\n\n\n\n\n\n\n\n\n\nlocal tmp = ssk.display.newCircle( nil, centerX, centerY, { radius = 30, fill = _R_ } )\n\nfunction tmp.onComplete( self )\n   print(\nDone transitioning color.\n)\nend\n\ntransition.color( tmp, { fromColor = _R_, toColor = _G_, time = 1000, \n                         transition = easing.outCirc, onComplete = tmp } )\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Extensions"
        }, 
        {
            "location": "/extensions/#extensions", 
            "text": "SSK extends a number of Lua and Corona libraries/functions.", 
            "title": "Extensions"
        }, 
        {
            "location": "/extensions/#display", 
            "text": "Function  Summary      newContainer( ... )  Adds flags  __isContainer = true  and  __isGroup = true  to returned container.    newGroup( )  Adds flags  __isContainer = false  and  __isGroup = true  to returned group.", 
            "title": "display.*"
        }, 
        {
            "location": "/extensions/#io", 
            "text": "Note:  Unless otherwise specified, if a function takes the (optional) argument  base , it defaults to  system.DocumentsDirectory     Function  Summary      appendFile( dataToWrite, fileName [ , base ] )  Append the contents of string  dataToWrite  to the file  fileName , creating file if it does not exist.    cleanFileName( filename )  Cleans the string  filename  to ensure it is safe for use as a file name in all OSes targted by Corona SDK.    exists( fileName [, base ] )  Returns  true  if path exists.    mkdir( dirName [, base ] )  Make a new directory with the name  dirName .  ( Warning:  Parent folders must be created first for compound paths.)    readFile( fileName [, base ] )  Returns contents of file at  fileName  as string.    readFileTable( fileName [, base ] )  Read the contens of fileName and return it as a table, where each entry is a line from the file.  Lines are separated by newline ( \\n ).    repairPath( path )  Changes 'slashes' in path to match current OS specifications.    writeFile( dataToWrite, fileName [ , base ] )  Write the contents of string  dataToWrite  to the file  fileName .", 
            "title": "io.*"
        }, 
        {
            "location": "/extensions/#math", 
            "text": "Function  Summary      getUID( rlen )  Generates and returns a unique ID of length  rlen .   Warning:  With a  rlen  of 12 or higher, it is extremely unlikely you will get an id collision, but it is your responsibility to track your prior IDs and verify no collision occurs.    haversine_dist( lat1, lng1, lat2, lng2 [, R ] )  Calculate the distance from GPS position to another. Distance is a multiple of R (default is 6373 kilometers == 3961 miles.)    normRot( toNorm )  (number)  Modifies number  toNorm  and returns equivalent angle in range [0,360).    normRot( toNorm )  (display object)  Modifies display object  toNorm , such that  rotation  is an equivalent value in range [0,360).", 
            "title": "math.*"
        }, 
        {
            "location": "/extensions/#string", 
            "text": "Function  Summary      comma_value( num )  Returns a nicely comma-separated string version of number  num .    endswith( str, piece)  Return  true  if  str  ends with  piece .  Credit: Sergey Lerg    first_upper( str )  Convert first letter in  str  to upper-case.    lpad( str, len [, char] )  Places padding on left side of a string, such that the new string is at  least len characters long.    merge( t )  Return a string containing all entries in an indexed table concatenated together.    printf( ... )  Replicates C-language printf().    rpad( str, len [, char] )  Places padding on right side of a string, such that the new string is at least len characters long.    spaces2underbars( str )  Returns string converting all spaces ( ) in  str  to underbars ( _ ).    split( str, tok)  Split  str  into a table, where elements in the string are separated by the token  tok .    startswith( str, piece)  Return  true  if  str  starts with  piece .  Credit: Sergey Lerg    trim( str )  Remove all whitespace from beginning and end of  str .    truncate( str, maxLen [, appendMe ] )  Shorten  str  to maxLen and optionally append  appendMe  to indicate string has been truncated.    underbars2spaces( str )  Returns string converting all underbars ( _ ) in  str  to spaces ( ).    url_decode( str )  Returns URL decoded version of  str .    url_encode( str )  Returns URL encoded version of  str .", 
            "title": "string.*"
        }, 
        {
            "location": "/extensions/#torque-derived-string-functions", 
            "text": "I added a number of functions to string.* based on same-named functions from Torque.  These functions operate on:   Words - Strings containing elements separated by a space ( ).  Fields - Strings containing elements separated by a tab ( \\t )  Records - Strings containing elements separated by a newline ( \\n )      Function  Summary      getWord( str [, index ] )  Returns  index  ( 1 ) word in  str .    getWordCount( str )  Counts words in  str .    getWords( str, [ index [, endindex ]] )  Returns a string containing all words in  str  between  index  ( 1 ) and  endindex  ( last word ).    setWord( str, [ index [, replace ]] )  Returns a string where the word in  str  at  index  ( 1 ) has been replaced with the string  replace  ( nil ).    getField( str [, index ] )  Field  equivalent of  getWord()    getFieldCount( str )  Field  equivalent of  getWordCount()    getFields( str, [ index [, endindex ]] )  Field  equivalent of  getWords()    setField( str, [ index [, replace ]] )  Field  equivalent of  setWord()    getRecord( str [, index ] )  Record  equivalent of  getWord()    getRecordCount( str )  Record  equivalent of  getWordCount()    getRecords( str, [ index [, endindex ]] )  Record  equivalent of  getWords()    setRecord( str, [ index [, replace ]] )  Record  equivalent of  setWord()", 
            "title": "Torque Derived String Functions"
        }, 
        {
            "location": "/extensions/#table", 
            "text": "", 
            "title": "table.*"
        }, 
        {
            "location": "/extensions/#table-debug-features", 
            "text": "Function  Summary      dump(theTable [ , padding [ , marker ]]  )  Dumps indexes and values inside single-level table (for debug) (SORTED).    dumpu(theTable [ , padding [ , marker ]]  )  Dumps indexes and values inside single-level table (for debug) (UNSORTED).    print_r( t )  Dumps indexes and values inside multi-level table (for debug)", 
            "title": "Table Debug Features"
        }, 
        {
            "location": "/extensions/#saving-loading-tables", 
            "text": "Note:  Unless otherwise specified, if a function takes the (optional) argument  base , it defaults to  system.DocumentsDirectory     Function  Summary      load( fileName [ , base ] )  Returns table loaded from file (Uses JSON library as intermediary)    prettySave( theTable, fileName [ , base ] )  Saves table to file as human readable JSON.    repairIndicies( theTable )  Repair numeric indicies in table that uses numbers and other values for indexing.  Combining index types like this is bad practice if you are going to save() and load() the table.  This function repairs the indices after a load.    save( theTable, fileName [ , base ] )  Saves table to file (Uses JSON library as intermediary)    secure_save( theTable, fileName [ , base ] )  Equivalent to save(), but uses ssk.security.* to obfuscate save.    secure_load( theTable, fileName [ , base ] )  Equivalent to load(), but uses ssk.security.* to obfuscate save.    stripSave( theTable, fileName [ , base ] )  Saves table to file (Uses JSON library as intermediary)", 
            "title": "Saving &amp; Loading Tables"
        }, 
        {
            "location": "/extensions/#table-utilities", 
            "text": "Function  Summary      combineUnique( ... )  Combines n tables into a single table containing only unique members from each source table.    combineUnique_i( ... )  Combines n tables into a single table containing only unique members from each source table.    count( t )  Counts all entries in table (non-recursive).    count_r( t )  Counts all entries in table (recursive).    deepCopy( src [ , dst ])  Copies multi-level tables; handles non-integer indexes; does not copy metatable    deepStripCopy( src [ , dst ])  Copies multi-level tables, but strips out metatable(s) and  Fields with these value types: functions or userdata; Fields with these these names: _class or __index.    getRandom( t )  Return randomly selected entry from table  t .    maxIndex( t )  Determine the maximum index of a sparse table.    removeByRef( t, obj )  Locate entry  obj  in numerically indexed table  t  and remove it.   Credit: Sergey Lerg    serialize( t )  Table Serializer: https://github.com/EmmanuelOga/columns/blob/master/utils/serialize.lua    shallowCopy( src [ , dst ])  Copies single-level tables; handles non-integer indexes; does not copy metatable    shallowStripCopy( src, dst )  Copies single-level tables; handles non-integer indexes; does not copy metatable    shuffle( t [, iter ] )  Randomizes the order of a numerically indexed (non-sparse) table.  Supply iteration value  iter  ( 1 ) for better randomizing.    toString( t [, flat ]) )  Converts table to string (serializes it).  Credit: Jason Schroeder", 
            "title": "Table Utilities"
        }, 
        {
            "location": "/extensions/#transition", 
            "text": "", 
            "title": "transition.*"
        }, 
        {
            "location": "/extensions/#color", 
            "text": "Adds ability to transition the color of display objects (including text objects) from  fromColor  to  toColor .  transition.color( obj, params )   obj  - Text or other display object that supports  setFillColor() .  params  ( {} ) - Transition control parameters.  fromColor  ( _W_ ) - Starting color.  toColor  ( _W_ ) - Ending color.  delay  ( nil ) - Time to wait before transitioning in milliseconds.  time  ( _W_ ) - Time to transition in milliseconds.  transition  ( _W_ ) -  Easing  to use for transition.  onComplete  ( nil ) - Listener to call on completion of transition.     \nlocal tmp = ssk.display.newCircle( nil, centerX, centerY, { radius = 30, fill = _R_ } )\n\nfunction tmp.onComplete( self )\n   print( Done transitioning color. )\nend\n\ntransition.color( tmp, { fromColor = _R_, toColor = _G_, time = 1000, \n                         transition = easing.outCirc, onComplete = tmp } )     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "color"
        }, 
        {
            "location": "/libraries/colors/", 
            "text": "Colors Library (ssk.colors.*)\n\n\nEasy Colors (ssk.colors.easy.*)\n\n\nTip:\n These variables are exported as globals when SSK \ninit()\n parameter \nexportColors\n is \ntrue\n.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n_WHITE_\n, \n_W_\n\n\n_BLACK_\n, \n_K_\n\n\n_TRANSPARENT_\n, \n_T_\n\n\n\n\n\n\n_RED_\n, \n_R_\n\n\n_GREEN_\n, \n_G_\n\n\n_BLUE_\n, \n_B_\n\n\n\n\n\n\n_LIGHTGREY_\n\n\n_GREY_\n\n\n_DARKGREY_\n\n\n\n\n\n\n_CYAN_\n, \n_C_\n\n\n_YELLOW_\n, \n_Y_\n\n\n_ORANGE_\n, \n_O_\n\n\n\n\n\n\n_PURPLE_\n\n\n_PINK_\n, \n_P_\n\n\n\n\n\n\n\n\n\n\n\nlocal circ = display.newCircle( 100, 100, 100 )\n\nrect:setFillColor( unpack( _PURPLE_ ) )\n\n\n\n\n\nColor Helpers and Utilities (ssk.colors.*)\n\n\nTip:\n These functions are exported as globals when SSK \ninit()\n parameter \nexportColors\n is \ntrue\n.\n\n\n\n\nhexcolor( code )\n - converts hex color codes to rgba Graphics 2.0 value\n\n\nrandomColor( )\n - Returns random  color selected from 'Easy Colors'.\n\n\nrgba2( colors )\n - Converts Graphics 1.0 color table to a valid Graphics 2.0 color table.\n\n\n\n\n\nlocal rect1 = display.newRect( 100, 100, 100, 100 )\nlocal rect2 = display.newRect( 100, 100, 200, 100 )\nlocal rect3 = display.newRect( 100, 100, 300, 100 )\n\n-- Set fill color to a nice blue\nrect1:setFillColor( unpack( hexcolor( \n33AFFF\n ) ) )\n\n-- Choose a random Easy Color as the fill\nrect2:setFillColor( unpack( randomColor() ) )\n\n-- Set color to Graphics 1.0 encoded 'Pink'\nrect3:setFillColor( unpack( rgba2( { 255, 0, 255 } ) ) )\n\n\n\n\n\nRGB\n\n\n\n\nR - Red component in the range [0,1].\n\n\nG - Green component in the range [0,1].\n\n\nB - Blue component in the range [0,1].\n\n\nA - Alpha in the range [0,1].  Assumed to be 1 if not specified.\n\n\n\n\n(\nGraphcs 1.0 used values in the range [0,255].\n)\n\n\n   local lightGrey = { 0.25, 0.25, 0.25, 1 }\n\n\n\n\nRGB Functions (ssk.colors.*)\n\n\nTip:\n These functions are NOT exported and can \nonly\n be accessed via \nssk.colors.*\n or localizations.\n\n\n\n\nrgb2hsl( r, g, b, a )\n - Convert RGB color to HSL color table.\n\n\nmixRGB( c1, c2 )\n - Evenly mix two RGBa colors.\n\n\nrandomRGB( [ c1 ] )\n - Generates a random RGB color.  If optional c1 is passed in, it is mixed evenly with the random color.\n\n\npastelRGB( [ c1 ] )\n - Generates a random RGB pastel color.  If optional c1 is passed in, it is mixed evenly with the random color.\n\n\nrgbOffset( r, g, b, a, angle )\n - Converts RGB color to HSL and applies hueOffset()\n\n\nrgbNeighbors( r, g, b, a, angle )\n - Converts RGB color to HSL and applies hslNeighbors(), then returns two rgb colors.\n\n\nrgbTriadic( r, g, b, a )\n - Converts RGB color to HSL and applies hslTriadic(), then returns two rgb colors.\n\n\nrgbSplitComplementary( r, g, b, a, angle )\n - Converts RGB color to HSL and applies hslSplitComplementary(), then returns two rgb colors.\n\n\n\n\nHSL\n\n\n\n\nH - Hue is a degree on the color wheel in the range [0,360).\n\n\n0 is red, 120 is green, 240 is blue. \n\n\nNumbers in between reflect different shades.\n\n\n\n\n\n\nS - Saturation is a percentage value in the range [0,1].\n\n\n1.0 is the full color.\n\n\n\n\n\n\nL - Lightness is also a percentage value in the range [0,1].\n\n\n0.0 is dark (black), \n\n\n1.0 1.0 is light (white)\n\n\n0.5 is the average\n\n\n\n\n\n\nA - Alpha in the range [0,1].  Assumed to be 1 if not specified.  \n\n\n\n\n\n   local cornFlowerBlue = hsl2rgb( 219, 0.79, 0.66, 1.0 )\n\n\n\n\n\nHSL Functions (ssk.colors.*)\n\n\nTip:\n These functions are NOT exported and can \nonly\n be accessed via \nssk.colors.*\n or localizations.\n\n\n\n\nhsl2rgb( h, s, l, a )\n - Convert HSL color to RGB color table.\n\n\nhueOffset( h, s, l, a, angle )\n - Rotate hue by 'angle' degrees\n\n\nhslNeighbors( h, s, l, a, angle )\n - Return two arbitray angle neighbors (left and right by angle)\n\n\nhslTriadic( h, s, l, a )\n - Return two triadic neighbors of color\n\n\nhslSplitComplementary( h, s, l, a, angle )\n - Return two complementary split angle colors. \n\n\n\n\nExamples\n\n\nRGB \n HSL\n\n\n\n\nfunction test.run( group, params )\n   group = group or display.currentStage\n   params = params or {}\n\n   local startX = left + 100\n   local startY = top + 100\n\n   local curX = startX\n   local curY = startY\n\n   -- ==============================================\n   -- Row 1 - Test conversions\n    -- ==============================================\n\n    -- RGB 2 HSL \n HSL 2 RGB\n    curX = startX\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_G_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_B_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_O_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_Y_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_P_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_PURPLE_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_GREY_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n\n   -- ==============================================\n   -- Row 2 - Test HSL HUE Offset\n    -- ==============================================\n\n    -- hueOffset\n    curX = startX\n    curY = curY + 100\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c1 = ssk.colors.hueOffset(c, 60 )\n    local c2 = ssk.colors.hsl2rgb( c1 )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c1 = ssk.colors.hueOffset(c, -60 )\n    local c2 = ssk.colors.hsl2rgb( c1 )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n   -- ==============================================\n   -- Row 3 - Test HSL Neighbors, Triadic, Split Complementary\n    -- ==============================================\n\n    -- hslNeighbors\n    curX = startX\n    curY = curY + 100\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c2,c3 = ssk.colors.hslNeighbors( c, 90 )\n    c2 = ssk.colors.hsl2rgb( c2 )\n    c3 = ssk.colors.hsl2rgb( c3 )   \n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\n\n    -- hslTriadic\n    curX = curX + 100\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c2,c3 = ssk.colors.hslTriadic( c )\n    c2 = ssk.colors.hsl2rgb( c2 )\n    c3 = ssk.colors.hsl2rgb( c3 )   \n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\n\n    -- hslSplitComplementary\n    curX = curX + 100\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c2,c3 = ssk.colors.hslSplitComplementary( c, 30 )\n    c2 = ssk.colors.hsl2rgb( c2 )\n    c3 = ssk.colors.hsl2rgb( c3 )   \n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\n\n   -- ==============================================\n   -- Row 4 - Test RGB Offset\n    -- ==============================================\n\n    -- rgbOffset\n    curX = startX\n    curY = curY + 100\n    local c1 = ssk.colors.rgbOffset( _R_, 60 )\n    newRect( group, curX, curY, { size = 80, fill = c1  } )\n\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n\n    curX = curX + 80\n    local c1 = ssk.colors.rgbOffset( _R_, -60 )\n    newRect( group, curX, curY, { size = 80, fill = c1  } )\n\n   -- ==============================================\n   -- Row 5 - Test RGB Neighbors, Triadic, Split Complementary\n    -- ==============================================\n\n    -- hslNeighbors\n    curX = startX\n    curY = curY + 100\n    local c2,c3 = ssk.colors.rgbNeighbors( _R_, 90 )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\n\n    -- rgbTriadic\n    curX = curX + 100\n    local c2,c3 = ssk.colors.rgbTriadic( _R_ )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\n\n    -- rgbSplitComplementary\n    curX = curX + 100\n    local c2,c3 = ssk.colors.rgbSplitComplementary( _R_, 30 )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\nend\n\n\n\n\nPastels\n\n\n\n\n\nfunction test.run( group, params )\n   group = group or display.currentStage\n   params = params or {}\n\n   local startX = left + 100\n   local startY = top + 100\n\n   local curX = startX\n   local curY = startY\n\n    -- Pastel No Seed Color\n    for i = 1, 3 do\n        curX = startX   \n        for j = 1, 10 do\n            newRect( group, curX, curY, { size = 80, fill = ssk.colors.pastelRGB( )  } )\n            curX = curX + 80\n        end\n        curY = curY + 80\n    end\n\n    curY = curY + 40\n\n    -- Pastel Random Seed Color\n    for i = 1, 3 do\n        curX = startX   \n        for j = 1, 10 do\n            newRect( group, curX, curY, { size = 80, fill = ssk.colors.pastelRGB( randomColor() )  } )\n            curX = curX + 80\n        end\n        curY = curY + 80\n    end\n\nend\n\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Colors (ssk.colors)"
        }, 
        {
            "location": "/libraries/colors/#colors-library-sskcolors", 
            "text": "", 
            "title": "Colors Library (ssk.colors.*)"
        }, 
        {
            "location": "/libraries/colors/#easy-colors-sskcolorseasy", 
            "text": "Tip:  These variables are exported as globals when SSK  init()  parameter  exportColors  is  true .            _WHITE_ ,  _W_  _BLACK_ ,  _K_  _TRANSPARENT_ ,  _T_    _RED_ ,  _R_  _GREEN_ ,  _G_  _BLUE_ ,  _B_    _LIGHTGREY_  _GREY_  _DARKGREY_    _CYAN_ ,  _C_  _YELLOW_ ,  _Y_  _ORANGE_ ,  _O_    _PURPLE_  _PINK_ ,  _P_      \nlocal circ = display.newCircle( 100, 100, 100 )\n\nrect:setFillColor( unpack( _PURPLE_ ) )", 
            "title": "Easy Colors (ssk.colors.easy.*)"
        }, 
        {
            "location": "/libraries/colors/#color-helpers-and-utilities-sskcolors", 
            "text": "Tip:  These functions are exported as globals when SSK  init()  parameter  exportColors  is  true .   hexcolor( code )  - converts hex color codes to rgba Graphics 2.0 value  randomColor( )  - Returns random  color selected from 'Easy Colors'.  rgba2( colors )  - Converts Graphics 1.0 color table to a valid Graphics 2.0 color table.   \nlocal rect1 = display.newRect( 100, 100, 100, 100 )\nlocal rect2 = display.newRect( 100, 100, 200, 100 )\nlocal rect3 = display.newRect( 100, 100, 300, 100 )\n\n-- Set fill color to a nice blue\nrect1:setFillColor( unpack( hexcolor(  33AFFF  ) ) )\n\n-- Choose a random Easy Color as the fill\nrect2:setFillColor( unpack( randomColor() ) )\n\n-- Set color to Graphics 1.0 encoded 'Pink'\nrect3:setFillColor( unpack( rgba2( { 255, 0, 255 } ) ) )", 
            "title": "Color Helpers and Utilities (ssk.colors.*)"
        }, 
        {
            "location": "/libraries/colors/#rgb", 
            "text": "R - Red component in the range [0,1].  G - Green component in the range [0,1].  B - Blue component in the range [0,1].  A - Alpha in the range [0,1].  Assumed to be 1 if not specified.   ( Graphcs 1.0 used values in the range [0,255]. )     local lightGrey = { 0.25, 0.25, 0.25, 1 }", 
            "title": "RGB"
        }, 
        {
            "location": "/libraries/colors/#rgb-functions-sskcolors", 
            "text": "Tip:  These functions are NOT exported and can  only  be accessed via  ssk.colors.*  or localizations.   rgb2hsl( r, g, b, a )  - Convert RGB color to HSL color table.  mixRGB( c1, c2 )  - Evenly mix two RGBa colors.  randomRGB( [ c1 ] )  - Generates a random RGB color.  If optional c1 is passed in, it is mixed evenly with the random color.  pastelRGB( [ c1 ] )  - Generates a random RGB pastel color.  If optional c1 is passed in, it is mixed evenly with the random color.  rgbOffset( r, g, b, a, angle )  - Converts RGB color to HSL and applies hueOffset()  rgbNeighbors( r, g, b, a, angle )  - Converts RGB color to HSL and applies hslNeighbors(), then returns two rgb colors.  rgbTriadic( r, g, b, a )  - Converts RGB color to HSL and applies hslTriadic(), then returns two rgb colors.  rgbSplitComplementary( r, g, b, a, angle )  - Converts RGB color to HSL and applies hslSplitComplementary(), then returns two rgb colors.", 
            "title": "RGB Functions (ssk.colors.*)"
        }, 
        {
            "location": "/libraries/colors/#hsl", 
            "text": "H - Hue is a degree on the color wheel in the range [0,360).  0 is red, 120 is green, 240 is blue.   Numbers in between reflect different shades.    S - Saturation is a percentage value in the range [0,1].  1.0 is the full color.    L - Lightness is also a percentage value in the range [0,1].  0.0 is dark (black),   1.0 1.0 is light (white)  0.5 is the average    A - Alpha in the range [0,1].  Assumed to be 1 if not specified.     \n   local cornFlowerBlue = hsl2rgb( 219, 0.79, 0.66, 1.0 )", 
            "title": "HSL"
        }, 
        {
            "location": "/libraries/colors/#hsl-functions-sskcolors", 
            "text": "Tip:  These functions are NOT exported and can  only  be accessed via  ssk.colors.*  or localizations.   hsl2rgb( h, s, l, a )  - Convert HSL color to RGB color table.  hueOffset( h, s, l, a, angle )  - Rotate hue by 'angle' degrees  hslNeighbors( h, s, l, a, angle )  - Return two arbitray angle neighbors (left and right by angle)  hslTriadic( h, s, l, a )  - Return two triadic neighbors of color  hslSplitComplementary( h, s, l, a, angle )  - Return two complementary split angle colors.", 
            "title": "HSL Functions (ssk.colors.*)"
        }, 
        {
            "location": "/libraries/colors/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/libraries/colors/#rgb-hsl", 
            "text": "function test.run( group, params )\n   group = group or display.currentStage\n   params = params or {}\n\n   local startX = left + 100\n   local startY = top + 100\n\n   local curX = startX\n   local curY = startY\n\n   -- ==============================================\n   -- Row 1 - Test conversions\n    -- ==============================================\n\n    -- RGB 2 HSL   HSL 2 RGB\n    curX = startX\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_G_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_B_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_O_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_Y_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_P_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_PURPLE_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_GREY_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n\n   -- ==============================================\n   -- Row 2 - Test HSL HUE Offset\n    -- ==============================================\n\n    -- hueOffset\n    curX = startX\n    curY = curY + 100\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c1 = ssk.colors.hueOffset(c, 60 )\n    local c2 = ssk.colors.hsl2rgb( c1 )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c1 = ssk.colors.hueOffset(c, -60 )\n    local c2 = ssk.colors.hsl2rgb( c1 )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n   -- ==============================================\n   -- Row 3 - Test HSL Neighbors, Triadic, Split Complementary\n    -- ==============================================\n\n    -- hslNeighbors\n    curX = startX\n    curY = curY + 100\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c2,c3 = ssk.colors.hslNeighbors( c, 90 )\n    c2 = ssk.colors.hsl2rgb( c2 )\n    c3 = ssk.colors.hsl2rgb( c3 )   \n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\n\n    -- hslTriadic\n    curX = curX + 100\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c2,c3 = ssk.colors.hslTriadic( c )\n    c2 = ssk.colors.hsl2rgb( c2 )\n    c3 = ssk.colors.hsl2rgb( c3 )   \n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\n\n    -- hslSplitComplementary\n    curX = curX + 100\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c2,c3 = ssk.colors.hslSplitComplementary( c, 30 )\n    c2 = ssk.colors.hsl2rgb( c2 )\n    c3 = ssk.colors.hsl2rgb( c3 )   \n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\n\n   -- ==============================================\n   -- Row 4 - Test RGB Offset\n    -- ==============================================\n\n    -- rgbOffset\n    curX = startX\n    curY = curY + 100\n    local c1 = ssk.colors.rgbOffset( _R_, 60 )\n    newRect( group, curX, curY, { size = 80, fill = c1  } )\n\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n\n    curX = curX + 80\n    local c1 = ssk.colors.rgbOffset( _R_, -60 )\n    newRect( group, curX, curY, { size = 80, fill = c1  } )\n\n   -- ==============================================\n   -- Row 5 - Test RGB Neighbors, Triadic, Split Complementary\n    -- ==============================================\n\n    -- hslNeighbors\n    curX = startX\n    curY = curY + 100\n    local c2,c3 = ssk.colors.rgbNeighbors( _R_, 90 )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\n\n    -- rgbTriadic\n    curX = curX + 100\n    local c2,c3 = ssk.colors.rgbTriadic( _R_ )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\n\n    -- rgbSplitComplementary\n    curX = curX + 100\n    local c2,c3 = ssk.colors.rgbSplitComplementary( _R_, 30 )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\nend", 
            "title": "RGB &amp; HSL"
        }, 
        {
            "location": "/libraries/colors/#pastels", 
            "text": "function test.run( group, params )\n   group = group or display.currentStage\n   params = params or {}\n\n   local startX = left + 100\n   local startY = top + 100\n\n   local curX = startX\n   local curY = startY\n\n    -- Pastel No Seed Color\n    for i = 1, 3 do\n        curX = startX   \n        for j = 1, 10 do\n            newRect( group, curX, curY, { size = 80, fill = ssk.colors.pastelRGB( )  } )\n            curX = curX + 80\n        end\n        curY = curY + 80\n    end\n\n    curY = curY + 40\n\n    -- Pastel Random Seed Color\n    for i = 1, 3 do\n        curX = startX   \n        for j = 1, 10 do\n            newRect( group, curX, curY, { size = 80, fill = ssk.colors.pastelRGB( randomColor() )  } )\n            curX = curX + 80\n        end\n        curY = curY + 80\n    end\n\nend     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Pastels"
        }, 
        {
            "location": "/libraries/display_standard/", 
            "text": "Display Object Factories (ssk.display.*)\n\n\n(\nEach object below (except spinning circle) was created with a single function call.\n)\n\n\n\nSSK versus Pure Corona SDK\n\n\nSSK provides a set of improved factories to replace/extend (\n) the traditional \ndisplay.*\n factories:\n\n\n\n\nssk.display.newCircle()\n \n \ndisplay.newCircle()\n\n\nssk.display.newRect()\n \n \ndisplay.newRect()\n\n\nssk.display.newImage()\n \n \ndisplay.newImage()\n\n\nssk.display.newImageRect()\n \n \ndisplay.newImageRect()\n\n\n\n\nThe benefit of these factories over the traditional ones is that a display object can often be fully configured, colorized, have a body added, and even have listeners added, all in one easily-typed and legible function call.\n\n\nThe SSK Way\n\n\n\nnewImageRect( group, centerX - 100 , centerY - 50,\n              \nimages/kenney/physicsAssets/yellow_round.png\n, \n              { size = 40 }, \n              { radius = 20, bounce = 1, gravityScale = 0.2 } ) \n\nnewImageRect( group, centerX - 100, centerY + 100, \n              \nimages/kenney/physicsAssets/stone/square2.png\n, \n              { size = 40 }, \n              { bodyType = \nstatic\n } ) \n\n\n\n\n\n\n\nThe Old Way - Blech!\n\n\n\nlocal ball = display.newImageRect( group, \nimages/kenney/physicsAssets/yellow_round.png\n, 40, 40 )\nball.x = display.contentCenterX + 100\nball.y = display.contentCenterY - 50\nphysics.addBody( ball, { radius = 20, bounce = 1, radius = 20  } )\nball.gravityScale = 0.2\n\nlocal block = display.newImageRect( group, \nimages/kenney/physicsAssets/stone/square2.png\n, 40, 40 )\nblock.x = display.contentCenterX + 100\nblock.y = display.contentCenterY + 100\nphysics.addBody( block, \nstatic\n )\n\n\n\n\n\nThe Standard Factories\n\n\nAll of the \nStandard Factories\n take similar arguments.  Please see \nFactory Arguments\n below for details on these arguments.\n\n\n(\nI am not providing individual examples here.  To learn about using these factories, please explore the \nsamples\n.\n)\n\n\nnewCircle\n\n\nssk.display.newCircle( group, x, y [, visualParams [, bodyParams [, behaviorsList ]]] )\n\n\n\n\nnewRect\n\n\nssk.display.newRect( group, x, y [, visualParams [, bodyParams [, behaviorsList ]]] )\n\n\n\n\nnewImage\n\n\nssk.display.newImage( group, x, y, imgSrc [, visualParams [, bodyParams [, behaviorsList ]]] )\n\n\n\n\nnewImageRect\n\n\nssk.display.newImageRect( group, x, y, imgSrc [, visualParams [, bodyParams [, behaviorsList ]]] )\n\n\n\n\nFactory Arguments\n\n\nAs you will have noticed, the above factories have a fairly consistent function signature and share common arguments.  Those argument can be summarized as follows:\n\n\n\n\ngroup\n - Display group to place object in.  If \nnil\n, object is placed in \ndisplay.currentStage\n.\n\n\nx\n, \ny\n - \n x, y \n position to place object at.\n\n\nimgSrc\n - A string specifying a path to the image you wish to display.\n\n\nvisualParams\n - Table of parameters controlling the look of an object.  \n\n\nSee '\nVisual Parameters\n' below.\n\n\n\n\n\n\nbodyParams\n - Table of parameters controlling the (optional) physics body.  \n\n\nSee '\nBody Parameters\n' below.\n\n\n\n\n\n\nbehaviorsList\n - Table of parameters that allows the easy addition of complex game logic to display objects. \n\n\nSee '\nBehaviors List\n' below. \n\n\n\n\n\n\n\n\nOther Factories\n\n\nThis page (of the docs) only discusses the 'Standard Factories', however \nssk.diplay.*\n also has these factories: \nArcs\n, \nLines\n, \nQuick Layers\n\n\nVisual Parameters (\nvisualParams\n)\n\n\nThe first (common) table that all of these builders takes is the \nvisualParams\n table.  With this table, you can set almost all visual properties on the object and you can also attach or set any arbitrary property.\n\n\nvisualParams\n - 'Standard' Properties\n\n\nAside from the 'custom' and specially handled properties listed above, you may set any normal Corona property as well.\n\n\n\n-- Create a red circle with a 50% alpha\nnewCircle( nil, 100, 100 { fill = _R_, alpha = 0.5 } )\n\n\n\n\n\nSee the Corona docs for the complete list of '\nDisplay Object Properties\n'  (\nexternal link\n).\n\n\nvisualParams\n - 'Custom' Properties\n\n\n\n\ncornerRadius\n (\n0\n) - If specified for \nnewRect()\n, a rounded rectangle (\ndisplay.newRoundedRect\n) will be created.\n\n\ndiameter\n - Sets the radius to half this value for \nnewCircle()\n.\n\n\nfill\n (\n{1,1,1,1}\n) - If specified, assigns a fill to the object. Most standard paint fills are allowed:\n\n\n(Color) Paint: \nfill = { 1, 0, 0, 0.25 }\n\n\nComposite Paint\n (\nexternal link\n)\n\n\nTrick:\n You may specify a \nfillEffect\n property in the composite fill table. (Default \nfillEffect\n is \n\"composite.average\"\n.)\n\n\n\n\n\n\nBitmap Paint\n (\nexternal link\n)\n\n\nGradient Paint\n (\nexternal link\n)\n\n\nNot Supported:\n\n\nImage Sheet Paint\n (\nexternal link\n)\n\n\nCamera Fill Paint\n (\nexternal link\n)\n\n\n\n\n\n\n\n\n\n\nradius\n (\n20\n) - Sets the radius for \nnewCircle()\n.\n\n\nscale\n - If specified, the object will be scaled in the x- and y-dimension by this factor.\n\n\nTip:\n Overrides \nxScale\n and \nyScale\n parameters.\n\n\n\n\n\n\nsize\n - Sets width and height of rectangular objects.  If calling \nnewCircle()\n the radius is computed as half the \nsize\n.\n\n\nw\n and \nh\n parameters override this.\n\n\n\n\n\n\nstroke\n (\n{1,1,1,1}\n) - If specified, sets the stroke color of the display object.\n\n\nTip:\n Supports same paint fill types as \nfill\n parameter.\n\n\n\n\n\n\nstrokeWidth\n (\n0\n) - If specified, sets the stroke width of the display object.\n\n\nw\n, \nh\n (\n40\n) - Width and height.\n\n\n\n\nvisualParams\n - 'Listeners'\n\n\nIn addition to being able to set many visual properties via the \nvisualParams\n table, you can supply function references to the following property names:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\naccelerometer\n\n\naxis\n\n\ncollision\n\n\nenterFrame\n\n\n\n\n\n\nfinalize\n\n\nkey\n\n\nmouse\n\n\nsprite\n\n\n\n\n\n\ntap\n\n\ntimer\n\n\ntouch\n\n\n\n\n\n\n\n\n\n\nIf any of these parameters is specified, SSK will automatically hook-up and start the specified listener(s).\n\n\nNote:\n Only works if \nenableAutoListeners = true\n.  See \nConfiguring SSK2\n.\n\n\nListener Example 1 - \ntouch\n\n\n\nlocal function onTouch( self, event)\n   if( event.phase == \nended\n ) then\n      print(\nMy name is: \n .. self.myName )\n   end\n   return false\nend\n\nlocal tmp = newRect( nil, 100, 100, { touch = onTouch, myName = \nRect 1\n }) \n\nlocal tmp = newRect( nil, 200, 100, { touch = onTouch, myName = \nRect 2\n })\n\n\n\n\n\nNow, if you touch either of the two rectangles created by this code, they will print: \n\n\n\n\nMy name is: Rect 1\n \nOR\n  \nMy name is: Rect 2\n\n\n\n\nListener Example 2 - \nenterFrame\n\n\n\nlocal function onEnterFrame( self )\n\n   self.x = self.x + 1\n\n   if( self.x \n= right ) then\n\n      self.x = right\n\n      ignore( \nenterFrame\n, self )\n\n      self.enterFrame = nil\n\n    end\n\nend\n\nnewCircle( nil, left, centerY, { enterFrame = onEnterFrame } )\n\n\n\n\n\nThe sample above created a white circle with a radius of 20 pixels on the very left-edge of the screen and vertically centered.\n\n\nAs soon as it was created, the circle immediately started moving one pixel to the right every frame.  \n\n\nOnce it reached the right-edge of the screen it will stop and remove the listener.\n\n\nvisualParams\n - 'Arbitrary' Properties\n\n\nLastly, as you may have noticed in the prior section, \nvisualParams\n can take any arbitrary property name and assign a value to it.  This is extremely handy for setting flags and other values used later in your code.\n\n\n\nlocal tmp = newRect( nil, 100, 100, { myName = \nBob\n, myAge = 21, amHappy = true }) \n\nprint( tmp.myName, tmp.myAge, tmp.amHappy )\n\n\n\n\n\nBody Parameters (\nbodyParams\n)\n\n\nThe second optional table you can pass to all of the builder functions is the \nbodyParams\n table.\n\n\nbodyParams\n - The Default Body \n{}\n\n\nSpecifying an empty table tell SSK to add a default body to the object.\n\n\n\nnewCircle( nil, 100, 100, { radius = 50 }, {} )\n\nnewRect( nil, 100, 100, { w = 50, h = 20 }, {} )\n\n\n\n\n\nAfter the prior code executes, we will have a circle and a rectangle, both with default bodies.\n\n\nThe circle will have a circular body and the rectangle will have a rectangular body that matches the dimensions of the rectangle.\n\n\nBoth bodies will have this (default) physics configuration:\n\n\n\n\nbodyType = \"dynamic\"\n\n\nbounce = 0.2\n\n\ndensity = 1.0\n\n\nfriction = 0.3\n\n\nlinearDamping = 0\n\n\ngravityScale = 1\n\n\nisSleepingAllowed = true\n\n\nisSensor = false\n\n\nisBullet = false\n\n\nisFixedRotation = false\n\n\n\n\nbodyParams\n - 'Standard' Properties\n\n\nAs with \nvisualParams\n, you may pass key-value pairs in this table to set properties.  These properties include all the standard Physics property.\n\n\n\n-- Create a circle with a static body that is also a sensor\nnewCircle( nil, 100, 100, { radius = 50 }, { bodyType = \nstatic\n, isSensor = true } )\n\n\n\n\n\nSee the Corona docs for a full list of '\nPhysics Body Properties\n'  (\nexternal link\n).\n\n\nbodyParams\n - 'Custom' Properties\n\n\nBesides the many 'Standard' properties supported by Corona and SSK, you can specify these custom properties too:\n\n\n\n\ncalculator\n - A reference to an SSK collision calculator object.\n\n\ncolliderName\n - 'Name' of this object's type (must be specified in calculator.)\n\n\nuseOutline\n - Tells the body to use the objects image file as its shape.  \n\n\nOnly works for \nnewImage()\n and \nnewImageRect()\n.\n\n\n\n\n\n\npillParams\n - A special that tells SSK to construct a 'pill shaped' body. Pass an empty table (\n{}\n) for the default pill shape, or pass a table with any of the following parameters to modify that shape.\n\n\ncorner\n (\n0.15\n) - Amount to subtract/add from/to edges of pill.\n\n\nxScale\n, \nxScale\n (\n1\n)- Scale the shape in either dimension, x and/or y.\n\n\noffsetY\n (\n0\n)- Give the shape a vertical offset.\n\n\noffsetY\n (\n0\n)- Give the shape a horizontal offset.\n\n\n\n\n\n\n\n\n\n-- Make a circle that uses the 'player' settings from a previously created and configured Collision Calculator.\nnewCircle( nil, 100, 100, { radius = 50 }, { calculator = myCC, colliderName = \nplayer\n } )\n\n\n\n\n\nBehaviors (\nbehaviorsList\n)\n\n\nThis is a work-in-progress feature.\n\n\nWhen it is released, you will be able to create objects with complex behaviors like:\n\n\n\n\nDrag-and-Drop - Attach robust drag-and-drop logic to the object.\n\n\nAsteroids-Player - Create a one-line asteroids player. \n\n\n...  \n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Standard Factories (ssk.display)"
        }, 
        {
            "location": "/libraries/display_standard/#display-object-factories-sskdisplay", 
            "text": "( Each object below (except spinning circle) was created with a single function call. )", 
            "title": "Display Object Factories (ssk.display.*)"
        }, 
        {
            "location": "/libraries/display_standard/#ssk-versus-pure-corona-sdk", 
            "text": "SSK provides a set of improved factories to replace/extend ( ) the traditional  display.*  factories:   ssk.display.newCircle()     display.newCircle()  ssk.display.newRect()     display.newRect()  ssk.display.newImage()     display.newImage()  ssk.display.newImageRect()     display.newImageRect()   The benefit of these factories over the traditional ones is that a display object can often be fully configured, colorized, have a body added, and even have listeners added, all in one easily-typed and legible function call.", 
            "title": "SSK versus Pure Corona SDK"
        }, 
        {
            "location": "/libraries/display_standard/#the-ssk-way", 
            "text": "newImageRect( group, centerX - 100 , centerY - 50,\n               images/kenney/physicsAssets/yellow_round.png , \n              { size = 40 }, \n              { radius = 20, bounce = 1, gravityScale = 0.2 } ) \n\nnewImageRect( group, centerX - 100, centerY + 100, \n               images/kenney/physicsAssets/stone/square2.png , \n              { size = 40 }, \n              { bodyType =  static  } )", 
            "title": "The SSK Way"
        }, 
        {
            "location": "/libraries/display_standard/#the-old-way-blech", 
            "text": "local ball = display.newImageRect( group,  images/kenney/physicsAssets/yellow_round.png , 40, 40 )\nball.x = display.contentCenterX + 100\nball.y = display.contentCenterY - 50\nphysics.addBody( ball, { radius = 20, bounce = 1, radius = 20  } )\nball.gravityScale = 0.2\n\nlocal block = display.newImageRect( group,  images/kenney/physicsAssets/stone/square2.png , 40, 40 )\nblock.x = display.contentCenterX + 100\nblock.y = display.contentCenterY + 100\nphysics.addBody( block,  static  )", 
            "title": "The Old Way - Blech!"
        }, 
        {
            "location": "/libraries/display_standard/#the-standard-factories", 
            "text": "All of the  Standard Factories  take similar arguments.  Please see  Factory Arguments  below for details on these arguments.  ( I am not providing individual examples here.  To learn about using these factories, please explore the  samples . )", 
            "title": "The Standard Factories"
        }, 
        {
            "location": "/libraries/display_standard/#newcircle", 
            "text": "ssk.display.newCircle( group, x, y [, visualParams [, bodyParams [, behaviorsList ]]] )", 
            "title": "newCircle"
        }, 
        {
            "location": "/libraries/display_standard/#newrect", 
            "text": "ssk.display.newRect( group, x, y [, visualParams [, bodyParams [, behaviorsList ]]] )", 
            "title": "newRect"
        }, 
        {
            "location": "/libraries/display_standard/#newimage", 
            "text": "ssk.display.newImage( group, x, y, imgSrc [, visualParams [, bodyParams [, behaviorsList ]]] )", 
            "title": "newImage"
        }, 
        {
            "location": "/libraries/display_standard/#newimagerect", 
            "text": "ssk.display.newImageRect( group, x, y, imgSrc [, visualParams [, bodyParams [, behaviorsList ]]] )", 
            "title": "newImageRect"
        }, 
        {
            "location": "/libraries/display_standard/#factory-arguments", 
            "text": "As you will have noticed, the above factories have a fairly consistent function signature and share common arguments.  Those argument can be summarized as follows:   group  - Display group to place object in.  If  nil , object is placed in  display.currentStage .  x ,  y  -   x, y   position to place object at.  imgSrc  - A string specifying a path to the image you wish to display.  visualParams  - Table of parameters controlling the look of an object.    See ' Visual Parameters ' below.    bodyParams  - Table of parameters controlling the (optional) physics body.    See ' Body Parameters ' below.    behaviorsList  - Table of parameters that allows the easy addition of complex game logic to display objects.   See ' Behaviors List ' below.", 
            "title": "Factory Arguments"
        }, 
        {
            "location": "/libraries/display_standard/#other-factories", 
            "text": "This page (of the docs) only discusses the 'Standard Factories', however  ssk.diplay.*  also has these factories:  Arcs ,  Lines ,  Quick Layers", 
            "title": "Other Factories"
        }, 
        {
            "location": "/libraries/display_standard/#visual-parameters-visualparams", 
            "text": "The first (common) table that all of these builders takes is the  visualParams  table.  With this table, you can set almost all visual properties on the object and you can also attach or set any arbitrary property.", 
            "title": "Visual Parameters (visualParams)"
        }, 
        {
            "location": "/libraries/display_standard/#visualparams-standard-properties", 
            "text": "Aside from the 'custom' and specially handled properties listed above, you may set any normal Corona property as well.  \n-- Create a red circle with a 50% alpha\nnewCircle( nil, 100, 100 { fill = _R_, alpha = 0.5 } )  See the Corona docs for the complete list of ' Display Object Properties '  ( external link ).", 
            "title": "visualParams - 'Standard' Properties"
        }, 
        {
            "location": "/libraries/display_standard/#visualparams-custom-properties", 
            "text": "cornerRadius  ( 0 ) - If specified for  newRect() , a rounded rectangle ( display.newRoundedRect ) will be created.  diameter  - Sets the radius to half this value for  newCircle() .  fill  ( {1,1,1,1} ) - If specified, assigns a fill to the object. Most standard paint fills are allowed:  (Color) Paint:  fill = { 1, 0, 0, 0.25 }  Composite Paint  ( external link )  Trick:  You may specify a  fillEffect  property in the composite fill table. (Default  fillEffect  is  \"composite.average\" .)    Bitmap Paint  ( external link )  Gradient Paint  ( external link )  Not Supported:  Image Sheet Paint  ( external link )  Camera Fill Paint  ( external link )      radius  ( 20 ) - Sets the radius for  newCircle() .  scale  - If specified, the object will be scaled in the x- and y-dimension by this factor.  Tip:  Overrides  xScale  and  yScale  parameters.    size  - Sets width and height of rectangular objects.  If calling  newCircle()  the radius is computed as half the  size .  w  and  h  parameters override this.    stroke  ( {1,1,1,1} ) - If specified, sets the stroke color of the display object.  Tip:  Supports same paint fill types as  fill  parameter.    strokeWidth  ( 0 ) - If specified, sets the stroke width of the display object.  w ,  h  ( 40 ) - Width and height.", 
            "title": "visualParams - 'Custom' Properties"
        }, 
        {
            "location": "/libraries/display_standard/#visualparams-listeners", 
            "text": "In addition to being able to set many visual properties via the  visualParams  table, you can supply function references to the following property names:             accelerometer  axis  collision  enterFrame    finalize  key  mouse  sprite    tap  timer  touch      If any of these parameters is specified, SSK will automatically hook-up and start the specified listener(s).  Note:  Only works if  enableAutoListeners = true .  See  Configuring SSK2 .", 
            "title": "visualParams - 'Listeners'"
        }, 
        {
            "location": "/libraries/display_standard/#listener-example-1-touch", 
            "text": "local function onTouch( self, event)\n   if( event.phase ==  ended  ) then\n      print( My name is:   .. self.myName )\n   end\n   return false\nend\n\nlocal tmp = newRect( nil, 100, 100, { touch = onTouch, myName =  Rect 1  }) \n\nlocal tmp = newRect( nil, 200, 100, { touch = onTouch, myName =  Rect 2  })  Now, if you touch either of the two rectangles created by this code, they will print:    My name is: Rect 1   OR    My name is: Rect 2", 
            "title": "Listener Example 1 - touch"
        }, 
        {
            "location": "/libraries/display_standard/#listener-example-2-enterframe", 
            "text": "local function onEnterFrame( self )\n\n   self.x = self.x + 1\n\n   if( self.x  = right ) then\n\n      self.x = right\n\n      ignore(  enterFrame , self )\n\n      self.enterFrame = nil\n\n    end\n\nend\n\nnewCircle( nil, left, centerY, { enterFrame = onEnterFrame } )  The sample above created a white circle with a radius of 20 pixels on the very left-edge of the screen and vertically centered.  As soon as it was created, the circle immediately started moving one pixel to the right every frame.    Once it reached the right-edge of the screen it will stop and remove the listener.", 
            "title": "Listener Example 2 - enterFrame"
        }, 
        {
            "location": "/libraries/display_standard/#visualparams-arbitrary-properties", 
            "text": "Lastly, as you may have noticed in the prior section,  visualParams  can take any arbitrary property name and assign a value to it.  This is extremely handy for setting flags and other values used later in your code.  \nlocal tmp = newRect( nil, 100, 100, { myName =  Bob , myAge = 21, amHappy = true }) \n\nprint( tmp.myName, tmp.myAge, tmp.amHappy )", 
            "title": "visualParams - 'Arbitrary' Properties"
        }, 
        {
            "location": "/libraries/display_standard/#body-parameters-bodyparams", 
            "text": "The second optional table you can pass to all of the builder functions is the  bodyParams  table.", 
            "title": "Body Parameters (bodyParams)"
        }, 
        {
            "location": "/libraries/display_standard/#bodyparams-the-default-body", 
            "text": "Specifying an empty table tell SSK to add a default body to the object.  \nnewCircle( nil, 100, 100, { radius = 50 }, {} )\n\nnewRect( nil, 100, 100, { w = 50, h = 20 }, {} )  After the prior code executes, we will have a circle and a rectangle, both with default bodies.  The circle will have a circular body and the rectangle will have a rectangular body that matches the dimensions of the rectangle.  Both bodies will have this (default) physics configuration:   bodyType = \"dynamic\"  bounce = 0.2  density = 1.0  friction = 0.3  linearDamping = 0  gravityScale = 1  isSleepingAllowed = true  isSensor = false  isBullet = false  isFixedRotation = false", 
            "title": "bodyParams - The Default Body {}"
        }, 
        {
            "location": "/libraries/display_standard/#bodyparams-standard-properties", 
            "text": "As with  visualParams , you may pass key-value pairs in this table to set properties.  These properties include all the standard Physics property.  \n-- Create a circle with a static body that is also a sensor\nnewCircle( nil, 100, 100, { radius = 50 }, { bodyType =  static , isSensor = true } )  See the Corona docs for a full list of ' Physics Body Properties '  ( external link ).", 
            "title": "bodyParams - 'Standard' Properties"
        }, 
        {
            "location": "/libraries/display_standard/#bodyparams-custom-properties", 
            "text": "Besides the many 'Standard' properties supported by Corona and SSK, you can specify these custom properties too:   calculator  - A reference to an SSK collision calculator object.  colliderName  - 'Name' of this object's type (must be specified in calculator.)  useOutline  - Tells the body to use the objects image file as its shape.    Only works for  newImage()  and  newImageRect() .    pillParams  - A special that tells SSK to construct a 'pill shaped' body. Pass an empty table ( {} ) for the default pill shape, or pass a table with any of the following parameters to modify that shape.  corner  ( 0.15 ) - Amount to subtract/add from/to edges of pill.  xScale ,  xScale  ( 1 )- Scale the shape in either dimension, x and/or y.  offsetY  ( 0 )- Give the shape a vertical offset.  offsetY  ( 0 )- Give the shape a horizontal offset.     \n-- Make a circle that uses the 'player' settings from a previously created and configured Collision Calculator.\nnewCircle( nil, 100, 100, { radius = 50 }, { calculator = myCC, colliderName =  player  } )", 
            "title": "bodyParams - 'Custom' Properties"
        }, 
        {
            "location": "/libraries/display_standard/#behaviors-behaviorslist", 
            "text": "This is a work-in-progress feature.  When it is released, you will be able to create objects with complex behaviors like:   Drag-and-Drop - Attach robust drag-and-drop logic to the object.  Asteroids-Player - Create a one-line asteroids player.   ...        Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Behaviors (behaviorsList)"
        }, 
        {
            "location": "/libraries/display_arcs/", 
            "text": "Arc Factories (ssk.display.*)\n\n\nThis library contains two functions for creating arc objects:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nssk.display.arc\n\n\nssk.display.polyArc\n\n\n\n\n\n\nCreates a new arc using lines.\n\n\nCreates a new \narc\n using \ndisplay.newPolygon\n (\nexternal link\n).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArc\n\n\nCreates a new arc using lines.\n\n\nssk.display.arc(group, x, y [ , params ] )\n\n\n\n\n\n\ngroup\n - Group to add arc object to.\n\n\nx\n, \ny\n - \n x, y \n center of arc.\n\n\nparams\n - Table of arc properties.\n\n\ns\n (\n0\n) - Start angle where 0 is up, 90 is right, ...\n\n\nsweep\n (\n360\n) - Angle sweep, where 360 is a full circle.\n\n\nradius\n (\n100\n) - Radius of arc.\n\n\nstrokeColor\n (\n_W_\n) - Color of arc line.\n\n\nstrokeWidth\n (\n4\n) - Width/thickness of arc line.\n\n\nincr\n (\n1\n) - Degrees to increment by per step, \n\n\nMay be any value in range: (-360,360) except 0 \n\n\n\n\n\n\n\n\n\n\n\n\nExample\n\n\n\nlocal spinGroup = display.newGroup()\ngroup:insert(spinGroup)\nspinGroup.x = centerX - 300\nspinGroup.y = centerY - 50\nssk.display.arc( spinGroup, 0, 0 , \n                  { radius = 50, s = 0, sweep = 90,\n                    strokeColor = _R_, strokeWidth = 6 })\nssk.display.arc( spinGroup, 0, 0 , \n                  { radius = 50, s = 90, sweep = 90,\n                    strokeColor = _G_, strokeWidth = 6 })\nssk.display.arc( spinGroup, 0, 0 , \n                  { radius = 50, s = 180, sweep = 90, \n                    strokeColor = _B_, strokeWidth = 6 })\nssk.display.arc( spinGroup, 0, 0 , \n                  { radius = 50, s = 270, sweep = 90,\n                    strokeColor = _Y_, strokeWidth = 6 })\n\nfunction spinGroup.enterFrame( self )\n    self.rotation = self.rotation + 5 \nend; listen(\nenterFrame\n, spinGroup)\n\n\n-- Poly Arcs\nssk.display.polyArc( group, centerX-150, centerY-50,\n      { radius = 50, s = 0, sweep = 180, incr = -0.25, fillColor = _O_ } )\n\n\nssk.display.polyArc( group, centerX-50, centerY-50,\n      { radius = 50, s = 45, sweep = 180, incr = -0.25, fillColor = _P_ } )\n\n\n\n\n\n\nPolyArc\n\n\nCreates a new \narc\n (more of a semi-circle/pie-chart shape actually) using \ndisplay.newPolygon\n (\nexternal link\n). \n\n\nssk.display.polyArc(group, x, y [ , params ] )\n\n\n\n\n\n\ngroup\n - Group to add arc object to.\n\n\nx\n, \ny\n - \n x, y \n center of arc.\n\n\nparams\n - Table of arc properties.\n\n\ns\n (\n0\n) - Start angle where 0 is up, 90 is right, ...\n\n\nsweep\n (\n360\n) - Angle sweep, where 360 is a full circle.\n\n\nradius\n (\n100\n) - Radius of arc.\n\n\nfillColor\n (\n_W_\n) - Fill color for body of arc polygon.\n\n\nstrokeColor\n (\n_W_\n) - Color of arc line.\n\n\nstrokeWidth\n (\n0\n) - Width/thickness of arc line.\n\n\nincr\n (\n1\n) - Degrees to increment by per step, \n\n\nMay be any value in range: (-360,360) except 0 \n\n\n\n\n\n\n\n\n\n\n\n\nExample\n\n\n\nlocal pac\nlocal curSep = 90\nlocal curDir = -15\n\nlocal function chomp()\n    display.remove(pac)\n   pac = ssk.display.polyArc( group, centerX - 200, centerY + 100,\n      { radius = 50, s = 90 - curSep/2, sweep = 360 - curSep, incr = -0.1, fillColor = _Y_ } )\n   curSep = curSep + curDir\n   if( curSep \n= 0 ) then\n    curSep = 0\n    curDir = 15\n   elseif( curSep \n= 90 ) then\n    curSep = 90\n    curDir = -15\n   end\nend\ntimer.performWithDelay( 30, chomp, -1 )\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Arc Factories (ssk.display)"
        }, 
        {
            "location": "/libraries/display_arcs/#arc-factories-sskdisplay", 
            "text": "This library contains two functions for creating arc objects:           ssk.display.arc  ssk.display.polyArc    Creates a new arc using lines.  Creates a new  arc  using  display.newPolygon  ( external link ).", 
            "title": "Arc Factories (ssk.display.*)"
        }, 
        {
            "location": "/libraries/display_arcs/#arc", 
            "text": "Creates a new arc using lines.  ssk.display.arc(group, x, y [ , params ] )   group  - Group to add arc object to.  x ,  y  -   x, y   center of arc.  params  - Table of arc properties.  s  ( 0 ) - Start angle where 0 is up, 90 is right, ...  sweep  ( 360 ) - Angle sweep, where 360 is a full circle.  radius  ( 100 ) - Radius of arc.  strokeColor  ( _W_ ) - Color of arc line.  strokeWidth  ( 4 ) - Width/thickness of arc line.  incr  ( 1 ) - Degrees to increment by per step,   May be any value in range: (-360,360) except 0", 
            "title": "Arc"
        }, 
        {
            "location": "/libraries/display_arcs/#example", 
            "text": "local spinGroup = display.newGroup()\ngroup:insert(spinGroup)\nspinGroup.x = centerX - 300\nspinGroup.y = centerY - 50\nssk.display.arc( spinGroup, 0, 0 , \n                  { radius = 50, s = 0, sweep = 90,\n                    strokeColor = _R_, strokeWidth = 6 })\nssk.display.arc( spinGroup, 0, 0 , \n                  { radius = 50, s = 90, sweep = 90,\n                    strokeColor = _G_, strokeWidth = 6 })\nssk.display.arc( spinGroup, 0, 0 , \n                  { radius = 50, s = 180, sweep = 90, \n                    strokeColor = _B_, strokeWidth = 6 })\nssk.display.arc( spinGroup, 0, 0 , \n                  { radius = 50, s = 270, sweep = 90,\n                    strokeColor = _Y_, strokeWidth = 6 })\n\nfunction spinGroup.enterFrame( self )\n    self.rotation = self.rotation + 5 \nend; listen( enterFrame , spinGroup)\n\n\n-- Poly Arcs\nssk.display.polyArc( group, centerX-150, centerY-50,\n      { radius = 50, s = 0, sweep = 180, incr = -0.25, fillColor = _O_ } )\n\n\nssk.display.polyArc( group, centerX-50, centerY-50,\n      { radius = 50, s = 45, sweep = 180, incr = -0.25, fillColor = _P_ } )", 
            "title": "Example"
        }, 
        {
            "location": "/libraries/display_arcs/#polyarc", 
            "text": "Creates a new  arc  (more of a semi-circle/pie-chart shape actually) using  display.newPolygon  ( external link ).   ssk.display.polyArc(group, x, y [ , params ] )   group  - Group to add arc object to.  x ,  y  -   x, y   center of arc.  params  - Table of arc properties.  s  ( 0 ) - Start angle where 0 is up, 90 is right, ...  sweep  ( 360 ) - Angle sweep, where 360 is a full circle.  radius  ( 100 ) - Radius of arc.  fillColor  ( _W_ ) - Fill color for body of arc polygon.  strokeColor  ( _W_ ) - Color of arc line.  strokeWidth  ( 0 ) - Width/thickness of arc line.  incr  ( 1 ) - Degrees to increment by per step,   May be any value in range: (-360,360) except 0", 
            "title": "PolyArc"
        }, 
        {
            "location": "/libraries/display_arcs/#example_1", 
            "text": "local pac\nlocal curSep = 90\nlocal curDir = -15\n\nlocal function chomp()\n    display.remove(pac)\n   pac = ssk.display.polyArc( group, centerX - 200, centerY + 100,\n      { radius = 50, s = 90 - curSep/2, sweep = 360 - curSep, incr = -0.1, fillColor = _Y_ } )\n   curSep = curSep + curDir\n   if( curSep  = 0 ) then\n    curSep = 0\n    curDir = 15\n   elseif( curSep  = 90 ) then\n    curSep = 90\n    curDir = -15\n   end\nend\ntimer.performWithDelay( 30, chomp, -1 )     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Example"
        }, 
        {
            "location": "/libraries/display_lines/", 
            "text": "Line Factories (ssk.display.*)\n\n\nThis library contains a number of function for creating complex and customizable lines.\n\n\n\n\n\n\n\n\n\n\nFunction\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nssk.display.newLine\n\n\nHyper-configurable line-segment factory, using two end-points to define the line.\n\n\n\n\n\n\nssk.display.newAngleLine\n\n\nHyper-configurable line-segment factory using a start-point, an angle, and a length to define the line.\n\n\n\n\n\n\nssk.display.newPointsLine\n\n\nHyper-configurable line-segment factory, using a \npoints list\n to define the line.\n\n\n\n\n\n\n\n\nnewLine\n\n\nHyper-configurable line-segment factory, using two end-points to define the line.\n\n\nssk.display.newLine( group, startX, startY, endX, endY [, visualParams ] )\n\n\n\n\n\n\ngroup\n - Group to add arc object to.\n\n\nstartX\n, \nstartY\n - \n x, y \n start of line.\n\n\nendX\n, \nendX\n - \n x, y \n end of line.\n\n\nvisualParams\n - Table of arc properties.\n\n\ndashLen\n (\n1\n) - Length of line-segments making up line.  \n\n\nIgnored for \nstyle == \"solid\"\n.\n\n\n\n\n\n\nfill\n (\n_W_\n) - Fill color if  using \nstyle\n \n\"dotted\"\n or \n\"arrows\"\n\n\ngapLen\n (\n0\n) - Width of spaces between line-segments.\n\n\nIgnored for \nstyle == \"solid\"\n.\n\n\n\n\n\n\nstroke\n (\n_W_\n) - Color of line.\n\n\nstrokeWidth\n (\n1\n) - Thickness of line.\n\n\nstyle\n (\n\"solid\"\n) - \n\"solid\"\n, \n\"dashed\"\n, \n\"dotted\"\n, \n\"arrows\"\n\n\n\n\n\n\n\n\nnewAngleLine\n\n\nHyper-configurable line-segment factory using a start-point, an angle, and a length to define the line. \n\n\nssk.display.newAngleLine( group, startX, startY, angle, length [, visualParams ] )\n\n\n\n\n\n\ngroup\n - Group to add arc object to.\n\n\nstartX\n, \nstartY\n - \n x, y \n start of line.\n\n\nangle\n  - Angle line runs in where 0 is up, 90 is right, ...\n\n\nvisualParams\n - Table of arc properties.\n\n\ndashLen\n (\n1\n) - Length of line-segments making up line.  \n\n\nIgnored for \nstyle == \"solid\"\n.\n\n\n\n\n\n\nfill\n (\n_W_\n) - Fill color if  using \nstyle\n \n\"dotted\"\n or \n\"arrows\"\n\n\ngapLen\n (\n0\n) - Width of spaces between line-segments.\n\n\nIgnored for \nstyle == \"solid\"\n.\n\n\n\n\n\n\nstroke\n (\n_W_\n) - Color of line.\n\n\nstrokeWidth\n (\n1\n) - Thickness of line.\n\n\nstyle\n (\n\"solid\"\n) - \n\"solid\"\n, \n\"dashed\"\n, \n\"dotted\"\n, \n\"arrows\"\n\n\n\n\n\n\n\n\nnewPointsLine\n\n\nHyper-configurable line-segment factory, using a \npoints list\n to define the line.\n\n\nssk.display.newPointsLine( group, points [, visualParams ] )\n\n\n\n\n\n\ngroup\n - Group to add arc object to.\n\n\npoints\n - \nPoints list\n, defining each point on line.\n\n\nvisualParams\n - Table of arc properties.\n\n\ndashLen\n (\n1\n) - Length of line-segments making up line.  \n\n\nIgnored for \nstyle == \"solid\"\n.\n\n\n\n\n\n\nfill\n (\n_W_\n) - Fill color if  using \nstyle\n \n\"dotted\"\n or \n\"arrowheads\"\n\n\ngapLen\n (\n0\n) - Width of spaces between line-segments.\n\n\nIgnored for \nstyle == \"solid\"\n.\n\n\n\n\n\n\nstroke\n (\n_W_\n) - Color of line.\n\n\nstrokeWidth\n (\n1\n) - Thickness of line.\n\n\nstyle\n (\n\"solid\"\n) - \n\"solid\"\n, \n\"dashed\"\n, \n\"dotted\"\n, \n\"arrowheads\"\n\n\n\n\n\n\n\n\nComplete Example\n\n\nExample of all line factories in use.\n\n\n\nfunction test.run( group, params )\n   group = group or display.currentStage\n   params = params or {}\n\n   -- Basic\n   local newLine    = ssk.display.newLine\n    newLine( group, 50, top + 50, 450, top + 50 )\n    newLine( group, 50, top + 50 + 20, 450, top + 50 + 20, \n              { w = 2, fill = _R_ } )\n    newLine( group, 50, top + 50 + 40, 450, top + 50 + 40, \n              { w = 1, dashLen = 3, gapLen = 5, fill = _C_, style = \ndashed\n } )\n    newLine( group, 50, top + 50 + 60, 450, top + 50 + 60, \n              { radius = 3, gapLen = 5, fill = _O_, style = \ndotted\n, \n                stroke = _Y_, strokeWidth = 1} )\n    newLine( group, 50, top + 50 + 80, 450, top + 50 + 80, \n              { gapLen = 10, dashLen = 6, headSize = 4, fill = _O_, style = \narrows\n} )\n    newLine( group, 50, top + 50 + 100, 450, top + 50 + 100, \n              { gapLen = 10, dashLen = 0, headSize = 4, fill = _C_, style = \narrows\n} )\n\n\n    -- Angle lines\n    local newAngleLine = ssk.display.newAngleLine\n    local curY = top + 200\n    local tmp = newAngleLine( group, 50, curY, 135, 200 )\n    curY = curY + 20\n    local tmp = newAngleLine( group, 50, curY, 135, 200, \n                              { w = 2, fill = _R_ } )\n    curY = curY + 20\n    local tmp = newAngleLine( group, 50, curY, 135, 200, \n                               { w = 1, dashLen = 3, gapLen = 5, fill = _C_, style = \ndashed\n } )\n    curY = curY + 20\n    local tmp = newAngleLine( group, 50, curY, 135, 200, \n                               { radius = 3, gapLen = 5, fill = _O_, style = \ndotted\n, \n                                 stroke = _Y_, strokeWidth = 1} )\n    curY = curY + 20\n    local tmp = newAngleLine( group, 50, curY, 135, 200, \n                               { gapLen = 10, dashLen = 6, headSize = 4, fill = _O_, \n                                 style = \narrows\n} )\n    curY = curY + 20\n    local tmp = newAngleLine( group, 50, curY, 135, 200, \n                               { gapLen = 10, dashLen = 1, headSize = 4, fill = _C_, \n                                 style = \narrows\n} )\n\n    -- Animated Lines\n    local newPointsLine     = ssk.display.newPointsLine\n    local newPoints         = ssk.points.new\n    local easyIFC           = ssk.easyIFC\n    local mRand             = math.random\n    local reDrawLines\n    local lastGroup\n\n    reDrawLines = function()\n        display.remove( lastGroup )\n\n        lastGroup = display.newGroup()\n        group:insert( lastGroup )\n\n        lastGroup.x  = lastGroup.x + 200\n\n        local curY = 250\n\n        local points = newPoints()\n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points  )\n\n        local points = newPoints()  \n        curY = curY + 20\n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points, { w = 2, fill = _R_ } )\n\n        local points = newPoints()\n        curY = curY + 20    \n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points, \n                                    { w = 1, dashLen = 1, gapLen = 2, fill = _C_, \n                                      style = \ndashed\n } )\n\n        local points = newPoints()\n        curY = curY + 20\n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points, \n                                    { radius = 3, gapLen = 5, fill = _O_, style = \ndotted\n, \n                                       stroke = _Y_, strokeWidth = 1} )\n\n        local points = newPoints()\n        curY = curY + 20\n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points, \n                                    { gapLen = 10, dashLen = 6, headSize = 4, fill = _O_, \n                                      style = \narrowheads\n} )\n\n        local points = newPoints()\n        curY = curY + 20\n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points, { fill = {1,1,1,0.2} } )\n        local tmp = newPointsLine( lastGroup, points, \n                                    { gapLen = 10, dashLen = 1, headSize = 4, fill = _C_, \n                                      style = \narrowheads\n} )\n\n        timer.performWithDelay( 100, reDrawLines )\n    end\n\n    reDrawLines()\nend\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Line Factories (ssk.display)"
        }, 
        {
            "location": "/libraries/display_lines/#line-factories-sskdisplay", 
            "text": "This library contains a number of function for creating complex and customizable lines.      Function  Description      ssk.display.newLine  Hyper-configurable line-segment factory, using two end-points to define the line.    ssk.display.newAngleLine  Hyper-configurable line-segment factory using a start-point, an angle, and a length to define the line.    ssk.display.newPointsLine  Hyper-configurable line-segment factory, using a  points list  to define the line.", 
            "title": "Line Factories (ssk.display.*)"
        }, 
        {
            "location": "/libraries/display_lines/#newline", 
            "text": "Hyper-configurable line-segment factory, using two end-points to define the line.  ssk.display.newLine( group, startX, startY, endX, endY [, visualParams ] )   group  - Group to add arc object to.  startX ,  startY  -   x, y   start of line.  endX ,  endX  -   x, y   end of line.  visualParams  - Table of arc properties.  dashLen  ( 1 ) - Length of line-segments making up line.    Ignored for  style == \"solid\" .    fill  ( _W_ ) - Fill color if  using  style   \"dotted\"  or  \"arrows\"  gapLen  ( 0 ) - Width of spaces between line-segments.  Ignored for  style == \"solid\" .    stroke  ( _W_ ) - Color of line.  strokeWidth  ( 1 ) - Thickness of line.  style  ( \"solid\" ) -  \"solid\" ,  \"dashed\" ,  \"dotted\" ,  \"arrows\"", 
            "title": "newLine"
        }, 
        {
            "location": "/libraries/display_lines/#newangleline", 
            "text": "Hyper-configurable line-segment factory using a start-point, an angle, and a length to define the line.   ssk.display.newAngleLine( group, startX, startY, angle, length [, visualParams ] )   group  - Group to add arc object to.  startX ,  startY  -   x, y   start of line.  angle   - Angle line runs in where 0 is up, 90 is right, ...  visualParams  - Table of arc properties.  dashLen  ( 1 ) - Length of line-segments making up line.    Ignored for  style == \"solid\" .    fill  ( _W_ ) - Fill color if  using  style   \"dotted\"  or  \"arrows\"  gapLen  ( 0 ) - Width of spaces between line-segments.  Ignored for  style == \"solid\" .    stroke  ( _W_ ) - Color of line.  strokeWidth  ( 1 ) - Thickness of line.  style  ( \"solid\" ) -  \"solid\" ,  \"dashed\" ,  \"dotted\" ,  \"arrows\"", 
            "title": "newAngleLine"
        }, 
        {
            "location": "/libraries/display_lines/#newpointsline", 
            "text": "Hyper-configurable line-segment factory, using a  points list  to define the line.  ssk.display.newPointsLine( group, points [, visualParams ] )   group  - Group to add arc object to.  points  -  Points list , defining each point on line.  visualParams  - Table of arc properties.  dashLen  ( 1 ) - Length of line-segments making up line.    Ignored for  style == \"solid\" .    fill  ( _W_ ) - Fill color if  using  style   \"dotted\"  or  \"arrowheads\"  gapLen  ( 0 ) - Width of spaces between line-segments.  Ignored for  style == \"solid\" .    stroke  ( _W_ ) - Color of line.  strokeWidth  ( 1 ) - Thickness of line.  style  ( \"solid\" ) -  \"solid\" ,  \"dashed\" ,  \"dotted\" ,  \"arrowheads\"", 
            "title": "newPointsLine"
        }, 
        {
            "location": "/libraries/display_lines/#complete-example", 
            "text": "Example of all line factories in use.  \nfunction test.run( group, params )\n   group = group or display.currentStage\n   params = params or {}\n\n   -- Basic\n   local newLine    = ssk.display.newLine\n    newLine( group, 50, top + 50, 450, top + 50 )\n    newLine( group, 50, top + 50 + 20, 450, top + 50 + 20, \n              { w = 2, fill = _R_ } )\n    newLine( group, 50, top + 50 + 40, 450, top + 50 + 40, \n              { w = 1, dashLen = 3, gapLen = 5, fill = _C_, style =  dashed  } )\n    newLine( group, 50, top + 50 + 60, 450, top + 50 + 60, \n              { radius = 3, gapLen = 5, fill = _O_, style =  dotted , \n                stroke = _Y_, strokeWidth = 1} )\n    newLine( group, 50, top + 50 + 80, 450, top + 50 + 80, \n              { gapLen = 10, dashLen = 6, headSize = 4, fill = _O_, style =  arrows } )\n    newLine( group, 50, top + 50 + 100, 450, top + 50 + 100, \n              { gapLen = 10, dashLen = 0, headSize = 4, fill = _C_, style =  arrows } )\n\n\n    -- Angle lines\n    local newAngleLine = ssk.display.newAngleLine\n    local curY = top + 200\n    local tmp = newAngleLine( group, 50, curY, 135, 200 )\n    curY = curY + 20\n    local tmp = newAngleLine( group, 50, curY, 135, 200, \n                              { w = 2, fill = _R_ } )\n    curY = curY + 20\n    local tmp = newAngleLine( group, 50, curY, 135, 200, \n                               { w = 1, dashLen = 3, gapLen = 5, fill = _C_, style =  dashed  } )\n    curY = curY + 20\n    local tmp = newAngleLine( group, 50, curY, 135, 200, \n                               { radius = 3, gapLen = 5, fill = _O_, style =  dotted , \n                                 stroke = _Y_, strokeWidth = 1} )\n    curY = curY + 20\n    local tmp = newAngleLine( group, 50, curY, 135, 200, \n                               { gapLen = 10, dashLen = 6, headSize = 4, fill = _O_, \n                                 style =  arrows } )\n    curY = curY + 20\n    local tmp = newAngleLine( group, 50, curY, 135, 200, \n                               { gapLen = 10, dashLen = 1, headSize = 4, fill = _C_, \n                                 style =  arrows } )\n\n    -- Animated Lines\n    local newPointsLine     = ssk.display.newPointsLine\n    local newPoints         = ssk.points.new\n    local easyIFC           = ssk.easyIFC\n    local mRand             = math.random\n    local reDrawLines\n    local lastGroup\n\n    reDrawLines = function()\n        display.remove( lastGroup )\n\n        lastGroup = display.newGroup()\n        group:insert( lastGroup )\n\n        lastGroup.x  = lastGroup.x + 200\n\n        local curY = 250\n\n        local points = newPoints()\n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points  )\n\n        local points = newPoints()  \n        curY = curY + 20\n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points, { w = 2, fill = _R_ } )\n\n        local points = newPoints()\n        curY = curY + 20    \n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points, \n                                    { w = 1, dashLen = 1, gapLen = 2, fill = _C_, \n                                      style =  dashed  } )\n\n        local points = newPoints()\n        curY = curY + 20\n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points, \n                                    { radius = 3, gapLen = 5, fill = _O_, style =  dotted , \n                                       stroke = _Y_, strokeWidth = 1} )\n\n        local points = newPoints()\n        curY = curY + 20\n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points, \n                                    { gapLen = 10, dashLen = 6, headSize = 4, fill = _O_, \n                                      style =  arrowheads } )\n\n        local points = newPoints()\n        curY = curY + 20\n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points, { fill = {1,1,1,0.2} } )\n        local tmp = newPointsLine( lastGroup, points, \n                                    { gapLen = 10, dashLen = 1, headSize = 4, fill = _C_, \n                                      style =  arrowheads } )\n\n        timer.performWithDelay( 100, reDrawLines )\n    end\n\n    reDrawLines()\nend     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Complete Example"
        }, 
        {
            "location": "/libraries/display_layers/", 
            "text": "Quick Layers (ssk.display.*)\n\n\n\n\nquickLayers( parentGroup, ... )\n - This function allows you to easily specify display group hierachies with optional nesting in a single call.  \n\n\n\n\nThe \nquickLayers()\n function returns a single display group (\nlayers\n) that contains the hierarchy as specified and that gives acess to each layer by its name, making game layering both fast and easy to implement.\n\n\nFurthermore, the returned \nlayers\n object provides two very useful methods:\n\n\n\n\nlayers:destroy()\n - Destroys the entire hierachy and all its children in one call.\n\n\nlayers:purge( [ name [, recursive ] )\n - Purge the contents of any named layer.\n\n\nname\n (\nnil\n) - Name of layer to purge.  If not specified, purge starting from root of hierarchcy.\n\n\n\n\n\n\nrecursive\n (\ntrue\n) - Clear objects in this layer and all objects in all child layers.\n\n\n\n\nTip:\n Purges do not destroy the layer groups themselves, so the hierarchy is maintained.\n\n\nCreating A Layer System\n\n\n\n-- Create Layers For Current Scene\nlocal layers = ssk.display.quickLayers( sceneGroup, \n   \nunderlay\n, \n   \nworld\n,\n      {  \nbackground\n, \n         \ncontent\n, \n         \nforeground\n },\n   \noverlay\n )\n\n\n\n\n\nProduces this bottom-to-top layered group hierarchy (\nparentGroup\n is \nsceneGroup\n in this example):\n\n\n\n\\ (parentGroup)\n|--\\ underlay\n|--\\ world\n   |--\\ background\n   |--\\ content\n   |--\\ foreground\n|--\\ overlay\n\n\n\n\n\nUsing A Layer System\n\n\n\n-- Create grey rectangle in background layer\n--\nlocal back = newRect( layers.background, centerX, centerY, \n                       { w = fullw, h = fullh, fill = _DARKGREY_ } )\n\n-- Add a 'player' in the 'content' layer\n--\nlocal player = newImageRect( layers.content, centerX, centerY, \nimages/smiley.png\n )\n\n\n\n\n\nPurging A Layer\n\n\n\n-- Create 100 cirlces in 'overlay' layer.\n--\nfor i = 1, 100 do\n   newRect( layers.overlay, centerX + math.radom( -200, 200), centerY + math.radom( -200, 200), \n            { fill = ssk.colors.randomColor() }   )\nend\n\n-- Wait 2 seconds, then purge the 'overlay' layer thus destroying all those circles.\n--\ntimer.performWithDelay( 2000, function() layers:purge( \noverlay\n ) end )\n\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Quick Layers (ssk.display)"
        }, 
        {
            "location": "/libraries/display_layers/#quick-layers-sskdisplay", 
            "text": "quickLayers( parentGroup, ... )  - This function allows you to easily specify display group hierachies with optional nesting in a single call.     The  quickLayers()  function returns a single display group ( layers ) that contains the hierarchy as specified and that gives acess to each layer by its name, making game layering both fast and easy to implement.  Furthermore, the returned  layers  object provides two very useful methods:   layers:destroy()  - Destroys the entire hierachy and all its children in one call.  layers:purge( [ name [, recursive ] )  - Purge the contents of any named layer.  name  ( nil ) - Name of layer to purge.  If not specified, purge starting from root of hierarchcy.    recursive  ( true ) - Clear objects in this layer and all objects in all child layers.   Tip:  Purges do not destroy the layer groups themselves, so the hierarchy is maintained.", 
            "title": "Quick Layers (ssk.display.*)"
        }, 
        {
            "location": "/libraries/display_layers/#creating-a-layer-system", 
            "text": "-- Create Layers For Current Scene\nlocal layers = ssk.display.quickLayers( sceneGroup, \n    underlay , \n    world ,\n      {   background , \n          content , \n          foreground  },\n    overlay  )  Produces this bottom-to-top layered group hierarchy ( parentGroup  is  sceneGroup  in this example):  \n\\ (parentGroup)\n|--\\ underlay\n|--\\ world\n   |--\\ background\n   |--\\ content\n   |--\\ foreground\n|--\\ overlay", 
            "title": "Creating A Layer System"
        }, 
        {
            "location": "/libraries/display_layers/#using-a-layer-system", 
            "text": "-- Create grey rectangle in background layer\n--\nlocal back = newRect( layers.background, centerX, centerY, \n                       { w = fullw, h = fullh, fill = _DARKGREY_ } )\n\n-- Add a 'player' in the 'content' layer\n--\nlocal player = newImageRect( layers.content, centerX, centerY,  images/smiley.png  )", 
            "title": "Using A Layer System"
        }, 
        {
            "location": "/libraries/display_layers/#purging-a-layer", 
            "text": "-- Create 100 cirlces in 'overlay' layer.\n--\nfor i = 1, 100 do\n   newRect( layers.overlay, centerX + math.radom( -200, 200), centerY + math.radom( -200, 200), \n            { fill = ssk.colors.randomColor() }   )\nend\n\n-- Wait 2 seconds, then purge the 'overlay' layer thus destroying all those circles.\n--\ntimer.performWithDelay( 2000, function() layers:purge(  overlay  ) end )     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Purging A Layer"
        }, 
        {
            "location": "/libraries/display_samples/", 
            "text": "Display Object Samples (ssk.display.*)\n\n\nHere are some samples to help you get your head wrapped around the concepts outlined in the previous docs pages.\n\n\nTip:\n To make typing easier, I usually localize SSK functions at the top of a file. \n\n\n\n-- Localize factories\nlocal newCircle    = ssk.display.newCircle\nlocal newRect      = ssk.display.newRect\nlocal newImageRect = ssk.display.newImageRect\n\n\n\n\n\n\n\nCircles - \nnewCircle\n\n\n\n\nnewCircle( group, 45, top + 50 )    \n\nnewCircle( group, 95, top + 50, { fill = _R_ } )\n\nnewCircle( group, 145, top + 50, { radius = 10, fill = _B_, stroke = _W_, strokeWidth = 2 } )\n\nnewCircle( group, 195, top + 50, { size = 20, fill = _O_ } )\n\nnewCircle( group, 245, top + 50, { radius = 20, scale = 0.5, fill = _Y_ } )\n\nnewCircle( group, 295, top + 50, { xScale = 0.75, fill = _C_ } )\n\nnewCircle( group, 345, top + 50, { yScale = 0.75, rotation = 15, fill = _PURPLE_ } )\n\nnewCircle( group, 395, top + 50, { fill = { type = \nimage\n, \n                                            baseDir = system.ResourceDirectory, \n                                            filename = \nimages/water.png\n} } )\n\nnewCircle( group, 445, top + 50, { \n        fill = { type = \ngradient\n, color1 = { 1, 0, 0.4 }, \n                 color2 = { 1, 0, 0, 0.2 }, direction = \ndown\n }, strokeWidth = 4, \n        stroke = { type = \ngradient\n, color1 = { 0, 1, 0.4 }, \n                   color2 = { 0, 0, 1, 0.2 }, direction = \nup\n } } )\n\n\n\n\n\n\n\nRectangles - \nnewRect\n\n\n\n\n\nnewRect( group, 45, top + 100 )  \n\nnewRect( group, 95, top + 100, { fill = _R_ } )\n\nnewRect( group, 145, top + 100, { radius = 10, fill = _B_,  stroke = _W_, strokeWidth = 2 } )\n\nnewRect( group, 195, top + 100, { size = 20, fill = _O_ } )\n\nnewRect( group, 245, top + 100, { radius = 20, scale = 0.5, fill = _Y_ } )\n\nnewRect( group, 295, top + 100, { xScale = 0.75, fill = _C_ } )\n\nnewRect( group, 345, top + 100, { yScale = 0.75, rotation = 15, fill = _PURPLE_ } )\n\nnewRect( group, 395, top + 100, { fill = { type = \nimage\n, \n                                           baseDir = system.ResourceDirectory, \n                                           filename = \nimages/water.png\n} } )\n\nnewRect( group, 445, top + 100, { \n        fill = { type = \ngradient\n, color1 = { 1, 0, 0.4 }, \n                 color2 = { 1, 0, 0, 0.2 }, direction = \ndown\n }, strokeWidth = 4, \n        stroke = { type = \ngradient\n, color1 = { 0, 1, 0.4 }, \n                   color2 = { 0, 0, 1, 0.2 }, direction = \nup\n } } )\n\n\n\n\n\n\n\nImage Rectanges - \nnewImageRect\n\n\n\n\n\nnewImageRect( group, 45, top + 150, \nimages/smiley.png\n )    \n\nnewImageRect( group, 95, top + 150, \nimages/smiley.png\n, { fill = _R_ } )\n\nnewImageRect( group, 145, top + 150, \nimages/smiley.png\n, { radius = 10, fill = _B_, \n                                                            stroke = _W_, strokeWidth = 2 } )\n\nnewImageRect( group, 195, top + 150, \nimages/smiley.png\n, { size = 20, fill = _O_ } )\n\nnewImageRect( group, 245, top + 150, \nimages/smiley.png\n, { radius = 20, scale = 0.5, fill = _Y_ } )\n\nnewImageRect( group, 295, top + 150, \nimages/smiley.png\n, { xScale = 0.75, fill = _C_ } )\n\nnewImageRect( group, 345, top + 150, \nimages/smiley.png\n, { yScale = 0.75, rotation = 15, fill = _PURPLE_ } )\n\nnewImageRect( group, 395, top + 150, \nimages/smiley.png\n, { fill = { type = \nimage\n, \n                                                                     baseDir = system.ResourceDirectory, \n                                                                     filename = \nimages/water.png\n} } )\n\nnewImageRect( group, 445, top + 150, \nimages/smiley.png\n, { \n        fill = { type = \ngradient\n, color1 = { 1, 0, 0.4 }, \n                 color2 = { 1, 0, 0, 0.2 }, direction = \ndown\n }, strokeWidth = 4, \n        stroke = { type = \ngradient\n, color1 = { 0, 1, 0.4 }, \n                   color2 = { 0, 0, 1, 0.2 }, direction = \nup\n } } )\n\n\n\n\n\n\n\nBouncing Block - Simple Physics\n\n\n\n\n\nnewImageRect( group, centerX - 100 , centerY - 50, \nimages/kenney/physicsAssets/yellow_round.png\n, \n              { size = 40 }, { radius = 20, bounce = 1, gravityScale = 0.2 } )  \n\nnewImageRect( group, centerX - 100, centerY + 100, \nimages/kenney/physicsAssets/stone/square2.png\n, \n              { size = 40 }, { bodyType = \nstatic\n } ) \n\n\n\n\n\n\n\n'Color Switch'-like Shape with Arcs\n\n\n\n\n\nlocal spinGroup = display.newGroup()\ngroup:insert(spinGroup)\nspinGroup.x = centerX - 300\nspinGroup.y = centerY - 50\nssk.display.arc( spinGroup, 0, 0 , \n                  { radius = 50, s = 0, sweep = 90,\n                    strokeColor = _R_, strokeWidth = 6 })\nssk.display.arc( spinGroup, 0, 0 , \n                  { radius = 50, s = 90, sweep = 90,\n                    strokeColor = _G_, strokeWidth = 6 })\nssk.display.arc( spinGroup, 0, 0 , \n                  { radius = 50, s = 180, sweep = 90, \n                    strokeColor = _B_, strokeWidth = 6 })\nssk.display.arc( spinGroup, 0, 0 , \n                  { radius = 50, s = 270, sweep = 90,\n                    strokeColor = _Y_, strokeWidth = 6 })\n\nfunction spinGroup.enterFrame( self )\n    self.rotation = self.rotation + 5 \nend; listen(\nenterFrame\n, spinGroup)\n\n\n-- Poly Arcs\nssk.display.polyArc( group, centerX-150, centerY-50,\n      { radius = 50, s = 0, sweep = 180, incr = -0.25, fillColor = _O_ } )\n\n\nssk.display.polyArc( group, centerX-50, centerY-50,\n      { radius = 50, s = 45, sweep = 180, incr = -0.25, fillColor = _P_ } )\n\n\n\n\n\n\n\n\n'Pac-Man' with Poly Arc\n\n\n\n\n\nlocal pac\nlocal curSep = 90\nlocal curDir = -15\n\nlocal function chomp()\n    display.remove(pac)\n   pac = ssk.display.polyArc( group, centerX - 200, centerY + 100,\n      { radius = 50, s = 90 - curSep/2, sweep = 360 - curSep, incr = -0.1, fillColor = _Y_ } )\n   curSep = curSep + curDir\n   if( curSep \n= 0 ) then\n    curSep = 0\n    curDir = 15\n   elseif( curSep \n= 90 ) then\n    curSep = 90\n    curDir = -15\n   end\nend\ntimer.performWithDelay( 30, chomp, -1 )\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Samples (ssk.display)"
        }, 
        {
            "location": "/libraries/display_samples/#display-object-samples-sskdisplay", 
            "text": "Here are some samples to help you get your head wrapped around the concepts outlined in the previous docs pages.  Tip:  To make typing easier, I usually localize SSK functions at the top of a file.   \n-- Localize factories\nlocal newCircle    = ssk.display.newCircle\nlocal newRect      = ssk.display.newRect\nlocal newImageRect = ssk.display.newImageRect", 
            "title": "Display Object Samples (ssk.display.*)"
        }, 
        {
            "location": "/libraries/display_samples/#circles-newcircle", 
            "text": "newCircle( group, 45, top + 50 )    \n\nnewCircle( group, 95, top + 50, { fill = _R_ } )\n\nnewCircle( group, 145, top + 50, { radius = 10, fill = _B_, stroke = _W_, strokeWidth = 2 } )\n\nnewCircle( group, 195, top + 50, { size = 20, fill = _O_ } )\n\nnewCircle( group, 245, top + 50, { radius = 20, scale = 0.5, fill = _Y_ } )\n\nnewCircle( group, 295, top + 50, { xScale = 0.75, fill = _C_ } )\n\nnewCircle( group, 345, top + 50, { yScale = 0.75, rotation = 15, fill = _PURPLE_ } )\n\nnewCircle( group, 395, top + 50, { fill = { type =  image , \n                                            baseDir = system.ResourceDirectory, \n                                            filename =  images/water.png } } )\n\nnewCircle( group, 445, top + 50, { \n        fill = { type =  gradient , color1 = { 1, 0, 0.4 }, \n                 color2 = { 1, 0, 0, 0.2 }, direction =  down  }, strokeWidth = 4, \n        stroke = { type =  gradient , color1 = { 0, 1, 0.4 }, \n                   color2 = { 0, 0, 1, 0.2 }, direction =  up  } } )", 
            "title": "Circles - newCircle"
        }, 
        {
            "location": "/libraries/display_samples/#rectangles-newrect", 
            "text": "newRect( group, 45, top + 100 )  \n\nnewRect( group, 95, top + 100, { fill = _R_ } )\n\nnewRect( group, 145, top + 100, { radius = 10, fill = _B_,  stroke = _W_, strokeWidth = 2 } )\n\nnewRect( group, 195, top + 100, { size = 20, fill = _O_ } )\n\nnewRect( group, 245, top + 100, { radius = 20, scale = 0.5, fill = _Y_ } )\n\nnewRect( group, 295, top + 100, { xScale = 0.75, fill = _C_ } )\n\nnewRect( group, 345, top + 100, { yScale = 0.75, rotation = 15, fill = _PURPLE_ } )\n\nnewRect( group, 395, top + 100, { fill = { type =  image , \n                                           baseDir = system.ResourceDirectory, \n                                           filename =  images/water.png } } )\n\nnewRect( group, 445, top + 100, { \n        fill = { type =  gradient , color1 = { 1, 0, 0.4 }, \n                 color2 = { 1, 0, 0, 0.2 }, direction =  down  }, strokeWidth = 4, \n        stroke = { type =  gradient , color1 = { 0, 1, 0.4 }, \n                   color2 = { 0, 0, 1, 0.2 }, direction =  up  } } )", 
            "title": "Rectangles - newRect"
        }, 
        {
            "location": "/libraries/display_samples/#image-rectanges-newimagerect", 
            "text": "newImageRect( group, 45, top + 150,  images/smiley.png  )    \n\nnewImageRect( group, 95, top + 150,  images/smiley.png , { fill = _R_ } )\n\nnewImageRect( group, 145, top + 150,  images/smiley.png , { radius = 10, fill = _B_, \n                                                            stroke = _W_, strokeWidth = 2 } )\n\nnewImageRect( group, 195, top + 150,  images/smiley.png , { size = 20, fill = _O_ } )\n\nnewImageRect( group, 245, top + 150,  images/smiley.png , { radius = 20, scale = 0.5, fill = _Y_ } )\n\nnewImageRect( group, 295, top + 150,  images/smiley.png , { xScale = 0.75, fill = _C_ } )\n\nnewImageRect( group, 345, top + 150,  images/smiley.png , { yScale = 0.75, rotation = 15, fill = _PURPLE_ } )\n\nnewImageRect( group, 395, top + 150,  images/smiley.png , { fill = { type =  image , \n                                                                     baseDir = system.ResourceDirectory, \n                                                                     filename =  images/water.png } } )\n\nnewImageRect( group, 445, top + 150,  images/smiley.png , { \n        fill = { type =  gradient , color1 = { 1, 0, 0.4 }, \n                 color2 = { 1, 0, 0, 0.2 }, direction =  down  }, strokeWidth = 4, \n        stroke = { type =  gradient , color1 = { 0, 1, 0.4 }, \n                   color2 = { 0, 0, 1, 0.2 }, direction =  up  } } )", 
            "title": "Image Rectanges - newImageRect"
        }, 
        {
            "location": "/libraries/display_samples/#bouncing-block-simple-physics", 
            "text": "newImageRect( group, centerX - 100 , centerY - 50,  images/kenney/physicsAssets/yellow_round.png , \n              { size = 40 }, { radius = 20, bounce = 1, gravityScale = 0.2 } )  \n\nnewImageRect( group, centerX - 100, centerY + 100,  images/kenney/physicsAssets/stone/square2.png , \n              { size = 40 }, { bodyType =  static  } )", 
            "title": "Bouncing Block - Simple Physics"
        }, 
        {
            "location": "/libraries/display_samples/#color-switch-like-shape-with-arcs", 
            "text": "local spinGroup = display.newGroup()\ngroup:insert(spinGroup)\nspinGroup.x = centerX - 300\nspinGroup.y = centerY - 50\nssk.display.arc( spinGroup, 0, 0 , \n                  { radius = 50, s = 0, sweep = 90,\n                    strokeColor = _R_, strokeWidth = 6 })\nssk.display.arc( spinGroup, 0, 0 , \n                  { radius = 50, s = 90, sweep = 90,\n                    strokeColor = _G_, strokeWidth = 6 })\nssk.display.arc( spinGroup, 0, 0 , \n                  { radius = 50, s = 180, sweep = 90, \n                    strokeColor = _B_, strokeWidth = 6 })\nssk.display.arc( spinGroup, 0, 0 , \n                  { radius = 50, s = 270, sweep = 90,\n                    strokeColor = _Y_, strokeWidth = 6 })\n\nfunction spinGroup.enterFrame( self )\n    self.rotation = self.rotation + 5 \nend; listen( enterFrame , spinGroup)\n\n\n-- Poly Arcs\nssk.display.polyArc( group, centerX-150, centerY-50,\n      { radius = 50, s = 0, sweep = 180, incr = -0.25, fillColor = _O_ } )\n\n\nssk.display.polyArc( group, centerX-50, centerY-50,\n      { radius = 50, s = 45, sweep = 180, incr = -0.25, fillColor = _P_ } )", 
            "title": "'Color Switch'-like Shape with Arcs"
        }, 
        {
            "location": "/libraries/display_samples/#pac-man-with-poly-arc", 
            "text": "local pac\nlocal curSep = 90\nlocal curDir = -15\n\nlocal function chomp()\n    display.remove(pac)\n   pac = ssk.display.polyArc( group, centerX - 200, centerY + 100,\n      { radius = 50, s = 90 - curSep/2, sweep = 360 - curSep, incr = -0.1, fillColor = _Y_ } )\n   curSep = curSep + curDir\n   if( curSep  = 0 ) then\n    curSep = 0\n    curDir = 15\n   elseif( curSep  = 90 ) then\n    curSep = 90\n    curDir = -15\n   end\nend\ntimer.performWithDelay( 30, chomp, -1 )     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "'Pac-Man' with Poly Arc"
        }, 
        {
            "location": "/libraries/easy_interfaces/", 
            "text": "Easy Interfaces (ssk.easyIFC:*)\n\n\nThe \nEasy Interfaces\n library is a large library designed to produce:\n\n\n\n\nButtons\n - Two-state buttons that execute a listener(s) to do 'work'.  Includes:\n\n\nPush Buttons, Toggle Buttons, and Radio Buttons\n\n\n\n\n\n\nLabels\n - Single-line text objects.\n\n\n\n\nThis library has these features and benefits:\n\n\n\n\nOne Line Creation\n - Make interface objects with a single line of code.\n\n\nPreset Libraries\n  - Create templates (presets) once and use them over-and-over.  \n\n\nSelective Overrides\n - When using presets, override any setting(s) you need, in order to handle one-off cases while still getting the value from presets.\n\n\nMeaningful Listeners\n - While buttons are implemented with touch listeners, I realized that the standard \"began\", \"moved\", and \"ended\" phases didn't really express the proper meaning for most new developers.  So, this library uses these explicit (contextual) \nlisteners\n instead: \nonPress\n, \nonRelease\n, and \nonEvent\n.\n\n\nHyper-Flexible Construction\n - You can use an arbitrary combination of images, rectangles, frames, etc. to build great looking buttons.\n\n\n... more\n\n\n\n\nLastly, this library provides a number of useful \nEffects\n that can be used to give your menus (and other interfaces) juicy visual effects.\n\n\nButton Factories\n\n\n\n\n\n\n\n\nMethod Signatures\n\n\n\n\n\n\n\n\n\n\nssk.easyIFC:newButton( group [, params ] )\n\n\n\n\n\n\nA \nparameterized\n factory used by all other factories to build buttons.\n\n\n\n\n\n\nssk.easyIFC:presetPush( group, presetName, x, y, w, h [, labelText [, onRelease [ , overrideParams ]]] )\n\n\n\n\n\n\nCreates standard push-button \ninstance\n using a \npreset\n record.\n\n\n\n\n\n\nssk.easyIFC:presetToggle( group, presetName, x, y, w, h [, labelText [ , onEvent [, overrideParams ]]] )\n\n\n\n\n\n\nCreates standard toggle-button \ninstance\n using a \npreset\n record.\n\n\n\n\n\n\nssk.easyIFC:presetRadio( group, presetName, x, y , w, h [, labelText [, onRelease [, overrideParams ]]] )\n\n\n\n\n\n\nCreates standard radio-button \ninstance\n using a \npreset\n record.\n\n\n\n\n\n\n\n\n\n\ngroup\n (\ndisplay.currentStage\n) - Group to put button in.\n\n\nparams\n (\n{}\n) - See \nButton Parameters\n below.\n\n\npresetName\n (\n\"default\"\n) - Name of preset record to use for configuring button.\n\n\nSee \nMaking Button Presets\n below.\n\n\n\n\n\n\nx\n, \ny\n - \n x, y \n position of button center. \n\n\nw\n, \nh\n - Width and height of button.\n\n\nlabelText\n (\n\"\"\n) - Optional text for button label.\n\n\nonRelease\n (\nnil\n) - Listener to call when push/radio button is released.\n\n\nonEvent\n (\nnil\n) - Listener to call when toggl button is toggled (on or off).\n\n\noverrideParams\n (\nnil\n) - Optional table of properties to override from preset.\n\n\nSee \nButton Parameters\n below.\n\n\n\n\n\n\n\n\nButton Parameters\n\n\nThe following list is designed as a quick reference to the many button parameters.  \n\n\nTo learn about using these, please explore the samples \nhere\n.\n\n\n\n\nGeneral\n\n\nbuttonType\n (\n\"push\"\n) - \n\"push\"\n, \n\"toggle\"\n \n\"radio\"\n\n\nanchorX\n (\n0.5\n) - Same as Corona SDK \nanchorX\n (\nexternal link\n)\n\n\nanchorY\n (\n0.5\n) - Same as Corona SDK \nanchorY\n (\nexternal link\n)\n\n\nplaceRelative\n (\nfalse\n)- \nExperimental\n option that causes buttons to re-calculate their position relative to the sides of the screen.  (\nUse at your own risk.\n)\n\n\n\n\n\n\nLabel Parameters\n\n\nemboss\n (\nfalse\n) - Use \nembossed\n label.        \n\n\nlabelSize\n (\n20\n) - Font size of label.\n\n\nlabelColor\n (\n_K_\n) - Label color when not selected.\n\n\nselLabelColor\n (\n_K_\n) - Label color when selected.\n\n\nlabelFont\n (\ngameFont\n or \nnative.systemFontBold\n) - Font to use for label.\n\n\nSee \nConfiguring SSK2\n to learn how to set \ngameFont\n.\n\n\n\n\n\n\nlabelOffset\n (\n{0,0}\n) - Table of \nx\n and \ny\n offsets to apply to lable.  Helps center troublesome fonts or push the label above/below/left/right the button if you want that look.\n\n\nlabelHorizAlign\n (\n\"center\"\n) - Label alignments: \n\"left\"\n, \n\"center\"\n, \n\"right\"\n. \n\n\nWarning:\n Not thoroughly tested as I rarely use this feature.    \n\n\n\n\n\n\n\n\n\n\nRectangle Parameters - If you are using plain rectangles for the button representation.\n\n\nunselRectFillColor\n (\n{1,1,1,1}\n) - Fill color for not selected representation of button.\n\n\nselRectFillColor\n (\n{1,1,1,1}\n) - Fill color for selected representation of button.\n\n\ncornerRadius\n (\nnil\n) - EFM\n\n\n\n\n\n\nImage Parameters - If you are using image rectangles for the button representation.\n\n\nunselImgSrc\n (\nEFM\n) - Path and filename of not selected image representation.\n\n\nselImgSrc\n (\nEFM\n) - Path and filename of selected image representation.\n\n\nunselImgFillColor\n (\n{1,1,1,1}\n) - Fill color for not selected representation of button.\n\n\nselImgFillColor\n (\n{1,1,1,1}\n) - Fill color for selected representation of button.\n\n\n\n\n\n\nTouch Masking Parameters\n\n\ntouchMask\n (\nnil\n) - Optional mask image to restrict/enable touch areas on button.\n\n\ntouchMaskW\n, \ntouchMaskH\n - Width and height of mask.\n\n\n\n\n\n\nStroke Parameters\n\n\nunselStrokeColor\n (\n{1,1,1,1}\n) - Stroke color for not selected representation of button.\n\n\nselStrokeColor\n (\n{1,1,1,1}\n) - Stroke color for selected representation of button.\n\n\nstrokeWidth\n (\n0\n) - Stroke width of button.\n\n\nstrokeColor\n (\n{1,1,1,1}\n) - Stroke color for both representations of button. \n\n\nTip:\n Overrides \nunselStrokeColor\n and \nselStrokeColor\n.\n\n\n\n\n\n\n\n\n\n\nOverlay Parameters - If you want to add an optional frame. (\nTip:\n Frame is same size as button and \noverlays\n it.)\n\n\nbuttonOverlayRectColor\n - If specified, create a rectangle using this color over the other visual elements.\n\n\nbuttonOverlayImgSrc\n - If specified, create an image rectangle using this path+filename over the other visual elements.\n\n\nbuttonOverlayFillColor\n - Optional fill color to shade image rectangle overlay.\n\n\n\n\n\n\n\n\nMaking Button Presets\n\n\nMaking a preset is as simple as:\n\n\n\n\nSpecifying a table of \nButton Parameters\n,\n\n\nAdding that table to the list of known button button presets using \naddButtonPreset()\n.\n\n\n\n\n\nlocal params = \n{ \n    labelColor         = {1,1,1,1},\n    labelSize          = 16,\n    labelFont          = gameFont,\n    labelOffset        = {0,1},\n    unselRectFillColor = { 0.25,  0.25,  0.25, 1},\n    selRectFillColor   = {0.5, 0.5, 0.5, 1},\n    strokeWidth        = 1,\n    strokeColor        = {1,1,1,0.5},\n    emboss             = false, \n}\nssk.easyIFC:addButtonPreset( \ndefault\n, params )\n\n\n\n\n\nLater, you can use the preset like this:\n\n\n\neasyIFC:presetPush( group, \ndefault\n, 100, 100, 50, 40, \nHello\n )\n\n\n\n\n\nDefault Presets\n\n\nOne great way to see how easy making presets is, is to look at the default presets that come with SSK2.  \n\n\nThe default SSK2 presets can be found here: \n~\npath to ssk2\n/interfaces/presets/default/\n.\n\n\nRedefining Button Presets\n\n\nYou may redefine a preset at any time in two simple steps:\n\n\n\n\nSpecifying a \nNEW\n table of \nButton Parameters\n,\n\n\nAdding that table to the list of known button presets using \naddButtonPreset()\n using an exiting preset name.\n\n\n\n\nAny buttons created with that preset name after this change will use the new definition.\n\n\nTip:\n This is a handy feature.  You can create your interface using the built-in defaults.  Then, when you are ready, create a custom preset definition file and use the same preset names.  This will replace all the built-in presets with your own.\n\n\nMore Preset Examples\n\n\nYou can download examples of button presets \nhere\n.\n\n\nReady-Made Presets\n\n\nEventually, I expect ready-made presets to be available for free and/or paid paid on:\n\n\n\n\nCorona SDK Marketplace\n\n\nSSK2 Extras Page\n\n\n\n\nButton Instances\n\n\nButton objects are regular display objects.  Thus, they have all the same properties and methods listed on the Corona SDK API \ndisplay.*\n reference page.\n\n\nIn addition, all buttons have the following properties and methods:\n\n\nProperties\n\n\n\n\nisPressed\n - \ntrue\n if button is currently in selected state.\n\n\nTip:\n You should not modify this field, but rather treat it as a \nread-only\n property. \n\n\n\n\n\n\n\n\nMethods\n\n\n\n\nbuttonInstance:pressed( )\n - Returns \ntrue\n if the button is in a 'selected' state.\n\n\nbuttonInstance:toggle( [ noDispatch ] )\n - Toggle the button and execute its listener.\n\n\nTip:\n If you do not want to execute the button's listener, pass \ntrue\n to the method.\n\n\n\n\n\n\nbuttonInstance:disable( )\n - Disable the button.  \n\n\nDisabled buttons ignore touches.\n\n\nChanges alpha of button to 0.5 to show user button is not selectable.    \n\n\n\n\n\n\nbuttonInstance:enable( )\n - Enable a previously disabled button.\n\n\nChanges alpha back to 1.0.\n\n\nStarts responding to touches again.\n\n\n\n\n\n\nbuttonInstance:isEnabled()\n - Returns \ntrue\n if button is enabled.\n\n\nbuttonInstance:getText( )\n - Returns the string currently displayed in the label or \n\"\"\n if blank.\n\n\nbuttonInstance:setText( [ newText ] )\n - Changes label text to \nnewText\n or \n\"\"\n if \nnewText\n is not specified.\n\n\nbuttonInstance:getTextColor()\n - Returns a table representing the color of the label.\n\n\nbuttonInstance:setLabelColor( color )\n - Changes the color of the label.\n\n\nbuttonInstance:adjustLabelOffset( offset )\n - Modifies the offset of the label.\n\n\n\n\nButton Listeners\n\n\nManually\n writing a solid button-listener is not straight-forward and requires a surprisingly large and sophisticated piece of code.  This is often well beyond what most new and intermediate developers can do.\n\n\nFirst, different kinds of buttons should execute their listener code at different times:\n\n\n\n\nPush Button\n - Users expect action to occur when button is released.\n\n\nToggle Button\n - Users expect the action to occur any time the button is released and changes state.\n\n\nRadio Button\n - Users expect the action to occur when the button is released.\n\n\n\n\nSecond, the listener should gracefully handle all the \nweird\n things users do, such as:\n\n\n\n\nTouch a button, slide the finger off the button, then release. - Button visuals should update to tell user the button isn't selected any more and then NOT call the listener.\n\n\nTouch, swipe off, swipe back on, release - Again, update the visuals so the user knows the button state and then call the listener.\n\n\nTouch the screen, then swipe onto a button - The button should entirely ignore this.  It is considered an '\naccidental touch\n'.\n\n\nTouch one button and swipe onto another - Similar to case #1 above, but second button doesn't update visually. This is another '\naccidental touch\n' scenario.\n\n\n... The list goes on and you've got to handle it all.\n\n\n\n\nThird, the listener should work equally well whether the developer has enabled 'multitouch' or not.\n\n\nTo handle all of this, the \nEasy Interfaces\n library uses a single (shared) listener for all buttons.  This function is about 200 lines long and handles all of these interactions and button contexts. \n\n\nAll buttons use this listener by default.  Then, if you want an action to happen at a particular contextual time, you supply your one (or more) small function(s) for one of these three named \nButton Parameters\n\n\nonRelease\n\n\nThis is the default listener for push and radio buttons. \n\n\n\n-- Sample Push Button 'onRelease' Listener\nlocal function onRelease( event )\n    print(\nPushed Button: \n .. tostring( event.target:getText() ) )\nend\n\n-- Create Two Push Buttons\neasyIFC:presetPush( group, \ndefault\n, 100, 100, 50, 40, \nHello\n, onRelease )\neasyIFC:presetPush( group, \ndefault\n, 100, 150, 50, 40, \nWorld\n, onRelease )\n\n\n\n\n\nIf you press the buttons created by this code, they will print:\n\n\n\n\n\"Pushed Button: Hello\"\n \nOR\n \n\"Pushed Button: World\"\n \n\n\n\n\n\n-- Sample Radio Button 'onRelease' Listener\nlocal function onRelease( event )\n    print(\nPushed Button: \n .. tostring( event.target:getText() ) )\nend\n\n-- Create Two Radio\nlocal first = easyIFC:presetRadio( group, \ndefault\n, 100, 100, 50, 40, \nHello\n, onRelease )\neasyIFC:presetRadio( group, \ndefault\n, 100, 150, 50, 40, \nWorld\n, onRelease )\n\nfirst:toggle()\n\n\n\n\n\nAs soon as this code executes, the message \n\"Pushed Button: Hello\"\n will print.\n\n\nThen if you do any of these actions \nNEXT\n:\n\n\n\n\nTouch \"Hello\" button: Nothing is printed.\n\n\nTouch and release \"World\" button:\n\n\n\"Hello\" button will de-select, \n\n\n\"World Button\" will select,\n\n\nWill be print:\n\n\n\"Pushed Button: World\"\n\n\n\n\n\n\n\n\n\n\nTouch \"World\" button, swipe off button, release.\n\n\n\"World\" button will change to its selected visual state and back to deselected.\n\n\nNothing is printed.\n\n\n\n\n\n\nTouch \"Hello\" button, swipe off, release.\n\n\nNo visual state change.\n\n\nNothing is printed.\n\n\n\n\n\n\n\n\nonEvent\n\n\nThis is the default listener for Toggle Buttons.  It is called every time the buttons toggle-state changes.\n\n\nNote:\n The listener is not called when the visual state updates, but when the finger is lifted.  i.e. Swiping on and off of a toggle button will not fire the listener.\n\n\n\n-- Sample Toggle Button 'onEvent' Listener\nlocal function onToggle( event )\n    print(\nPressed Button: \n .. tostring( event.target:getText() ) )\n    print(\nIs pressed ?= \n .. tostring( event.target:pressed() ) )\nend\n\neasyIFC:presetToggle( group, \ndefault\n, 100, 100, 50, 40, \nHello\n, onToggle )\neasyIFC:presetToggle( group, \ndefault\n, 100, 150, 50, 40, \nWorld\n, onToggle )\n\n\n\n\n\nIf you touch these buttons, they will print a message any time you press and release the button.  As expected, they ignore all 'weird' interactions and don't fire their listener unless a real toggle occured.  Both buttons can be toggled and will ignore the state of the other button.\n\n\n\n-- Sample Push Button 'onEvent' Listener\nlocal function onToggle( event )\n    print(\nPressed Button: \n .. tostring( event.target:getText() ) )\n    print(\nIs pressed ?= \n .. tostring( event.target:pressed() ) )\nend\n\neasyIFC:presetPush( group, \ndefault\n, 100, 100, 50, 40, \nHello\n, nil, { onEvent = onToggle } )\neasyIFC:presetPush( group, \ndefault\n, 100, 150, 50, 40, \nWorld\n, nil, { onEvent = onToggle } )\n\n\n\n\n\nThese buttons will fire two events.  First when you touch the button, and second when you release the button.\n\n\nIf you touch a button and swipe away, you will not get the second event.\n\n\nonPress\n\n\nThis listener is rarely used and excutes ONLY on the begining of a button touch.  i.e. It is called when the user first touches the button.\n\n\n\n-- Sample Push Button 'onPress' Listener\nlocal function onPress( event )\n    print(\nPressed Button: \n .. tostring( event.target:getText() ) )\nend\n\neasyIFC:presetPush( group, \ndefault\n, 100, 100, 50, 40, \nHello\n, nil, { onPress = onPress } )\n\n\n\n\n\nTouching this button will fire the listener immediately.  \n\n\nSwiping off and back onto the button is ignored and will not fire the listener again.  \n\n\nYou must lift your finger and touch the button again to get a new call to the listener.\n\n\n\n\nLabel Factories\n\n\npresetLabel\n\n\nCreates label \ninstance\n using a \npreset\n record.\n\n\nssk.easyIFC:presetLabel( group, presetName, text, x, y [, params ] )\n\n\n\n\nquickLabel\n\n\nssk.easyIFC:quickLabel( group, text, x, y [, font [, size [, color [ , anchorX [, anchorY ]]]]] )\n\n\n\n\nquickEmbossedLabel\n\n\nssk.easyIFC:quickEmbossedLabel( group, text, x, y [,font [,size [,colorM [,colorH [,colorS ]]]]] )\n\n\n\n\nLabel Factory Arguments\n\n\nAs you will have noticed, the above factories have a fairly consistent function signature and share common arguments.  Those argument can be summarized as follows:\n\n\n\n\ngroup\n (\ndisplay.currentStage\n) - Group to put button in.\n\n\nparams\n (\n{}\n) - See \nLabel Parameters\n below.\n\n\npresetName\n (\n\"default\"\n) - Name of preset record to use for configuring Label.\n\n\nSee \nMaking Label Presets\n below.\n\n\nx\n, \ny\n - \n x, y \n position of button center. \n\n\nanchorX\n, \nanchorY\n (\n0.5\n) - You can optionally select the anchors for \nquickLabel()\n\n\ntext\n (\n\"\"\n) - Optional text for label.\n\n\nfont\n (\ngameFont\n or \nnative.systemFontBold\n) - Font to use for label.\n        + See \nConfiguring SSK2\n to learn how to set \ngameFont\n.\n\n\nsize\n (\n20\n) - Font size of label.\n\n\ncolor\n (\n_K_\n) - Label color.\n\n\ncolorM\n (\n_W_\n) - Color of embossed label's main stroke.\n\n\ncolorH\n (\n_W_\n) - Color of embossed label's highlight stroke.\n\n\ncolorS\n (\n_K_\n) - Color of embossed label's shadow stroke.\n\n\n\n\nMaking Label Presets\n\n\nMaking a preset is as simple as:\n\n\n\n\nSpecifying a table of \nLabel Parameters\n,\n\n\nAdding that table to the list of known label presets using \naddLabelPreset()\n.\n\n\n\n\n\nlocal params = \n{ \n    font                 = \nBounty Hunter.ttf\n,\n    fontSize             = 32,\n    embossTextColor      = _K_,\n    embossHighlightColor = _Y_,\n    embossShadowColor    = _G_,\n}\nssk.easyIFC:addLabelPreset( \nbounty\n, params )\n\n\n\n\n\nLater, you can use the preset like this:\n\n\n\n-- Use 'bounty' preset, but override fontSize\neasyIFC:presetPush( group, \nbounty\n, \nBoom!\n, 100, 100, { fontSize = 60 } )\n\n\n\n\n\nLabel Preset Parameters\n\n\nPresets\n take all of the following parameters:\n\n\n\n\nfont\n (\ngameFont\n or \nnative.systemFontBold\n) - Font to use for label.\n        + See \nConfiguring SSK2\n to learn how to set \ngameFont\n.\n\n\nfontSize\n (\n20\n) - Font size of label.\n\n\ntextColor\n (\n_K_\n) - Label color.\n\n\nembossTextColor\n (\n_K_\n) - Color of embossed label's main stroke.\n\n\nembossHighlightColor\n (\n_K_\n) - Color of embossed label's highlight stroke.\n\n\nembossShadowColor\n (\n_K_\n) - Color of embossed label's shadow stroke.\n\n\n\n\nLabel Instances\n\n\nLabel Instances are regular display objects.  Thus, they have all the same properties and methods listed on the Corona SDK API \ndisplay.*\n reference page.\n\n\nIn addition, \nPreset\n Label Instances have the following properties and methods:\n\n\nProperties\n\n\n\n\nAll \nLabel Parameters\n are stored as (\nread-only\n) properties on the label instance.\n\n\n\n\nMethods\n\n\n\n\nbuttonInstance:getText( )\n - Returns current text in label.\n\n\nbuttonInstance:setText( [ newText ] )\n - Changes label text to \nnewText\n or \n\"\"\n if \nnewText\n is not specified.\n\n\nbuttonInstance:setFillColors( embossTextColor, embossHighlightColor, embossShadowColor )\n - Allows you to change the emboss colors of embossed label instances.\n\n\nbuttonInstance:setLabelColor( color )\n - Changes the color of the label.\n\n\nbuttonInstance:adjustLabelOffset( offset )\n - Modifies the offset of the label.\n\n\n\n\n\n\nEffects\n\n\nThe button library comes with a set of functions that let you:\n\n\n\n\nMake useful visual calculations.\n\n\nApply cool visual effects.\n\n\n\n\nTip:\n While they were first designed for interfaces, These functions can also be used on other display objects.\n\n\nVisual Calculations\n\n\n\n\nisInBounds( obj, obj2 )\n - Returns \ntrue\n if \nposition\n of \nobj\n over \nobj2\n (inside its axis-aligned-bounding-box.)\n\n\nRemember\n: Anchors affect \nposition\n.\n\n\nUses Corona SDK built-in \nobj2.contentBounds\n (\nexternal link\n).\n\n\n\n\n\n\nisInBounds_alt( obj, obj2 )\n - Same as \nisInBounds( obj, obj2 )\n, but bounds of \nobj2\n are calculated.\n\n\n\n\nFly Ins\n\n\n\n\n\n\nssk.easyIFC.easyFlyIn( obj, params )\n - Cuase an object to move/rotate/scale to some offset, then fly-in to its original rotation and/or position and/or scale.\n\n\ndelay\n (\n0\n) - Wait this long before starting the fly in.\n\n\ntime\n (\n250\n) - Take this long to fly in.\n\n\nmyEasing\n (\neasing.outBack\n) - Use this transition \neasing\n while flying in.\n\n\nsox\n (\n0\n) - Starting \nx\n offset.\n\n\nsoy\n (\n0\n) - Starting \ny\n offset.\n\n\nsdr\n (\n0\n) - Starting \nrotation\n delta.\n\n\nsdsx\n (\n1\n) - Starting \nxScale\n.  (\nCannot be 0.\n)\n\n\nsdsy\n (\n1\n) - Starting \nyScale\n.  (\nCannot be 0.\n)\n\n\nonComplete\n (\nnil\n) - Function to call when transition completes.   \n\n\nfunction( obj ) ... end\n \n\n\n\n\n\n\nonCompleteLabel\n (\nnil\n) - If \nobj\n has an object (usually text object) assigned to property \nobj.label\n, and you provide this parameter, the associated function will be called on the label.\n\n\n\n\n\n\n\n\n\n-- Silly Game\n\nlocal function onPress( event )\n\n   print(\nYou Win!\n)\n\n   transition.cancel( event.target )\n\n   event.target.rotation = 0\n\n   event.target:setText(\nWinner!\n)\n\n   event.target:disable()\n\nend\n\nlocal button = ssk.easyIFC:presetPush( group, \ndefault\n, 150, 100, 250, 40, \n                                       \nPress Before Spinning Stops!\n, onPress )\n\nlocal onComplete\nlocal onComplete2\n\nonComplete = function( obj )\n\n    ssk.easyIFC.easyFlyIn( button, { delay = 1000, time = 1000, sdr = 720, \n                                     myEasing = easing.linear,\n                                     onComplete = onComplete2 } ) \n\nend\n\nonComplete2 = function( obj )\n\n    obj:disable()\n    obj:setText( \nLoser!\n )\n\nend\n\nssk.easyIFC.easyFlyIn( button, { time = 500, sox = -fullw, onComplete = onComplete  } ) \n\n\n\n\n\nFlipping\n\n\n\n\n\n\nssk.easyIFC.easyFlip( obj, params )\n - Like flipping a card.\n\n\n\n\n\n   local button = ssk.easyIFC:presetPush( group, \ndefault\n, x, y, 250, 40, \nFlippy Button\n )\n\n   ssk.easyIFC.easyFlip( button, { delay = 500, time = 1250, myEasing = easing.outBounce } )\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Easy Interfaces (ssk.easyIFC)"
        }, 
        {
            "location": "/libraries/easy_interfaces/#easy-interfaces-sskeasyifc", 
            "text": "The  Easy Interfaces  library is a large library designed to produce:   Buttons  - Two-state buttons that execute a listener(s) to do 'work'.  Includes:  Push Buttons, Toggle Buttons, and Radio Buttons    Labels  - Single-line text objects.   This library has these features and benefits:   One Line Creation  - Make interface objects with a single line of code.  Preset Libraries   - Create templates (presets) once and use them over-and-over.    Selective Overrides  - When using presets, override any setting(s) you need, in order to handle one-off cases while still getting the value from presets.  Meaningful Listeners  - While buttons are implemented with touch listeners, I realized that the standard \"began\", \"moved\", and \"ended\" phases didn't really express the proper meaning for most new developers.  So, this library uses these explicit (contextual)  listeners  instead:  onPress ,  onRelease , and  onEvent .  Hyper-Flexible Construction  - You can use an arbitrary combination of images, rectangles, frames, etc. to build great looking buttons.  ... more   Lastly, this library provides a number of useful  Effects  that can be used to give your menus (and other interfaces) juicy visual effects.", 
            "title": "Easy Interfaces (ssk.easyIFC:*)"
        }, 
        {
            "location": "/libraries/easy_interfaces/#button-factories", 
            "text": "Method Signatures      ssk.easyIFC:newButton( group [, params ] )    A  parameterized  factory used by all other factories to build buttons.    ssk.easyIFC:presetPush( group, presetName, x, y, w, h [, labelText [, onRelease [ , overrideParams ]]] )    Creates standard push-button  instance  using a  preset  record.    ssk.easyIFC:presetToggle( group, presetName, x, y, w, h [, labelText [ , onEvent [, overrideParams ]]] )    Creates standard toggle-button  instance  using a  preset  record.    ssk.easyIFC:presetRadio( group, presetName, x, y , w, h [, labelText [, onRelease [, overrideParams ]]] )    Creates standard radio-button  instance  using a  preset  record.      group  ( display.currentStage ) - Group to put button in.  params  ( {} ) - See  Button Parameters  below.  presetName  ( \"default\" ) - Name of preset record to use for configuring button.  See  Making Button Presets  below.    x ,  y  -   x, y   position of button center.   w ,  h  - Width and height of button.  labelText  ( \"\" ) - Optional text for button label.  onRelease  ( nil ) - Listener to call when push/radio button is released.  onEvent  ( nil ) - Listener to call when toggl button is toggled (on or off).  overrideParams  ( nil ) - Optional table of properties to override from preset.  See  Button Parameters  below.", 
            "title": "Button Factories"
        }, 
        {
            "location": "/libraries/easy_interfaces/#button-parameters", 
            "text": "The following list is designed as a quick reference to the many button parameters.    To learn about using these, please explore the samples  here .   General  buttonType  ( \"push\" ) -  \"push\" ,  \"toggle\"   \"radio\"  anchorX  ( 0.5 ) - Same as Corona SDK  anchorX  ( external link )  anchorY  ( 0.5 ) - Same as Corona SDK  anchorY  ( external link )  placeRelative  ( false )-  Experimental  option that causes buttons to re-calculate their position relative to the sides of the screen.  ( Use at your own risk. )    Label Parameters  emboss  ( false ) - Use  embossed  label.          labelSize  ( 20 ) - Font size of label.  labelColor  ( _K_ ) - Label color when not selected.  selLabelColor  ( _K_ ) - Label color when selected.  labelFont  ( gameFont  or  native.systemFontBold ) - Font to use for label.  See  Configuring SSK2  to learn how to set  gameFont .    labelOffset  ( {0,0} ) - Table of  x  and  y  offsets to apply to lable.  Helps center troublesome fonts or push the label above/below/left/right the button if you want that look.  labelHorizAlign  ( \"center\" ) - Label alignments:  \"left\" ,  \"center\" ,  \"right\" .   Warning:  Not thoroughly tested as I rarely use this feature.          Rectangle Parameters - If you are using plain rectangles for the button representation.  unselRectFillColor  ( {1,1,1,1} ) - Fill color for not selected representation of button.  selRectFillColor  ( {1,1,1,1} ) - Fill color for selected representation of button.  cornerRadius  ( nil ) - EFM    Image Parameters - If you are using image rectangles for the button representation.  unselImgSrc  ( EFM ) - Path and filename of not selected image representation.  selImgSrc  ( EFM ) - Path and filename of selected image representation.  unselImgFillColor  ( {1,1,1,1} ) - Fill color for not selected representation of button.  selImgFillColor  ( {1,1,1,1} ) - Fill color for selected representation of button.    Touch Masking Parameters  touchMask  ( nil ) - Optional mask image to restrict/enable touch areas on button.  touchMaskW ,  touchMaskH  - Width and height of mask.    Stroke Parameters  unselStrokeColor  ( {1,1,1,1} ) - Stroke color for not selected representation of button.  selStrokeColor  ( {1,1,1,1} ) - Stroke color for selected representation of button.  strokeWidth  ( 0 ) - Stroke width of button.  strokeColor  ( {1,1,1,1} ) - Stroke color for both representations of button.   Tip:  Overrides  unselStrokeColor  and  selStrokeColor .      Overlay Parameters - If you want to add an optional frame. ( Tip:  Frame is same size as button and  overlays  it.)  buttonOverlayRectColor  - If specified, create a rectangle using this color over the other visual elements.  buttonOverlayImgSrc  - If specified, create an image rectangle using this path+filename over the other visual elements.  buttonOverlayFillColor  - Optional fill color to shade image rectangle overlay.", 
            "title": "Button Parameters"
        }, 
        {
            "location": "/libraries/easy_interfaces/#making-button-presets", 
            "text": "Making a preset is as simple as:   Specifying a table of  Button Parameters ,  Adding that table to the list of known button button presets using  addButtonPreset() .   \nlocal params = \n{ \n    labelColor         = {1,1,1,1},\n    labelSize          = 16,\n    labelFont          = gameFont,\n    labelOffset        = {0,1},\n    unselRectFillColor = { 0.25,  0.25,  0.25, 1},\n    selRectFillColor   = {0.5, 0.5, 0.5, 1},\n    strokeWidth        = 1,\n    strokeColor        = {1,1,1,0.5},\n    emboss             = false, \n}\nssk.easyIFC:addButtonPreset(  default , params )  Later, you can use the preset like this:  \neasyIFC:presetPush( group,  default , 100, 100, 50, 40,  Hello  )", 
            "title": "Making Button Presets"
        }, 
        {
            "location": "/libraries/easy_interfaces/#default-presets", 
            "text": "One great way to see how easy making presets is, is to look at the default presets that come with SSK2.    The default SSK2 presets can be found here:  ~ path to ssk2 /interfaces/presets/default/ .", 
            "title": "Default Presets"
        }, 
        {
            "location": "/libraries/easy_interfaces/#redefining-button-presets", 
            "text": "You may redefine a preset at any time in two simple steps:   Specifying a  NEW  table of  Button Parameters ,  Adding that table to the list of known button presets using  addButtonPreset()  using an exiting preset name.   Any buttons created with that preset name after this change will use the new definition.  Tip:  This is a handy feature.  You can create your interface using the built-in defaults.  Then, when you are ready, create a custom preset definition file and use the same preset names.  This will replace all the built-in presets with your own.", 
            "title": "Redefining Button Presets"
        }, 
        {
            "location": "/libraries/easy_interfaces/#more-preset-examples", 
            "text": "You can download examples of button presets  here .", 
            "title": "More Preset Examples"
        }, 
        {
            "location": "/libraries/easy_interfaces/#ready-made-presets", 
            "text": "Eventually, I expect ready-made presets to be available for free and/or paid paid on:   Corona SDK Marketplace  SSK2 Extras Page", 
            "title": "Ready-Made Presets"
        }, 
        {
            "location": "/libraries/easy_interfaces/#button-instances", 
            "text": "Button objects are regular display objects.  Thus, they have all the same properties and methods listed on the Corona SDK API  display.*  reference page.  In addition, all buttons have the following properties and methods:", 
            "title": "Button Instances"
        }, 
        {
            "location": "/libraries/easy_interfaces/#properties", 
            "text": "isPressed  -  true  if button is currently in selected state.  Tip:  You should not modify this field, but rather treat it as a  read-only  property.", 
            "title": "Properties"
        }, 
        {
            "location": "/libraries/easy_interfaces/#methods", 
            "text": "buttonInstance:pressed( )  - Returns  true  if the button is in a 'selected' state.  buttonInstance:toggle( [ noDispatch ] )  - Toggle the button and execute its listener.  Tip:  If you do not want to execute the button's listener, pass  true  to the method.    buttonInstance:disable( )  - Disable the button.    Disabled buttons ignore touches.  Changes alpha of button to 0.5 to show user button is not selectable.        buttonInstance:enable( )  - Enable a previously disabled button.  Changes alpha back to 1.0.  Starts responding to touches again.    buttonInstance:isEnabled()  - Returns  true  if button is enabled.  buttonInstance:getText( )  - Returns the string currently displayed in the label or  \"\"  if blank.  buttonInstance:setText( [ newText ] )  - Changes label text to  newText  or  \"\"  if  newText  is not specified.  buttonInstance:getTextColor()  - Returns a table representing the color of the label.  buttonInstance:setLabelColor( color )  - Changes the color of the label.  buttonInstance:adjustLabelOffset( offset )  - Modifies the offset of the label.", 
            "title": "Methods"
        }, 
        {
            "location": "/libraries/easy_interfaces/#button-listeners", 
            "text": "Manually  writing a solid button-listener is not straight-forward and requires a surprisingly large and sophisticated piece of code.  This is often well beyond what most new and intermediate developers can do.  First, different kinds of buttons should execute their listener code at different times:   Push Button  - Users expect action to occur when button is released.  Toggle Button  - Users expect the action to occur any time the button is released and changes state.  Radio Button  - Users expect the action to occur when the button is released.   Second, the listener should gracefully handle all the  weird  things users do, such as:   Touch a button, slide the finger off the button, then release. - Button visuals should update to tell user the button isn't selected any more and then NOT call the listener.  Touch, swipe off, swipe back on, release - Again, update the visuals so the user knows the button state and then call the listener.  Touch the screen, then swipe onto a button - The button should entirely ignore this.  It is considered an ' accidental touch '.  Touch one button and swipe onto another - Similar to case #1 above, but second button doesn't update visually. This is another ' accidental touch ' scenario.  ... The list goes on and you've got to handle it all.   Third, the listener should work equally well whether the developer has enabled 'multitouch' or not.  To handle all of this, the  Easy Interfaces  library uses a single (shared) listener for all buttons.  This function is about 200 lines long and handles all of these interactions and button contexts.   All buttons use this listener by default.  Then, if you want an action to happen at a particular contextual time, you supply your one (or more) small function(s) for one of these three named  Button Parameters", 
            "title": "Button Listeners"
        }, 
        {
            "location": "/libraries/easy_interfaces/#onrelease", 
            "text": "This is the default listener for push and radio buttons.   \n-- Sample Push Button 'onRelease' Listener\nlocal function onRelease( event )\n    print( Pushed Button:   .. tostring( event.target:getText() ) )\nend\n\n-- Create Two Push Buttons\neasyIFC:presetPush( group,  default , 100, 100, 50, 40,  Hello , onRelease )\neasyIFC:presetPush( group,  default , 100, 150, 50, 40,  World , onRelease )  If you press the buttons created by this code, they will print:   \"Pushed Button: Hello\"   OR   \"Pushed Button: World\"     \n-- Sample Radio Button 'onRelease' Listener\nlocal function onRelease( event )\n    print( Pushed Button:   .. tostring( event.target:getText() ) )\nend\n\n-- Create Two Radio\nlocal first = easyIFC:presetRadio( group,  default , 100, 100, 50, 40,  Hello , onRelease )\neasyIFC:presetRadio( group,  default , 100, 150, 50, 40,  World , onRelease )\n\nfirst:toggle()  As soon as this code executes, the message  \"Pushed Button: Hello\"  will print.  Then if you do any of these actions  NEXT :   Touch \"Hello\" button: Nothing is printed.  Touch and release \"World\" button:  \"Hello\" button will de-select,   \"World Button\" will select,  Will be print:  \"Pushed Button: World\"      Touch \"World\" button, swipe off button, release.  \"World\" button will change to its selected visual state and back to deselected.  Nothing is printed.    Touch \"Hello\" button, swipe off, release.  No visual state change.  Nothing is printed.", 
            "title": "onRelease"
        }, 
        {
            "location": "/libraries/easy_interfaces/#onevent", 
            "text": "This is the default listener for Toggle Buttons.  It is called every time the buttons toggle-state changes.  Note:  The listener is not called when the visual state updates, but when the finger is lifted.  i.e. Swiping on and off of a toggle button will not fire the listener.  \n-- Sample Toggle Button 'onEvent' Listener\nlocal function onToggle( event )\n    print( Pressed Button:   .. tostring( event.target:getText() ) )\n    print( Is pressed ?=   .. tostring( event.target:pressed() ) )\nend\n\neasyIFC:presetToggle( group,  default , 100, 100, 50, 40,  Hello , onToggle )\neasyIFC:presetToggle( group,  default , 100, 150, 50, 40,  World , onToggle )  If you touch these buttons, they will print a message any time you press and release the button.  As expected, they ignore all 'weird' interactions and don't fire their listener unless a real toggle occured.  Both buttons can be toggled and will ignore the state of the other button.  \n-- Sample Push Button 'onEvent' Listener\nlocal function onToggle( event )\n    print( Pressed Button:   .. tostring( event.target:getText() ) )\n    print( Is pressed ?=   .. tostring( event.target:pressed() ) )\nend\n\neasyIFC:presetPush( group,  default , 100, 100, 50, 40,  Hello , nil, { onEvent = onToggle } )\neasyIFC:presetPush( group,  default , 100, 150, 50, 40,  World , nil, { onEvent = onToggle } )  These buttons will fire two events.  First when you touch the button, and second when you release the button.  If you touch a button and swipe away, you will not get the second event.", 
            "title": "onEvent"
        }, 
        {
            "location": "/libraries/easy_interfaces/#onpress", 
            "text": "This listener is rarely used and excutes ONLY on the begining of a button touch.  i.e. It is called when the user first touches the button.  \n-- Sample Push Button 'onPress' Listener\nlocal function onPress( event )\n    print( Pressed Button:   .. tostring( event.target:getText() ) )\nend\n\neasyIFC:presetPush( group,  default , 100, 100, 50, 40,  Hello , nil, { onPress = onPress } )  Touching this button will fire the listener immediately.    Swiping off and back onto the button is ignored and will not fire the listener again.    You must lift your finger and touch the button again to get a new call to the listener.", 
            "title": "onPress"
        }, 
        {
            "location": "/libraries/easy_interfaces/#label-factories", 
            "text": "", 
            "title": "Label Factories"
        }, 
        {
            "location": "/libraries/easy_interfaces/#presetlabel", 
            "text": "Creates label  instance  using a  preset  record.  ssk.easyIFC:presetLabel( group, presetName, text, x, y [, params ] )", 
            "title": "presetLabel"
        }, 
        {
            "location": "/libraries/easy_interfaces/#quicklabel", 
            "text": "ssk.easyIFC:quickLabel( group, text, x, y [, font [, size [, color [ , anchorX [, anchorY ]]]]] )", 
            "title": "quickLabel"
        }, 
        {
            "location": "/libraries/easy_interfaces/#quickembossedlabel", 
            "text": "ssk.easyIFC:quickEmbossedLabel( group, text, x, y [,font [,size [,colorM [,colorH [,colorS ]]]]] )", 
            "title": "quickEmbossedLabel"
        }, 
        {
            "location": "/libraries/easy_interfaces/#label-factory-arguments", 
            "text": "As you will have noticed, the above factories have a fairly consistent function signature and share common arguments.  Those argument can be summarized as follows:   group  ( display.currentStage ) - Group to put button in.  params  ( {} ) - See  Label Parameters  below.  presetName  ( \"default\" ) - Name of preset record to use for configuring Label.  See  Making Label Presets  below.  x ,  y  -   x, y   position of button center.   anchorX ,  anchorY  ( 0.5 ) - You can optionally select the anchors for  quickLabel()  text  ( \"\" ) - Optional text for label.  font  ( gameFont  or  native.systemFontBold ) - Font to use for label.\n        + See  Configuring SSK2  to learn how to set  gameFont .  size  ( 20 ) - Font size of label.  color  ( _K_ ) - Label color.  colorM  ( _W_ ) - Color of embossed label's main stroke.  colorH  ( _W_ ) - Color of embossed label's highlight stroke.  colorS  ( _K_ ) - Color of embossed label's shadow stroke.", 
            "title": "Label Factory Arguments"
        }, 
        {
            "location": "/libraries/easy_interfaces/#making-label-presets", 
            "text": "Making a preset is as simple as:   Specifying a table of  Label Parameters ,  Adding that table to the list of known label presets using  addLabelPreset() .   \nlocal params = \n{ \n    font                 =  Bounty Hunter.ttf ,\n    fontSize             = 32,\n    embossTextColor      = _K_,\n    embossHighlightColor = _Y_,\n    embossShadowColor    = _G_,\n}\nssk.easyIFC:addLabelPreset(  bounty , params )  Later, you can use the preset like this:  \n-- Use 'bounty' preset, but override fontSize\neasyIFC:presetPush( group,  bounty ,  Boom! , 100, 100, { fontSize = 60 } )", 
            "title": "Making Label Presets"
        }, 
        {
            "location": "/libraries/easy_interfaces/#label-preset-parameters", 
            "text": "Presets  take all of the following parameters:   font  ( gameFont  or  native.systemFontBold ) - Font to use for label.\n        + See  Configuring SSK2  to learn how to set  gameFont .  fontSize  ( 20 ) - Font size of label.  textColor  ( _K_ ) - Label color.  embossTextColor  ( _K_ ) - Color of embossed label's main stroke.  embossHighlightColor  ( _K_ ) - Color of embossed label's highlight stroke.  embossShadowColor  ( _K_ ) - Color of embossed label's shadow stroke.", 
            "title": "Label Preset Parameters"
        }, 
        {
            "location": "/libraries/easy_interfaces/#label-instances", 
            "text": "Label Instances are regular display objects.  Thus, they have all the same properties and methods listed on the Corona SDK API  display.*  reference page.  In addition,  Preset  Label Instances have the following properties and methods:", 
            "title": "Label Instances"
        }, 
        {
            "location": "/libraries/easy_interfaces/#properties_1", 
            "text": "All  Label Parameters  are stored as ( read-only ) properties on the label instance.", 
            "title": "Properties"
        }, 
        {
            "location": "/libraries/easy_interfaces/#methods_1", 
            "text": "buttonInstance:getText( )  - Returns current text in label.  buttonInstance:setText( [ newText ] )  - Changes label text to  newText  or  \"\"  if  newText  is not specified.  buttonInstance:setFillColors( embossTextColor, embossHighlightColor, embossShadowColor )  - Allows you to change the emboss colors of embossed label instances.  buttonInstance:setLabelColor( color )  - Changes the color of the label.  buttonInstance:adjustLabelOffset( offset )  - Modifies the offset of the label.", 
            "title": "Methods"
        }, 
        {
            "location": "/libraries/easy_interfaces/#effects", 
            "text": "The button library comes with a set of functions that let you:   Make useful visual calculations.  Apply cool visual effects.   Tip:  While they were first designed for interfaces, These functions can also be used on other display objects.", 
            "title": "Effects"
        }, 
        {
            "location": "/libraries/easy_interfaces/#visual-calculations", 
            "text": "isInBounds( obj, obj2 )  - Returns  true  if  position  of  obj  over  obj2  (inside its axis-aligned-bounding-box.)  Remember : Anchors affect  position .  Uses Corona SDK built-in  obj2.contentBounds  ( external link ).    isInBounds_alt( obj, obj2 )  - Same as  isInBounds( obj, obj2 ) , but bounds of  obj2  are calculated.", 
            "title": "Visual Calculations"
        }, 
        {
            "location": "/libraries/easy_interfaces/#fly-ins", 
            "text": "ssk.easyIFC.easyFlyIn( obj, params )  - Cuase an object to move/rotate/scale to some offset, then fly-in to its original rotation and/or position and/or scale.  delay  ( 0 ) - Wait this long before starting the fly in.  time  ( 250 ) - Take this long to fly in.  myEasing  ( easing.outBack ) - Use this transition  easing  while flying in.  sox  ( 0 ) - Starting  x  offset.  soy  ( 0 ) - Starting  y  offset.  sdr  ( 0 ) - Starting  rotation  delta.  sdsx  ( 1 ) - Starting  xScale .  ( Cannot be 0. )  sdsy  ( 1 ) - Starting  yScale .  ( Cannot be 0. )  onComplete  ( nil ) - Function to call when transition completes.     function( obj ) ... end      onCompleteLabel  ( nil ) - If  obj  has an object (usually text object) assigned to property  obj.label , and you provide this parameter, the associated function will be called on the label.     \n-- Silly Game\n\nlocal function onPress( event )\n\n   print( You Win! )\n\n   transition.cancel( event.target )\n\n   event.target.rotation = 0\n\n   event.target:setText( Winner! )\n\n   event.target:disable()\n\nend\n\nlocal button = ssk.easyIFC:presetPush( group,  default , 150, 100, 250, 40, \n                                        Press Before Spinning Stops! , onPress )\n\nlocal onComplete\nlocal onComplete2\n\nonComplete = function( obj )\n\n    ssk.easyIFC.easyFlyIn( button, { delay = 1000, time = 1000, sdr = 720, \n                                     myEasing = easing.linear,\n                                     onComplete = onComplete2 } ) \n\nend\n\nonComplete2 = function( obj )\n\n    obj:disable()\n    obj:setText(  Loser!  )\n\nend\n\nssk.easyIFC.easyFlyIn( button, { time = 500, sox = -fullw, onComplete = onComplete  } )", 
            "title": "Fly Ins"
        }, 
        {
            "location": "/libraries/easy_interfaces/#flipping", 
            "text": "ssk.easyIFC.easyFlip( obj, params )  - Like flipping a card.   \n   local button = ssk.easyIFC:presetPush( group,  default , x, y, 250, 40,  Flippy Button  )\n\n   ssk.easyIFC.easyFlip( button, { delay = 500, time = 1250, myEasing = easing.outBounce } )     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Flipping"
        }, 
        {
            "location": "/libraries/system/", 
            "text": "System Variables and Flags (ssk.system.*)\n\n\nEnvironment Flags\n\n\n\n\n\n\n\n\nSyntax\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\nonSimulator\n\n\ntrue\n if running on Corona SDK simulator.\n\n\n\n\n\n\noniOS\n\n\ntrue\n if running on iPhone or iPad.\n\n\n\n\n\n\nonAndroid\n\n\ntrue\n if running on any Android device.\n\n\n\n\n\n\nonAmazon\n\n\ntrue\n if running on Amazon device.\n\n\n\n\n\n\nonNook\n\n\ntrue\n if running on NOOK device.\n\n\n\n\n\n\nonWinPhone\n\n\ntrue\n if running on Windows phone.\n\n\n\n\n\n\nonAppleTV\n\n\ntrue\n if running on Apple TV device.\n\n\n\n\n\n\nonAndroidTV\n\n\ntrue\n if running on Android TV device. \nNot 100% reliable.\n\n\n\n\n\n\nonOSX\n\n\ntrue\n if running on machine using OS X operating system.\n\n\n\n\n\n\nonWin\n\n\ntrue\n if running on machine using Windows (7/8/10/..) operating system.\n\n\n\n\n\n\nonDesktop\n\n\ntrue\n if onSimulator is \nfalse\n \nAND\n onOSX or onWin is \ntrue\n.\n\n\n\n\n\n\nonDevice\n\n\ntrue\n if running on a device( i.e. NOT simulator).\n\n\n\n\n\n\n\n\nDevice Flags\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\noniPhone\n\n\n\n\n\n\n\n\n\n\n\n\noniPhone4\n\n\noniPhone5\n\n\noniPhone5c\n\n\noniPhone5s\n\n\n\n\n\n\noniPhone6\n\n\noniPhone6Plus\n\n\noniPhone6s\n\n\noniPhone6sPlus\n\n\n\n\n\n\noniPad\n\n\noniPadPro\n\n\n\n\n\n\n\n\n\n\nonAndroidTablet\n\n\nNot 100% reliable.\n\n\n\n\n\n\n\n\n\n\nonTablet\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHow To Export ssk.system.*\n\n\nBy default, SSK2 \nDOES NOT\n export the ssk.system.* variables as globals.  \n\n\nHowever, I find them extremely useful and so you will typically see me exporting them in my examples by setting \nexportSystem\n to \ntrue\n when \ninitializing\n. SSK.\n\n\n_G.ssk.init( { exportSystem = true } )\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "System (ssk.system.)"
        }, 
        {
            "location": "/libraries/system/#system-variables-and-flags-ssksystem", 
            "text": "", 
            "title": "System Variables and Flags (ssk.system.*)"
        }, 
        {
            "location": "/libraries/system/#environment-flags", 
            "text": "Syntax  Summary      onSimulator  true  if running on Corona SDK simulator.    oniOS  true  if running on iPhone or iPad.    onAndroid  true  if running on any Android device.    onAmazon  true  if running on Amazon device.    onNook  true  if running on NOOK device.    onWinPhone  true  if running on Windows phone.    onAppleTV  true  if running on Apple TV device.    onAndroidTV  true  if running on Android TV device.  Not 100% reliable.    onOSX  true  if running on machine using OS X operating system.    onWin  true  if running on machine using Windows (7/8/10/..) operating system.    onDesktop  true  if onSimulator is  false   AND  onOSX or onWin is  true .    onDevice  true  if running on a device( i.e. NOT simulator).", 
            "title": "Environment Flags"
        }, 
        {
            "location": "/libraries/system/#device-flags", 
            "text": "oniPhone       oniPhone4  oniPhone5  oniPhone5c  oniPhone5s    oniPhone6  oniPhone6Plus  oniPhone6s  oniPhone6sPlus    oniPad  oniPadPro      onAndroidTablet  Not 100% reliable.      onTablet", 
            "title": "Device Flags"
        }, 
        {
            "location": "/libraries/system/#how-to-export-ssksystem", 
            "text": "By default, SSK2  DOES NOT  export the ssk.system.* variables as globals.    However, I find them extremely useful and so you will typically see me exporting them in my examples by setting  exportSystem  to  true  when  initializing . SSK.  _G.ssk.init( { exportSystem = true } )     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "How To Export ssk.system.*"
        }, 
        {
            "location": "/libraries/actions1/", 
            "text": "Actions Library (ssk.actions.*) (Part1)\n\n\nThe actions library is a collection of helper modules and functions to do the heavy lifting associated with smooth facing, movement, screen-wrapping, and target acquisition.  \n\n\n\n\nThis library is especially suited to action and arcade style game mechanics.\n\n\n\n\n\n\n\n\nFacing\n\n\nNon-Physics Movement\n\n\n\n\n\n\n\n\n\n\n\n\nface\n\n\nmove.at\n\n\nmove.forward\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPhysics Movement\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmovep.dampDown\n\n\nmovep.dampHoriz\n\n\nmovep.dampNormal\n\n\n\n\n\n\nmovep.dampVert\n\n\nmovep.forward\n\n\nmovep.impulseForward\n\n\n\n\n\n\nmovep.limitV\n\n\nmovep.limitAV\n\n\nmovep.thrustForward\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nScene\n\n\n\n\n\n\n\n\n\n\n\n\nscene.circWrap\n  \nscene.rectWrap\n\n\ntarget.acquireRandom\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTarget Acquisition\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntarget.drawDebugAngleDistanceLabel\n\n\ntarget.drawDebugDistanceLabel\n\n\ntarget.drawDebugLine\n\n\n\n\n\n\ntarget.get\n\n\ntarget.loseAtMaxDistance\n\n\ntarget.loseAtMinAlpha\n\n\n\n\n\n\ntarget.loseNotVisible\n\n\ntarget.loseOnDestroyed\n\n\ntarget.set\n\n\n\n\n\n\n\n\nFacing  (face)\n\n\nface\n\n\nCauses \nobj\n to rotate towards a specific angle or target.  The rate of rotation can be immediate or at a specified number of degrees-per-second (\ndps\n).\n\n\nThis function is typically called in an enterFrame listener and once used must be called every frame.  \n\n\nssk.actions.face( obj, params )\n\n\n\n\n\n\nobj\n - The object to be turned.\n\n\nparams\n - A table of key-value pairs controling the facing algorithm.\n\n\ntarget\n - A display object or table with \nx\n and \ny\n fields.\n\n\nangle\n - A desired rotation angle to face towards.\n\n\nrate\n - A number specifying the degrees-per-second to turn \nobj\n by.  \n\n\nIf set to \nnil\n or not specified, facing is immediate.\n\n\n\n\n\n\npause\n - Do not do any facing calculations during this call.  Simply update the turn timer and exit.\n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    -- Rotate to face the object `enemy` at a rate of 180 degrees-per-second\n    ssk.actions.face( self, { target = enemy, rate = 180 } )\n\nend\n\n\n\n\nTip #1:\n While you must continue to call this function every frame after you first call it, you can pause the facing to temorarily suspend calculations.  This is useful if you want \nobj\n to stop turning, of if you no longer have an angle/target to face.\n\n\nTip #2:\n If used in Combination with \nTarget Acquisition\n functions, you don't need to provide a target.  This will be handled for you.\n\n\n\n\nNon-Physics Movement (move.*)\n\n\nThe actions \nmove\n module provides functions to move object using 'calculated' movement in pixels-per-second.  \n\n\nmove.forward\n\n\nMove at a fixed rate, measured in pixels-per-second (\npps\n), in the direction the object is facing.\n\n\nssk.actions.move.forward( obj, params )\n\n\n\n\n\n\nobj\n - The object to be moved.\n\n\nparams\n - A table of key-value pairs controling the movement algorithm.\n\n\nrate\n (\n100\n) - A number specifying the movement speed in pixels-per-second.\n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    -- Move forward at 300 pixels-per-second\n    ssk.actions.move.forward( self, { rate = 300 } )\n\nend\n\n\n\n\nmove.at\n\n\nMove at a fixed rate, measured in pps, in an arbitrary \n x, y \n direction.\n\n\nssk.actions.move.at( obj, params )\n\n\n\n\n\n\nobj\n - The object to be moved.\n\n\nparams\n - A table of key-value pairs controling the movement algorithm.\n\n\nx\n (\n0\n) - A number specifiying the number of pixels-per-second by which to move in the x-axis.\n\n\ny\n (\n0\n) - A number specifiying the number of pixels-per-second by which to move in the y-axis.\n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    -- Move 'right' at 300 pixels-per-second\n    ssk.actions.move.at( self, { x = 300 } )\n\nend\n\n\n\n\n\n\nPhysics Movement  (movep.*)\n\n\nThe actions \nmovep\n module provides functions to move, limit, and dampen movement using 'calculatoins' and physics methods.  \n\n\nAll objects moved with the \nmovep\n module must have physics bodies.\n\n\nmovep.forward\n\n\nMove \nobj\n foward at a fixed rate, measured in pixels-per-second, using frame-by-frame calculations and \nobj:setLinearVelocity()\n.\n\n\nssk.actions.movep.forward( obj, params )\n\n\n\n\n\n\nobj\n - The object to be moved.\n\n\nparams\n - A table of key-value pairs controling the movement algorithm.\n\n\nrate\n (\n100\n) - A number specifying the movement speed in pixels-per-second.\n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    -- Move forward using physics at a rate of 300 pixels-per-second\n    ssk.actions.movep.forward( self, { rate = 300 } )\n\nend\n\n\n\n\nmovep.thrustForward\n\n\nMove \nobj\n forward by applying a force using calculations and \nobj:applyForce()\n.\n\n\nssk.actions.movep.thrustForward( obj, params )\n\n\n\n\n\n\nobj\n - The object to be moved.\n\n\nparams\n - A table of key-value pairs controling the movement algorithm.\n\n\nrate\n (\n100\n) - A number specifying the magnitude of the force to apply to \nobj\n.        \n\n\nignoreMass\n (\nfalse\n) - By default, \nrate\n is automatically multiplied by the object's mass.  Setting this field to \ntrue\n bypasses that part of the calculation.\n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    -- Move this object forward by applying a 100 units of force.\n    ssk.actions.movep.thrustForward( self, { rate = 100 } )\n\nend\n\n\n\n\nmovep.impulseForward\n\n\nMove \nobj\n forward by applying a impulses (kicks) using calculations and \nobj:applyLinearImpulse()\n.  \n\n\nThis is suitable for use in timed or intermittent movements and can produce some very intersting responses.\n\n\nssk.actions.movep.impulseForward( obj, params )\n\n\n\n\n\n\nobj\n - The object to be moved.\n\n\nparams\n - A table of key-value pairs controling the movement algorithm.\n\n\nrate\n (\n100\n) - A number specifying the magnitude of the impulse force to apply to \nobj\n.        \n\n\nignoreMass\n (\nfalse\n) - By default, \nrate\n is automatically multiplied by the object's mass.  Setting this field to \ntrue\n bypasses that part of the calculation.\n\n\n\n\n\n\n\n\nExample:\n\n\n-- Apply 15 impulses (kicks) to player, one every 250 milliseconds\nfunction player.timer( self )\n    ssk.actions.movep.impulseForward( self, { rate = 25 } )\nend\n\ntimer.performWithDelay( 250, player, 15 )\n\n\n\n\nmovep.limitV\n\n\nLimits an object's linear velocity to a maximum rate in pixels-per-second.\n\n\nThis is often used to place a cap on the maximum rate that can be produced using  \nmovep.thrustForward\n.\n\n\nssk.actions.movep.limitV( obj, params )\n\n\n\n\n\n\nobj\n - The object whose rate is to be limited.\n\n\nparams\n - A table of key-value pairs controling the movement algorithm.\n\n\nrate\n (\n100\n) - Maximum rate object may move at in pixels-per-second.    \n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    -- Accelerate this quickly using 500 units of force, but\n    -- limit the maximum velocity to 750 pixels-per-second\n    ssk.actions.movep.thrustForward( self, { rate = 500 } ) \n    ssk.actions.movep.limitV( self, { rate = 750 } )\n\nend\n\n\n\n\nmovep.limitAV\n\n\nLimits an object's angular velocity to a maximum rate in degrees-per-second.\n\n\nThis is great for things like wheels and circles that turn due to frictional contact with other objects.\n\n\nssk.actions.movep.limitAV( obj, params )\n\n\n\n\n\n\nobj\n - The object whose angular rate is to be limited.\n\n\nparams\n - A table of key-value pairs controling the movement algorithm.\n\n\nrate\n (\n100\n) - Maximum angular rate object may turn at in degrees-per-second.   \n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    ssk.actions.face( self, { target = target, rate = 180 } )\n\nend\n\n\n\n\nmovep.dampVert\n\n\nThis allows you to dampen linear velocity for just the vertical component of an object's movement.\n\n\nssk.actions.movep.dampVert( obj, params )\n\n\n\n\n\n\nobj\n - The object whose angular rate is to be limited.\n\n\nparams\n - A table of key-value pairs controling the damping algorithm.\n\n\ndamping\n (\n1\n) - Damping factor for vertical component of movement.\n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    ssk.actions.movep.dampVert( self, { damping = 1.5 } )\n\nend\n\n\n\n\nmovep.dampHoriz\n\n\nThis allows you to dampen linear velocity for just the horizontal component of an object's movement.\n\n\nssk.actions.movep.dampHoriz( obj, params )\n\n\n\n\n\n\nobj\n - The object whose angular rate is to be limited.\n\n\nparams\n - A table of key-value pairs controling the damping algorithm.\n\n\ndamping\n (\n1\n) - Damping factor for horizontal component of movement.\n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    ssk.actions.movep.dampHoriz( self, { damping = 1.5 } )\n\nend\n\n\n\n\nmovep.dampDown\n\n\nThis allows you to dampen linear velocity for just the downward (\n+y\n) component of an object's movement.\n\n\nssk.actions.movep.dampDown( obj, params )\n\n\n\n\n\n\nobj\n - The object whose angular rate is to be limited.\n\n\nparams\n - A table of key-value pairs controling the damping algorithm.\n\n\ndamping\n (\n1\n) - Damping factor for postive vertical component of movement.\n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    ssk.actions.movep.dampDown( self, { damping = 1.5 } )\n\nend\n\n\n\n\nmovep.dampNormal\n\n\nThis is a very specialized kind of damping that dampens motion that is 90-degrees away from forward motion.\n\n\nThe easiest way to think of this is damping like a tire.  Tires slow movement that is at cross angles to the tire's forward vector.\n\n\nNote:\n Not available yet.\n\n\nssk.actions.movep.dampNormal( obj, params )\n\n\n\n\n\n\nobj\n - The object whose angular rate is to be limited.\n\n\nparams\n - A table of key-value pairs controling the damping algorithm.\n\n\ndamping\n (\n1\n) - Damping factor for motion in the directions of either normal from the forward vector.\n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    ssk.actions.movep.dampNormal( self, { damping = 1.5 } )\n\nend\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.actions.* (Part 1)"
        }, 
        {
            "location": "/libraries/actions1/#actions-library-sskactions-part1", 
            "text": "The actions library is a collection of helper modules and functions to do the heavy lifting associated with smooth facing, movement, screen-wrapping, and target acquisition.     This library is especially suited to action and arcade style game mechanics.     Facing  Non-Physics Movement       face  move.at  move.forward        Physics Movement        movep.dampDown  movep.dampHoriz  movep.dampNormal    movep.dampVert  movep.forward  movep.impulseForward    movep.limitV  movep.limitAV  movep.thrustForward        Scene       scene.circWrap    scene.rectWrap  target.acquireRandom        Target Acquisition        target.drawDebugAngleDistanceLabel  target.drawDebugDistanceLabel  target.drawDebugLine    target.get  target.loseAtMaxDistance  target.loseAtMinAlpha    target.loseNotVisible  target.loseOnDestroyed  target.set", 
            "title": "Actions Library (ssk.actions.*) (Part1)"
        }, 
        {
            "location": "/libraries/actions1/#facing-face", 
            "text": "", 
            "title": "Facing  (face)"
        }, 
        {
            "location": "/libraries/actions1/#face", 
            "text": "Causes  obj  to rotate towards a specific angle or target.  The rate of rotation can be immediate or at a specified number of degrees-per-second ( dps ).  This function is typically called in an enterFrame listener and once used must be called every frame.    ssk.actions.face( obj, params )   obj  - The object to be turned.  params  - A table of key-value pairs controling the facing algorithm.  target  - A display object or table with  x  and  y  fields.  angle  - A desired rotation angle to face towards.  rate  - A number specifying the degrees-per-second to turn  obj  by.    If set to  nil  or not specified, facing is immediate.    pause  - Do not do any facing calculations during this call.  Simply update the turn timer and exit.     Example:  function player.enterFrame( self )\n\n    -- Rotate to face the object `enemy` at a rate of 180 degrees-per-second\n    ssk.actions.face( self, { target = enemy, rate = 180 } )\n\nend  Tip #1:  While you must continue to call this function every frame after you first call it, you can pause the facing to temorarily suspend calculations.  This is useful if you want  obj  to stop turning, of if you no longer have an angle/target to face.  Tip #2:  If used in Combination with  Target Acquisition  functions, you don't need to provide a target.  This will be handled for you.", 
            "title": "face"
        }, 
        {
            "location": "/libraries/actions1/#non-physics-movement-move", 
            "text": "The actions  move  module provides functions to move object using 'calculated' movement in pixels-per-second.", 
            "title": "Non-Physics Movement (move.*)"
        }, 
        {
            "location": "/libraries/actions1/#moveforward", 
            "text": "Move at a fixed rate, measured in pixels-per-second ( pps ), in the direction the object is facing.  ssk.actions.move.forward( obj, params )   obj  - The object to be moved.  params  - A table of key-value pairs controling the movement algorithm.  rate  ( 100 ) - A number specifying the movement speed in pixels-per-second.     Example:  function player.enterFrame( self )\n\n    -- Move forward at 300 pixels-per-second\n    ssk.actions.move.forward( self, { rate = 300 } )\n\nend", 
            "title": "move.forward"
        }, 
        {
            "location": "/libraries/actions1/#moveat", 
            "text": "Move at a fixed rate, measured in pps, in an arbitrary   x, y   direction.  ssk.actions.move.at( obj, params )   obj  - The object to be moved.  params  - A table of key-value pairs controling the movement algorithm.  x  ( 0 ) - A number specifiying the number of pixels-per-second by which to move in the x-axis.  y  ( 0 ) - A number specifiying the number of pixels-per-second by which to move in the y-axis.     Example:  function player.enterFrame( self )\n\n    -- Move 'right' at 300 pixels-per-second\n    ssk.actions.move.at( self, { x = 300 } )\n\nend", 
            "title": "move.at"
        }, 
        {
            "location": "/libraries/actions1/#physics-movement-movep", 
            "text": "The actions  movep  module provides functions to move, limit, and dampen movement using 'calculatoins' and physics methods.    All objects moved with the  movep  module must have physics bodies.", 
            "title": "Physics Movement  (movep.*)"
        }, 
        {
            "location": "/libraries/actions1/#movepforward", 
            "text": "Move  obj  foward at a fixed rate, measured in pixels-per-second, using frame-by-frame calculations and  obj:setLinearVelocity() .  ssk.actions.movep.forward( obj, params )   obj  - The object to be moved.  params  - A table of key-value pairs controling the movement algorithm.  rate  ( 100 ) - A number specifying the movement speed in pixels-per-second.     Example:  function player.enterFrame( self )\n\n    -- Move forward using physics at a rate of 300 pixels-per-second\n    ssk.actions.movep.forward( self, { rate = 300 } )\n\nend", 
            "title": "movep.forward"
        }, 
        {
            "location": "/libraries/actions1/#movepthrustforward", 
            "text": "Move  obj  forward by applying a force using calculations and  obj:applyForce() .  ssk.actions.movep.thrustForward( obj, params )   obj  - The object to be moved.  params  - A table of key-value pairs controling the movement algorithm.  rate  ( 100 ) - A number specifying the magnitude of the force to apply to  obj .          ignoreMass  ( false ) - By default,  rate  is automatically multiplied by the object's mass.  Setting this field to  true  bypasses that part of the calculation.     Example:  function player.enterFrame( self )\n\n    -- Move this object forward by applying a 100 units of force.\n    ssk.actions.movep.thrustForward( self, { rate = 100 } )\n\nend", 
            "title": "movep.thrustForward"
        }, 
        {
            "location": "/libraries/actions1/#movepimpulseforward", 
            "text": "Move  obj  forward by applying a impulses (kicks) using calculations and  obj:applyLinearImpulse() .    This is suitable for use in timed or intermittent movements and can produce some very intersting responses.  ssk.actions.movep.impulseForward( obj, params )   obj  - The object to be moved.  params  - A table of key-value pairs controling the movement algorithm.  rate  ( 100 ) - A number specifying the magnitude of the impulse force to apply to  obj .          ignoreMass  ( false ) - By default,  rate  is automatically multiplied by the object's mass.  Setting this field to  true  bypasses that part of the calculation.     Example:  -- Apply 15 impulses (kicks) to player, one every 250 milliseconds\nfunction player.timer( self )\n    ssk.actions.movep.impulseForward( self, { rate = 25 } )\nend\n\ntimer.performWithDelay( 250, player, 15 )", 
            "title": "movep.impulseForward"
        }, 
        {
            "location": "/libraries/actions1/#moveplimitv", 
            "text": "Limits an object's linear velocity to a maximum rate in pixels-per-second.  This is often used to place a cap on the maximum rate that can be produced using   movep.thrustForward .  ssk.actions.movep.limitV( obj, params )   obj  - The object whose rate is to be limited.  params  - A table of key-value pairs controling the movement algorithm.  rate  ( 100 ) - Maximum rate object may move at in pixels-per-second.         Example:  function player.enterFrame( self )\n\n    -- Accelerate this quickly using 500 units of force, but\n    -- limit the maximum velocity to 750 pixels-per-second\n    ssk.actions.movep.thrustForward( self, { rate = 500 } ) \n    ssk.actions.movep.limitV( self, { rate = 750 } )\n\nend", 
            "title": "movep.limitV"
        }, 
        {
            "location": "/libraries/actions1/#moveplimitav", 
            "text": "Limits an object's angular velocity to a maximum rate in degrees-per-second.  This is great for things like wheels and circles that turn due to frictional contact with other objects.  ssk.actions.movep.limitAV( obj, params )   obj  - The object whose angular rate is to be limited.  params  - A table of key-value pairs controling the movement algorithm.  rate  ( 100 ) - Maximum angular rate object may turn at in degrees-per-second.        Example:  function player.enterFrame( self )\n\n    ssk.actions.face( self, { target = target, rate = 180 } )\n\nend", 
            "title": "movep.limitAV"
        }, 
        {
            "location": "/libraries/actions1/#movepdampvert", 
            "text": "This allows you to dampen linear velocity for just the vertical component of an object's movement.  ssk.actions.movep.dampVert( obj, params )   obj  - The object whose angular rate is to be limited.  params  - A table of key-value pairs controling the damping algorithm.  damping  ( 1 ) - Damping factor for vertical component of movement.     Example:  function player.enterFrame( self )\n\n    ssk.actions.movep.dampVert( self, { damping = 1.5 } )\n\nend", 
            "title": "movep.dampVert"
        }, 
        {
            "location": "/libraries/actions1/#movepdamphoriz", 
            "text": "This allows you to dampen linear velocity for just the horizontal component of an object's movement.  ssk.actions.movep.dampHoriz( obj, params )   obj  - The object whose angular rate is to be limited.  params  - A table of key-value pairs controling the damping algorithm.  damping  ( 1 ) - Damping factor for horizontal component of movement.     Example:  function player.enterFrame( self )\n\n    ssk.actions.movep.dampHoriz( self, { damping = 1.5 } )\n\nend", 
            "title": "movep.dampHoriz"
        }, 
        {
            "location": "/libraries/actions1/#movepdampdown", 
            "text": "This allows you to dampen linear velocity for just the downward ( +y ) component of an object's movement.  ssk.actions.movep.dampDown( obj, params )   obj  - The object whose angular rate is to be limited.  params  - A table of key-value pairs controling the damping algorithm.  damping  ( 1 ) - Damping factor for postive vertical component of movement.     Example:  function player.enterFrame( self )\n\n    ssk.actions.movep.dampDown( self, { damping = 1.5 } )\n\nend", 
            "title": "movep.dampDown"
        }, 
        {
            "location": "/libraries/actions1/#movepdampnormal", 
            "text": "This is a very specialized kind of damping that dampens motion that is 90-degrees away from forward motion.  The easiest way to think of this is damping like a tire.  Tires slow movement that is at cross angles to the tire's forward vector.  Note:  Not available yet.  ssk.actions.movep.dampNormal( obj, params )   obj  - The object whose angular rate is to be limited.  params  - A table of key-value pairs controling the damping algorithm.  damping  ( 1 ) - Damping factor for motion in the directions of either normal from the forward vector.     Example:  function player.enterFrame( self )\n\n    ssk.actions.movep.dampNormal( self, { damping = 1.5 } )\n\nend     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "movep.dampNormal"
        }, 
        {
            "location": "/libraries/actions2/", 
            "text": "Actions Library (ssk.actions.*)  (Part2)\n\n\nThe actions library is a collection of helper modules and functions to do the heavy lifting associated with smooth facing, movement, screen-wrapping, and target acquisition.  \n\n\n\n\nThis library is especially suited to action and arcade style game mechanics.\n\n\n\n\n\n\n\n\nFacing\n\n\nNon-Physics Movement\n\n\n\n\n\n\n\n\n\n\n\n\nface\n\n\nmove.at\n\n\nmove.forward\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPhysics Movement\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmovep.dampDown\n\n\nmovep.dampHoriz\n\n\nmovep.dampNormal\n\n\n\n\n\n\nmovep.dampVert\n\n\nmovep.forward\n\n\nmovep.impulseForward\n\n\n\n\n\n\nmovep.limitV\n\n\nmovep.limitAV\n\n\nmovep.thrustForward\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nScene\n\n\n\n\n\n\n\n\n\n\n\n\nscene.circWrap\n  \nscene.rectWrap\n\n\ntarget.acquireRandom\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTarget Acquisition\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntarget.drawDebugAngleDistanceLabel\n\n\ntarget.drawDebugDistanceLabel\n\n\ntarget.drawDebugLine\n\n\n\n\n\n\ntarget.get\n\n\ntarget.loseAtMaxDistance\n\n\ntarget.loseAtMinAlpha\n\n\n\n\n\n\ntarget.loseNotVisible\n\n\ntarget.loseOnDestroyed\n\n\ntarget.set\n\n\n\n\n\n\n\n\n\n\nScene Wrapping (scene.*)\n\n\nSome action games use a single-screen world that wraps.  That is, if a player or enemy leaves one side of the screen, they re-enter from the other side.\n\n\nThe helper functions in this action module help you achieve this.\n\n\nscene.rectWrap\n\n\nThis helper will wrap one object about the bounds of a rectangle (any display object).\n\n\nThis seem strange at first, but by using a display object as the proxy for wrapping calculations, we have an easy way to define the wrapping space and well as an easy way to debug this.\n\n\nssk.actions.scene.rectWrap( objectToWrap, wrapRectangle )\n\n\n\n\n\n\nobjectToWrap\n - The object that should wrap about a 'wrapping space'.\n\n\nwrapRectangle\n - A display object to act as a proxy and define the 'wrapping space'.\n\n\n\n\nExample:\n\n\n-- Create a rectangle to act as our 'wrapping bounds'\nlocal wrapProxy = display.newRect( display.contentCenterX, display.contentCenterY, 300, 300 )\n\n-- Show it a little so we can see where the wrap should happen\nwrapProxy.alpha = 0.1 \n\n-- Place a player in the center of the wrapProxy and give it a random velocity\nlocal player = display.newCirle( wrapProxy.x, wrapProxy.y, 20 )\n\nphysics:addBody( player )\n\nplayer:setLinearVelocity( math.random( -100, 100), math.random( -100, 100) )\n\n-- Start an enter frame listener and test for wrapping each frame\nfunction player.enterFrame( self )\n    ssk.actions.scene.rectWrap( self, wrapProxy )\nend\n\nRuntime:addEventListener( \nenterFrame\n, player )\n\n\n\n\nscene.circWrap\n\n\nThis helper is similar to \nrectWrap\n, but the wrapping is about a circular space and no proxy is required.\n\n\nssk.actions.scene.circWrap( objectToWrap, point, radius )\n\n\n\n\n\n\nobjectToWrap\n - The object that should wrap about a 'wrapping space'.\n\n\npoint\n - \nx,y\n position of the 'wrapping circle'.\n\n\nradius\n - Radius of the 'wrapping circle'.\n\n\n\n\nExample:\n\n\n\nlocal cx = display.contentCenterX\nlocal cy = display.contentCenterY\n\n-- Place a player in the center of the screen and give it a random velocity\nlocal player = display.newCirle( cx, cy, 20 )\n\nphysics:addBody( player )\n\nplayer:setLinearVelocity( math.random( -100, 100), math.random( -100, 100) )\n\n-- Start an enter frame listener and test for wrapping each frame\nfunction player.enterFrame( self )\n    ssk.actions.scene.circWrap( self, { x = cx, y = cy }, 100 )\nend\n\nRuntime:addEventListener( \nenterFrame\n, player )\n\n\n\n\n\n\nTarget Acquisition (target.*)\n\n\nIn action and arcade games, there is often the need for missiles, gun turrets, enemies, etc. to acquire a target and then chase it down.\n\n\nThe functions in this actions module handle the first half of that work (target acquisition), and you can code up the second half using the \nface\n function in combination with \nmove\n or \nmovep\n functions.\n\n\ntarget.set\n\n\nThis function allows you to manually assign a target to an object.\n\n\nssk.actions.target.set( obj, newTarget )\n\n\n\n\n\n\nobj\n - The object that will be seeking or tracking the target.\n\n\nnewTarget\n - The new target for this object, or \nnil\n to clear the target.\n\n\n\n\nExample:\n\n\n-- Have the player start targeting enemy\nssk.actions.target.set( player, enemy )\n\n\n\n\ntarget.get\n\n\nThis function allows you to manually get an object's current target.  \n\n\nReturns nil if the object has no current target.\n\n\nssk.actions.target.get( obj )\n\n\n\n\n\n\nobj\n - The object that may be tracking a target.\n\n\n\n\nExample:\n\n\n-- Get the player's current target\nlocal curTarget = ssk.actions.target.get( player )\n\n\n\n\ntarget.acquireRandom\n\n\nThis chooses a random target from a target pool and assigns it to \nobj\n.  \n\n\nReturns \ntrue\n if a target was assigned, \nfalse\n otherwise.\n\n\nssk.actions.target.acquireRandom( obj, params )\n\n\n\n\n\n\nobj\n - The object to assign a target to.\n\n\nparams\n - A table of key-value pairs controling the targeting algorithm.\n\n\ntargets\n - A table of targets.\n\n\n\n\n\n\n\n\nExample:\n\n\nssk.actions.target.acquireRandom( self, { targets = targets } )\n\n\n\n\ntarget.acquireNearest\n\n\nThis chooses the nearest target from a target pool and assigns it to \nobj\n.  \n\n\nReturns \ntrue\n if a target was assigned, \nfalse\n otherwise.\n\n\nssk.actions.target.acquireRandom( obj, params )\n\n\n\n\n\n\nobj\n - The object to assign a target to.\n\n\nparams\n - A table of key-value pairs controling the targeting algorithm.\n\n\nmaxDist\n (\nmath.huge\n) - The maximum distance at which a target is considered valid.\n\n\ntargets\n - A table of targets.\n\n\n\n\n\n\n\n\nExample:\n\n\nssk.actions.target.acquireRandom( self, { targets = targets } )\n\n\n\n\ntarget.loseOnDestroyed\n\n\nTell \nobj\n to wipe its current target if that target has been destroyed and is no longer a valid display object.\n\n\nReturns \ntrue\n if \nobj\n no longer has a valid target.\n\n\nssk.actions.target.loseOnDestroyed( obj )\n\n\n\n\n\n\nobj\n - The object whose target we want to check.\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    -- Acquire a new random target if our last one was destroyed, or\n    -- if we don't have one yet.\n    if( ssk.actions.target.loseOnDestroyed( self ) ) then\n        ssk.actions.target.acquireRandom( self, { targets = targets } )\n    end\nend\n\n\n\n\ntarget.loseAtMaxDistance\n\n\nTell \nobj\n to wipe its current target if that target has moved beyond \nmaxDist\n.\n\n\nReturns \ntrue\n if \nobj\n no longer has a valid target.\n\n\nssk.actions.target.loseAtMaxDistance( obj )\n\n\n\n\n\n\nobj\n - The object whose target we want to check.\n\n\nparams\n - A table of key-value pairs controling the targeting algorithm.\n\n\nmaxDist\n (\nmath.huge\n) - The maximum distance at which a target is considered valid.\n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    -- Acquire a new random target if our last one was destroyed, or\n    -- if we don't have one yet.\n    if( ssk.actions.target.loseAtMaxDistance( self, { maxDist = 200 } ) ) then\n        ssk.actions.target.acquireRandom( self, { targets = targets } )\n    end\nend\n\n\n\n\ntarget.loseAtMinAlpha\n\n\nTell \nobj\n to wipe its current target if that target's alpha is below \nalpha\n.\n\n\nReturns \ntrue\n if \nobj\n no longer has a valid target.\n\n\nssk.actions.target.loseAtMinAlpha( obj )\n\n\n\n\n\n\nobj\n - The object whose target we want to check.\n\n\nparams\n - A table of key-value pairs controling the targeting algorithm.\n\n\nalpha\n (\n0.5\n) - The maximum alpha at which a target is considered valid.\n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    -- Acquire a new random target if our last one was destroyed, or\n    -- if we don't have one yet.\n    if( ssk.actions.target.loseAtMinAlpha( self, { alpha = 0.1 } ) ) then\n        ssk.actions.target.acquireRandom( self, { targets = targets } )\n    end\nend\n\n\n\n\ntarget.loseNotVisible\n\n\nTell \nobj\n to wipe its current target if that target is not visible.\n\n\nReturns \ntrue\n if \nobj\n no longer has a valid target.\n\n\nssk.actions.target.loseNotVisible( obj )\n\n\n\n\n\n\nobj\n - The object whose target we want to check.\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    -- Acquire a new random target if our last one was destroyed, or\n    -- if we don't have one yet.\n    if( ssk.actions.target.loseNotVisible( self ) ) then\n        ssk.actions.target.acquireRandom( self, { targets = targets } )\n    end\nend\n\n\n\n\ntarget.drawDebugLine\n\n\nThis is a debug feature that draws a line between \nobj\n and its target.\n\n\nssk.actions.target.drawDebugLine( obj, params )\n\n\n\n\n\n\nobj\n - The object that acts as the anchor for the line.\n\n\nparams\n - A table of key-value pairs controling the targeting algorithm.\n\n\nparent\n - By default, the line is added to \ndisplay.currentStage\n group, but you can specify a another group with this argument.\n\n\n\n\n\n\n\n\nExample:\n\n\nssk.actions.target.drawDebugLine( self )\n\n\n\n\ntarget.drawDebugDistanceLabel\n\n\nThis is a debug feature that draws a label showing the distance from \nobj\n to its target in pixels.\n\n\nssk.actions.target.drawDebugDistanceLabel( obj, params )\n\n\n\n\n\n\nobj\n - The object that acts as the anchor for the line.\n\n\nparams\n - A table of key-value pairs controling the targeting algorithm.\n\n\nparent\n - By default, the line is added to \ndisplay.currentStage\n group, but you can specify a another group with this argument.\n\n\nxOffset\n (\n0\n) - The label's x-position is \nobj.x + xOffset\n.\n\n\nyOffset\n (\n0\n) - The label's y-position is \nobj.y + yOffset\n.\n\n\n\n\n\n\n\n\nExample:\n\n\nssk.actions.target.drawDebugDistanceLabel( self, { yOffset = 40 } )\n\n\n\n\ntarget.drawDebugAngleDistanceLabel\n\n\nThis is a debug feature that draws a label showing the distance from \nobj\n to its target in pixels, as well as the angle between \nobj\n forward and the target.\n\n\nssk.actions.target.drawDebugAngleDistanceLabel( obj, params )\n\n\n\n\n\n\nobj\n - The object that acts as the anchor for the line.\n\n\nparams\n - A table of key-value pairs controling the targeting algorithm.\n\n\nparent\n - By default, the line is added to \ndisplay.currentStage\n group, but you can specify a another group with this argument.\n\n\nxOffset\n (\n0\n) - The label's x-position is \nobj.x + xOffset\n.\n\n\nyOffset\n (\n0\n) - The label's y-position is \nobj.y + yOffset\n.\n\n\n\n\n\n\n\n\nExample:\n\n\nssk.actions.target.drawDebugAngleDistanceLabel( self, { yOffset = 40 } )\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.actions.* (Part 2)"
        }, 
        {
            "location": "/libraries/actions2/#actions-library-sskactions-part2", 
            "text": "The actions library is a collection of helper modules and functions to do the heavy lifting associated with smooth facing, movement, screen-wrapping, and target acquisition.     This library is especially suited to action and arcade style game mechanics.     Facing  Non-Physics Movement       face  move.at  move.forward        Physics Movement        movep.dampDown  movep.dampHoriz  movep.dampNormal    movep.dampVert  movep.forward  movep.impulseForward    movep.limitV  movep.limitAV  movep.thrustForward        Scene       scene.circWrap    scene.rectWrap  target.acquireRandom        Target Acquisition        target.drawDebugAngleDistanceLabel  target.drawDebugDistanceLabel  target.drawDebugLine    target.get  target.loseAtMaxDistance  target.loseAtMinAlpha    target.loseNotVisible  target.loseOnDestroyed  target.set", 
            "title": "Actions Library (ssk.actions.*)  (Part2)"
        }, 
        {
            "location": "/libraries/actions2/#scene-wrapping-scene", 
            "text": "Some action games use a single-screen world that wraps.  That is, if a player or enemy leaves one side of the screen, they re-enter from the other side.  The helper functions in this action module help you achieve this.", 
            "title": "Scene Wrapping (scene.*)"
        }, 
        {
            "location": "/libraries/actions2/#scenerectwrap", 
            "text": "This helper will wrap one object about the bounds of a rectangle (any display object).  This seem strange at first, but by using a display object as the proxy for wrapping calculations, we have an easy way to define the wrapping space and well as an easy way to debug this.  ssk.actions.scene.rectWrap( objectToWrap, wrapRectangle )   objectToWrap  - The object that should wrap about a 'wrapping space'.  wrapRectangle  - A display object to act as a proxy and define the 'wrapping space'.   Example:  -- Create a rectangle to act as our 'wrapping bounds'\nlocal wrapProxy = display.newRect( display.contentCenterX, display.contentCenterY, 300, 300 )\n\n-- Show it a little so we can see where the wrap should happen\nwrapProxy.alpha = 0.1 \n\n-- Place a player in the center of the wrapProxy and give it a random velocity\nlocal player = display.newCirle( wrapProxy.x, wrapProxy.y, 20 )\n\nphysics:addBody( player )\n\nplayer:setLinearVelocity( math.random( -100, 100), math.random( -100, 100) )\n\n-- Start an enter frame listener and test for wrapping each frame\nfunction player.enterFrame( self )\n    ssk.actions.scene.rectWrap( self, wrapProxy )\nend\n\nRuntime:addEventListener(  enterFrame , player )", 
            "title": "scene.rectWrap"
        }, 
        {
            "location": "/libraries/actions2/#scenecircwrap", 
            "text": "This helper is similar to  rectWrap , but the wrapping is about a circular space and no proxy is required.  ssk.actions.scene.circWrap( objectToWrap, point, radius )   objectToWrap  - The object that should wrap about a 'wrapping space'.  point  -  x,y  position of the 'wrapping circle'.  radius  - Radius of the 'wrapping circle'.   Example:  \nlocal cx = display.contentCenterX\nlocal cy = display.contentCenterY\n\n-- Place a player in the center of the screen and give it a random velocity\nlocal player = display.newCirle( cx, cy, 20 )\n\nphysics:addBody( player )\n\nplayer:setLinearVelocity( math.random( -100, 100), math.random( -100, 100) )\n\n-- Start an enter frame listener and test for wrapping each frame\nfunction player.enterFrame( self )\n    ssk.actions.scene.circWrap( self, { x = cx, y = cy }, 100 )\nend\n\nRuntime:addEventListener(  enterFrame , player )", 
            "title": "scene.circWrap"
        }, 
        {
            "location": "/libraries/actions2/#target-acquisition-target", 
            "text": "In action and arcade games, there is often the need for missiles, gun turrets, enemies, etc. to acquire a target and then chase it down.  The functions in this actions module handle the first half of that work (target acquisition), and you can code up the second half using the  face  function in combination with  move  or  movep  functions.", 
            "title": "Target Acquisition (target.*)"
        }, 
        {
            "location": "/libraries/actions2/#targetset", 
            "text": "This function allows you to manually assign a target to an object.  ssk.actions.target.set( obj, newTarget )   obj  - The object that will be seeking or tracking the target.  newTarget  - The new target for this object, or  nil  to clear the target.   Example:  -- Have the player start targeting enemy\nssk.actions.target.set( player, enemy )", 
            "title": "target.set"
        }, 
        {
            "location": "/libraries/actions2/#targetget", 
            "text": "This function allows you to manually get an object's current target.    Returns nil if the object has no current target.  ssk.actions.target.get( obj )   obj  - The object that may be tracking a target.   Example:  -- Get the player's current target\nlocal curTarget = ssk.actions.target.get( player )", 
            "title": "target.get"
        }, 
        {
            "location": "/libraries/actions2/#targetacquirerandom", 
            "text": "This chooses a random target from a target pool and assigns it to  obj .    Returns  true  if a target was assigned,  false  otherwise.  ssk.actions.target.acquireRandom( obj, params )   obj  - The object to assign a target to.  params  - A table of key-value pairs controling the targeting algorithm.  targets  - A table of targets.     Example:  ssk.actions.target.acquireRandom( self, { targets = targets } )", 
            "title": "target.acquireRandom"
        }, 
        {
            "location": "/libraries/actions2/#targetacquirenearest", 
            "text": "This chooses the nearest target from a target pool and assigns it to  obj .    Returns  true  if a target was assigned,  false  otherwise.  ssk.actions.target.acquireRandom( obj, params )   obj  - The object to assign a target to.  params  - A table of key-value pairs controling the targeting algorithm.  maxDist  ( math.huge ) - The maximum distance at which a target is considered valid.  targets  - A table of targets.     Example:  ssk.actions.target.acquireRandom( self, { targets = targets } )", 
            "title": "target.acquireNearest"
        }, 
        {
            "location": "/libraries/actions2/#targetloseondestroyed", 
            "text": "Tell  obj  to wipe its current target if that target has been destroyed and is no longer a valid display object.  Returns  true  if  obj  no longer has a valid target.  ssk.actions.target.loseOnDestroyed( obj )   obj  - The object whose target we want to check.   Example:  function player.enterFrame( self )\n\n    -- Acquire a new random target if our last one was destroyed, or\n    -- if we don't have one yet.\n    if( ssk.actions.target.loseOnDestroyed( self ) ) then\n        ssk.actions.target.acquireRandom( self, { targets = targets } )\n    end\nend", 
            "title": "target.loseOnDestroyed"
        }, 
        {
            "location": "/libraries/actions2/#targetloseatmaxdistance", 
            "text": "Tell  obj  to wipe its current target if that target has moved beyond  maxDist .  Returns  true  if  obj  no longer has a valid target.  ssk.actions.target.loseAtMaxDistance( obj )   obj  - The object whose target we want to check.  params  - A table of key-value pairs controling the targeting algorithm.  maxDist  ( math.huge ) - The maximum distance at which a target is considered valid.     Example:  function player.enterFrame( self )\n\n    -- Acquire a new random target if our last one was destroyed, or\n    -- if we don't have one yet.\n    if( ssk.actions.target.loseAtMaxDistance( self, { maxDist = 200 } ) ) then\n        ssk.actions.target.acquireRandom( self, { targets = targets } )\n    end\nend", 
            "title": "target.loseAtMaxDistance"
        }, 
        {
            "location": "/libraries/actions2/#targetloseatminalpha", 
            "text": "Tell  obj  to wipe its current target if that target's alpha is below  alpha .  Returns  true  if  obj  no longer has a valid target.  ssk.actions.target.loseAtMinAlpha( obj )   obj  - The object whose target we want to check.  params  - A table of key-value pairs controling the targeting algorithm.  alpha  ( 0.5 ) - The maximum alpha at which a target is considered valid.     Example:  function player.enterFrame( self )\n\n    -- Acquire a new random target if our last one was destroyed, or\n    -- if we don't have one yet.\n    if( ssk.actions.target.loseAtMinAlpha( self, { alpha = 0.1 } ) ) then\n        ssk.actions.target.acquireRandom( self, { targets = targets } )\n    end\nend", 
            "title": "target.loseAtMinAlpha"
        }, 
        {
            "location": "/libraries/actions2/#targetlosenotvisible", 
            "text": "Tell  obj  to wipe its current target if that target is not visible.  Returns  true  if  obj  no longer has a valid target.  ssk.actions.target.loseNotVisible( obj )   obj  - The object whose target we want to check.   Example:  function player.enterFrame( self )\n\n    -- Acquire a new random target if our last one was destroyed, or\n    -- if we don't have one yet.\n    if( ssk.actions.target.loseNotVisible( self ) ) then\n        ssk.actions.target.acquireRandom( self, { targets = targets } )\n    end\nend", 
            "title": "target.loseNotVisible"
        }, 
        {
            "location": "/libraries/actions2/#targetdrawdebugline", 
            "text": "This is a debug feature that draws a line between  obj  and its target.  ssk.actions.target.drawDebugLine( obj, params )   obj  - The object that acts as the anchor for the line.  params  - A table of key-value pairs controling the targeting algorithm.  parent  - By default, the line is added to  display.currentStage  group, but you can specify a another group with this argument.     Example:  ssk.actions.target.drawDebugLine( self )", 
            "title": "target.drawDebugLine"
        }, 
        {
            "location": "/libraries/actions2/#targetdrawdebugdistancelabel", 
            "text": "This is a debug feature that draws a label showing the distance from  obj  to its target in pixels.  ssk.actions.target.drawDebugDistanceLabel( obj, params )   obj  - The object that acts as the anchor for the line.  params  - A table of key-value pairs controling the targeting algorithm.  parent  - By default, the line is added to  display.currentStage  group, but you can specify a another group with this argument.  xOffset  ( 0 ) - The label's x-position is  obj.x + xOffset .  yOffset  ( 0 ) - The label's y-position is  obj.y + yOffset .     Example:  ssk.actions.target.drawDebugDistanceLabel( self, { yOffset = 40 } )", 
            "title": "target.drawDebugDistanceLabel"
        }, 
        {
            "location": "/libraries/actions2/#targetdrawdebugangledistancelabel", 
            "text": "This is a debug feature that draws a label showing the distance from  obj  to its target in pixels, as well as the angle between  obj  forward and the target.  ssk.actions.target.drawDebugAngleDistanceLabel( obj, params )   obj  - The object that acts as the anchor for the line.  params  - A table of key-value pairs controling the targeting algorithm.  parent  - By default, the line is added to  display.currentStage  group, but you can specify a another group with this argument.  xOffset  ( 0 ) - The label's x-position is  obj.x + xOffset .  yOffset  ( 0 ) - The label's y-position is  obj.y + yOffset .     Example:  ssk.actions.target.drawDebugAngleDistanceLabel( self, { yOffset = 40 } )     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "target.drawDebugAngleDistanceLabel"
        }, 
        {
            "location": "/libraries/android/", 
            "text": "Android Helpers (ssk.android.*)\n\n\nThis library contains a few helper functions to handle common Android issues/tasks.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncaptureBackButton\n\n\ncaptureVolumeButtons\n\n\neasyAndroidUIVisibility\n\n\n\n\n\n\n\n\ncaptureBackButton\n\n\nCapture the back button on Android devices and prompt the user to be sure they really want to leave the app.\n\n\nWhen user presses back button they are prompted with a pop-up dialog:\n\n\n\n\nssk.android.captureBackButton( [ noCB, [ yesCB ] ] )\n\n\n\n\n\n\nnoCB\n - Optional function to execute if the user selects \"NO\".\n\n\nyesCB\n - Optional function to execute if the user selects \"YES\".\n\n\n\n\n\nlocal onNo()\n   print(\nPressed No\n)   \nend\n\nlocal onYes()\n   print(\nPressed Yes\n)\nend\n\nssk.android.captureBackButton( onNo, onYes )\n\n\n\n\n\ncaptureVolumeButtons\n\n\nCapture the volume buttons on Android and do something when they are pressed.\n\n\nssk.android.captureVolumeButtons( [ block, [ volUp, [ volDown ] ] ] )\n\n\n\n\n\n\nblock\n ( \ntrue\n ) - If \ntrue\n block the volume change action.\n\n\nvolUp\n - Optional function to execute if the user selects \"volUp\".\n\n\nvolDown\n - Optional function to execute if the user selects \"volDown\".\n\n\n\n\n\nlocal upUp()\n   print(\nUse tried to increase volume\n)   \nend\n\nlocal onDown()\n   print(\nUse tried to decrease volume\n)   \nend\n\nssk.android.captureBackButton( true, onUp, onDown )\n\n\n\n\n\neasyAndroidUIVisibility\n\n\nEasily hide Android virtual buttons (back, home, ... ).\n\n\nssk.android.easyAndroidUIVisibility( [ profile ] ] )\n\n\n\n\n\n\nprofile\n ( \n\"immersiveSticky\"\n ) - Style of visibility selection:\n\n\n\"immersiveSticky\"\n - Cause the status and navigation bars to disappear. \n\n\nIf the user swipes from the top or bottom, they \nwill reappear and then disappear again.\n\n\nOnly on Android KitKat (Api 19) or above.\n\n\n\n\n\n\n\"immersive\"\n -  Cause the status and navigation bars to disappear. \n\n\nIf the user swipes from the top or bottom, they will reappear and stay.\n\n\nWARNING:\n A resize event will be triggered and the objects on the screen will need to be manually re-rendered. This is because the content scaling for the device changes and the objects will not have the correct aspect ratio unless they are re-rendered (removed and restored).\n\n\n\n\n\n\nOnly on Android KitKat (Api 19) or above. \n\n\n\n\n\n\n\"lowProfile\"\n - Dims the navigation bar icons.\n\n\nOnly on Android Ice Cream Sandwich (Api 14) or above.\n\n\n\n\n\n\n\"default\"\n - Resets the value.\n\n\n\n\n\n\n\n\n\n-- Automatically use 'immersiveSticky' if available.\nssk.android.easyAndroidUIVisibility( nil )\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.android.*"
        }, 
        {
            "location": "/libraries/android/#android-helpers-sskandroid", 
            "text": "This library contains a few helper functions to handle common Android issues/tasks.            captureBackButton  captureVolumeButtons  easyAndroidUIVisibility", 
            "title": "Android Helpers (ssk.android.*)"
        }, 
        {
            "location": "/libraries/android/#capturebackbutton", 
            "text": "Capture the back button on Android devices and prompt the user to be sure they really want to leave the app.  When user presses back button they are prompted with a pop-up dialog:   ssk.android.captureBackButton( [ noCB, [ yesCB ] ] )   noCB  - Optional function to execute if the user selects \"NO\".  yesCB  - Optional function to execute if the user selects \"YES\".   \nlocal onNo()\n   print( Pressed No )   \nend\n\nlocal onYes()\n   print( Pressed Yes )\nend\n\nssk.android.captureBackButton( onNo, onYes )", 
            "title": "captureBackButton"
        }, 
        {
            "location": "/libraries/android/#capturevolumebuttons", 
            "text": "Capture the volume buttons on Android and do something when they are pressed.  ssk.android.captureVolumeButtons( [ block, [ volUp, [ volDown ] ] ] )   block  (  true  ) - If  true  block the volume change action.  volUp  - Optional function to execute if the user selects \"volUp\".  volDown  - Optional function to execute if the user selects \"volDown\".   \nlocal upUp()\n   print( Use tried to increase volume )   \nend\n\nlocal onDown()\n   print( Use tried to decrease volume )   \nend\n\nssk.android.captureBackButton( true, onUp, onDown )", 
            "title": "captureVolumeButtons"
        }, 
        {
            "location": "/libraries/android/#easyandroiduivisibility", 
            "text": "Easily hide Android virtual buttons (back, home, ... ).  ssk.android.easyAndroidUIVisibility( [ profile ] ] )   profile  (  \"immersiveSticky\"  ) - Style of visibility selection:  \"immersiveSticky\"  - Cause the status and navigation bars to disappear.   If the user swipes from the top or bottom, they \nwill reappear and then disappear again.  Only on Android KitKat (Api 19) or above.    \"immersive\"  -  Cause the status and navigation bars to disappear.   If the user swipes from the top or bottom, they will reappear and stay.  WARNING:  A resize event will be triggered and the objects on the screen will need to be manually re-rendered. This is because the content scaling for the device changes and the objects will not have the correct aspect ratio unless they are re-rendered (removed and restored).    Only on Android KitKat (Api 19) or above.     \"lowProfile\"  - Dims the navigation bar icons.  Only on Android Ice Cream Sandwich (Api 14) or above.    \"default\"  - Resets the value.     \n-- Automatically use 'immersiveSticky' if available.\nssk.android.easyAndroidUIVisibility( nil )     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "easyAndroidUIVisibility"
        }, 
        {
            "location": "/libraries/camera/", 
            "text": "Camera Library (ssk.camera.*)\n\n\nA number of basic cameras you can use out-of-the-box, or that you can copy and modify to meet your specific game requirements/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndelayedTracking\n\n\ntracking\n\n\n\n\n\n\ntrackingLooseCircle\n\n\ntrackingLooseRectangle\n\n\n\n\n\n\n\n\ntracking\n\n\nA camera that tracks the position of the \ntrackObj\n exactly, keeping it in the exact position it started in or has specified to be at.\n\n\nThis camera supports the ability to track in only one axis and/or to adjust the tracking offset. \n\n\nTip\n: Deleting \ntrackObj\n and/or the \nworld\n display group before stopping the camera, you will crash your game.  See \nStopping Cameras\n below for more details.\n\n\nssk.camera.tracking( trackObj, world [ , params ]  )\n\n\n\n\n\n\ntrackObj\n - The object to track with the camera.\n\n\nworld\n - The group that contains all other groups and objects including \ntrackObj\n.\n\n\nparams\n - An optional table of named settings:\n\n\ncentered\n (\nfalse\n) - If \ntrue\n, forces camera tracking to center of screen.\n\n\nlockX\n (\nfalse\n) - If \ntrue\n, tracking ignores x-movement.\n\n\nlockY\n (\nfalse\n) - If \ntrue\n, tracking ignores y-movement.\n\n\nlx\n - If specified, this is the x-position to track at.  \n\n\nDefaults to starting x-position of \ntrackObj\n.\n\n\n\n\n\n\nly\n - If specified, this is the y-position to track at.\n\n\nDefaults to starting y-position of \ntrackObj\n.    \n\n\n\n\n\n\n\n\n\n\n\n\n\n-- Create some basic layers.\n--\nlocal layers = quickLayers( group, \n      \nunderlay\n,\n      \nworld\n,\n         { \ncircles\n, \nplayer\n },\n      \noverlay\n )\n\nlocal player = newImageRect( layers.player, centerX, centerY, \nimages/smiley.png\n )\n\nssk.camera.tracking( player, layers.world )\n\n\n\n\n\ndelayedTracking\n\n\nAn \nexperimental\n camera that waits a moment then moves to the new position of the \ntrackObj\n.\n\n\nNote:\n I don't use this one.  It is meant to be a starting place for delayed cameras.  If you need such a camera, examine this code and then write your own camera function.\n\n\nTip\n: Deleting \ntrackObj\n and/or the \nworld\n display group before stopping the camera, you will crash your game.  See \nStopping Cameras\n below for more details.\n\n\nssk.camera.delayedTracking(  )\n\n\n\n\n\n\ntrackObj\n - The object to track with the camera.\n\n\nworld\n - The group that contains all other groups and objects including \ntrackObj\n.\n\n\nparams\n - An optional table of named settings:\n\n\ncentered\n (\nfalse\n) - If \ntrue\n, forces camera tracking to center of screen.\n\n\nlockX\n (\nfalse\n) - If \ntrue\n, tracking ignores x-movement.\n\n\nlockY\n (\nfalse\n) - If \ntrue\n, tracking ignores y-movement.\n\n\nlx\n - If specified, this is the x-position to track at.  \n\n\nDefaults to starting x-position of \ntrackObj\n.\n\n\n\n\n\n\nly\n - If specified, this is the y-position to track at.\n\n\nDefaults to starting y-position of \ntrackObj\n.\n\n\n\n\n\n\n\n\n\n\n\n\ntrackingLooseCircle\n\n\n\n\nA camera that tracks the \ntrackObj\n continuously, but only moves the \nworld\n once the  \ntrackObj\n moves beyond the radius of a dead zone.  After that, \nworld\n movement accelerates gradually to match that of \ntrackObj\n.  \n\n\nIncludes a debug feature to allow you to see the limits of the dead zone.\n\n\nTip\n: Deleting \ntrackObj\n and/or the \nworld\n display group before stopping the camera, you will crash your game.  See \nStopping Cameras\n below for more details.\n\n\nssk.camera.trackingLooseCircle( trackObj, world [ , params ]  )\n\n\n\n\n\n\ntrackObj\n - The object to track with the camera.\n\n\nworld\n - The group that contains all other groups and objects including \ntrackObj\n.\n\n\nparams\n - An optional table of named settings:\n\n\ndebugEn\n (\nfalse\n) - Enable debug feedback (see summary above).\n\n\ndeadRadius\n (\n100\n) - Radius of dead zone.\n\n\nbufferSize\n (\n50\n) - Width of zone outside \ndeadRadius\n where camera starts to move.  \n\n\nCamera will be moving at same rate as \ntrackObj\n once that object is at \ndeadRadius\n + \nbufferSize\n distance from camera center.\n\n\n\n\n\n\n\n\n\n\n\n\ntrackingLooseRectangle\n\n\nA camera that tracks the \ntrackObj\n continuously, but only moves the \nworld\n once the \ntrackObj\n moves beyond the bounds of a rectangular dead zone.  After that, \nworld\n movement accelerates gradually to match that of \ntrackObj\n.  \n\n\nTip\n: Deleting \ntrackObj\n and/or the \nworld\n display group before stopping the camera, you will crash your game.  See \nStopping Cameras\n below for more details.\n\n\nssk.camera.trackingLooseRectangle( trackObj, world [ , params ]  )\n\n\n\n\n\n\ntrackObj\n - The object to track with the camera.\n\n\nworld\n - The group that contains all other groups and objects including \ntrackObj\n.\n\n\nparams\n - An optional table of named settings:   \n\n\nboundarySize\n (\n100\n) - Pixel width of boudary. \n\n\nThe tracking rectangle is centered on the screen and has a width and height equal to the \nfullw - boundarySize\n and \nfullh - boundarySize\n respectively. \n\n\n\n\n\n\nminDelta\n (\n0.2\n) - Controls sensitivity of movement when boundary is encountered.\n\n\n\n\n\n\n\n\nStopping Cameras\n\n\nOnce a camera has been started, it will run continously until it is stopped.  \n\n\nWhen a camera is started, it adds a method to the \ntrackObj\n called \nstopCamera()\n.\n\n\nStopping a previously started camera is a simple as:\n\n\n\nplayer:stopCamera()\n\n\n\n\n\nTips\n\n\n\n\nDeleting \ntrackObj\n and/or the \nworld\n display group before stopping the camera, you will crash your game.\n\n\nOnce a camere has been stopped, you must re-start it using the same code you did initially.\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.camera.*"
        }, 
        {
            "location": "/libraries/camera/#camera-library-sskcamera", 
            "text": "A number of basic cameras you can use out-of-the-box, or that you can copy and modify to meet your specific game requirements/            delayedTracking  tracking    trackingLooseCircle  trackingLooseRectangle", 
            "title": "Camera Library (ssk.camera.*)"
        }, 
        {
            "location": "/libraries/camera/#tracking", 
            "text": "A camera that tracks the position of the  trackObj  exactly, keeping it in the exact position it started in or has specified to be at.  This camera supports the ability to track in only one axis and/or to adjust the tracking offset.   Tip : Deleting  trackObj  and/or the  world  display group before stopping the camera, you will crash your game.  See  Stopping Cameras  below for more details.  ssk.camera.tracking( trackObj, world [ , params ]  )   trackObj  - The object to track with the camera.  world  - The group that contains all other groups and objects including  trackObj .  params  - An optional table of named settings:  centered  ( false ) - If  true , forces camera tracking to center of screen.  lockX  ( false ) - If  true , tracking ignores x-movement.  lockY  ( false ) - If  true , tracking ignores y-movement.  lx  - If specified, this is the x-position to track at.    Defaults to starting x-position of  trackObj .    ly  - If specified, this is the y-position to track at.  Defaults to starting y-position of  trackObj .           \n-- Create some basic layers.\n--\nlocal layers = quickLayers( group, \n       underlay ,\n       world ,\n         {  circles ,  player  },\n       overlay  )\n\nlocal player = newImageRect( layers.player, centerX, centerY,  images/smiley.png  )\n\nssk.camera.tracking( player, layers.world )", 
            "title": "tracking"
        }, 
        {
            "location": "/libraries/camera/#delayedtracking", 
            "text": "An  experimental  camera that waits a moment then moves to the new position of the  trackObj .  Note:  I don't use this one.  It is meant to be a starting place for delayed cameras.  If you need such a camera, examine this code and then write your own camera function.  Tip : Deleting  trackObj  and/or the  world  display group before stopping the camera, you will crash your game.  See  Stopping Cameras  below for more details.  ssk.camera.delayedTracking(  )   trackObj  - The object to track with the camera.  world  - The group that contains all other groups and objects including  trackObj .  params  - An optional table of named settings:  centered  ( false ) - If  true , forces camera tracking to center of screen.  lockX  ( false ) - If  true , tracking ignores x-movement.  lockY  ( false ) - If  true , tracking ignores y-movement.  lx  - If specified, this is the x-position to track at.    Defaults to starting x-position of  trackObj .    ly  - If specified, this is the y-position to track at.  Defaults to starting y-position of  trackObj .", 
            "title": "delayedTracking"
        }, 
        {
            "location": "/libraries/camera/#trackingloosecircle", 
            "text": "A camera that tracks the  trackObj  continuously, but only moves the  world  once the   trackObj  moves beyond the radius of a dead zone.  After that,  world  movement accelerates gradually to match that of  trackObj .    Includes a debug feature to allow you to see the limits of the dead zone.  Tip : Deleting  trackObj  and/or the  world  display group before stopping the camera, you will crash your game.  See  Stopping Cameras  below for more details.  ssk.camera.trackingLooseCircle( trackObj, world [ , params ]  )   trackObj  - The object to track with the camera.  world  - The group that contains all other groups and objects including  trackObj .  params  - An optional table of named settings:  debugEn  ( false ) - Enable debug feedback (see summary above).  deadRadius  ( 100 ) - Radius of dead zone.  bufferSize  ( 50 ) - Width of zone outside  deadRadius  where camera starts to move.    Camera will be moving at same rate as  trackObj  once that object is at  deadRadius  +  bufferSize  distance from camera center.", 
            "title": "trackingLooseCircle"
        }, 
        {
            "location": "/libraries/camera/#trackinglooserectangle", 
            "text": "A camera that tracks the  trackObj  continuously, but only moves the  world  once the  trackObj  moves beyond the bounds of a rectangular dead zone.  After that,  world  movement accelerates gradually to match that of  trackObj .    Tip : Deleting  trackObj  and/or the  world  display group before stopping the camera, you will crash your game.  See  Stopping Cameras  below for more details.  ssk.camera.trackingLooseRectangle( trackObj, world [ , params ]  )   trackObj  - The object to track with the camera.  world  - The group that contains all other groups and objects including  trackObj .  params  - An optional table of named settings:     boundarySize  ( 100 ) - Pixel width of boudary.   The tracking rectangle is centered on the screen and has a width and height equal to the  fullw - boundarySize  and  fullh - boundarySize  respectively.     minDelta  ( 0.2 ) - Controls sensitivity of movement when boundary is encountered.", 
            "title": "trackingLooseRectangle"
        }, 
        {
            "location": "/libraries/camera/#stopping-cameras", 
            "text": "Once a camera has been started, it will run continously until it is stopped.    When a camera is started, it adds a method to the  trackObj  called  stopCamera() .  Stopping a previously started camera is a simple as:  \nplayer:stopCamera()  Tips   Deleting  trackObj  and/or the  world  display group before stopping the camera, you will crash your game.  Once a camere has been stopped, you must re-start it using the same code you did initially.      Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Stopping Cameras"
        }, 
        {
            "location": "/libraries/cc/", 
            "text": "Collision Calculator (ssk.cc.*)\n\n\nThe \nCollision Calculator\n allows you to quickly and easily configure single-body collisions rules using names instead of numbers.\n\n\nCreating a Calculator\n\n\nCreating a new myCC is as easy as:\n\n\nlocal myCC = ssk.cc.newCalculator()\n\n\n\n\nCalculator Methods (myCC:*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\naddName\n\n\naddNames\n\n\ncollidesWith\n\n\n\n\n\n\ngetCategoryBits\n\n\ngetMaskBits\n\n\ngetCollisionFilter\n\n\n\n\n\n\ndump\n\n\n\n\n\n\n\n\n\n\n\n\naddName\n\n\nAdd new 'named' collider type to known list of collider types, and automatically assign a number to this collider type (16 Max).\n\n\nmyCC:addName( colliderName )\n\n\n\n\n\n\ncolliderName\n - String containing name for new collider type.\n\n\n\n\n\nlocal myCC = ssk.cc.newCalculator()\n\nmyCC:addName( \nblock\n )\n\nmyCC:addName( \nredBall\n )\n\nmyCC:addName( \ngreenBall\n )\n\n\n\n\n\naddNames\n\n\nSame as \naddNames\n, but takes multiple strings in one call.\n\n\nmyCC:addNames( ... )\n\n\n\n\n\n\n...\n - One or more strings containing name for new collider type.\n\n\n\n\n\nlocal myCC = ssk.cc.newCalculator()\n\nmyCC:addNames( \nblock\n, \nredBall\n, \ngreenBall\n )\n\n\n\n\n\ncollidesWith\n\n\nAutomatically configure named collider A to collide with one or more other named colliders. \n\n\nReturns true if named type was successfully added to known colliders list, false otherwise.\n\n\nmyCC:collidesWith( colliderNameA, ... )\n\n\n\n\n\n\ncolliderNameA\n - A string containing the name of the collider that is being configured.\n\n\n...\n - One or more strings identifying previously added collider types that collide with colliderNameA.\n\n\n\n\n\nlocal myCC = ssk.cc.newCalculator()\n\n-- 'redBall' collides with 'block' and 'greenBall'\n myCC:collidesWith( \nredBall\n, { \nblock\n, \ngreenBall\n } )\n\n\n\n\n\ngetCollisionFilter\n\n\nGet collision filter for the named collider.\n\n\nmyCC:getCollisionFilter( colliderName )\n\n\n\n\n\n\ncolliderName\n - A string containing the name of the collider you want the CollisionFilter for.\n\n\n\n\n-- Create an Object with a Collision Body (Get Filter)\n\nlocal tmp = display.newCircle( 100, 100, 10 )\n\ntmp:setFillColor( 1, 0, 0 )\n\nphysics.addBody( tmp, \ndynamic\n, { radius = 10, filter = myCC:getCollisionFilter( \nredBall\n ) } )\n\n\n\n\n\n\ngetCategoryBits\n\n\nGet category bits for the named collider.\n\n\nNote:\n Rarely used.  Use the \ngetCollisionFilter()\n function instead.\n\n\nmyCC:getCategoryBits( colliderName )\n\n\n\n\n\n\ncolliderName\n - A string containing the name of the collider you want the CategoryBits for.\n\n\n\n\n\nlocal myCC = ssk.cc.newCalculator()\n\nmyCC:getCategoryBits()\n\n\n\n\n\ngetMaskBits\n\n\nGet mask bits for the named collider.\n\n\nNote:\n Rarely used.  Use the \ngetCollisionFilter()\n function instead.\n\n\nmyCC:getMaskBits( colliderName )\n\n\n\n\n\n\ncolliderName\n - A string containing the name of the collider you want the MaskBits for.\n\n\n\n\n\nlocal myCC = ssk.cc.newCalculator()\n\nmyCC:getMaskBits()\n\n\n\n\n\ndump\n\n\n(Debug Feature) Prints collider names, numbers, category bits, and masks.\n\n\n\nlocal myCC = ssk.cc.newCalculator()\n\nmyCC:addNames( \nblock\n, \nredBall\n, \ngreenBall\n )\n\nmyCC:collidesWith( \nredBall\n, { \nblock\n, \ngreenBall\n } )\n\nmyCC:dump()\n\n\n\n\n\nPrints: \n\n\n*********************************************\nDumping collision settings...\n          name | num | cat bits | col mask\n-------------- | --- | -------- | --------\nredBall        |  2  |  2       |  5\nblock          |  1  |  1       |  2\ngreenBall      |  3  |  4       |  2\n\n*********************************************\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.cc.*"
        }, 
        {
            "location": "/libraries/cc/#collision-calculator-sskcc", 
            "text": "The  Collision Calculator  allows you to quickly and easily configure single-body collisions rules using names instead of numbers.", 
            "title": "Collision Calculator (ssk.cc.*)"
        }, 
        {
            "location": "/libraries/cc/#creating-a-calculator", 
            "text": "Creating a new myCC is as easy as:  local myCC = ssk.cc.newCalculator()", 
            "title": "Creating a Calculator"
        }, 
        {
            "location": "/libraries/cc/#calculator-methods-mycc", 
            "text": "addName  addNames  collidesWith    getCategoryBits  getMaskBits  getCollisionFilter    dump", 
            "title": "Calculator Methods (myCC:*)"
        }, 
        {
            "location": "/libraries/cc/#addname", 
            "text": "Add new 'named' collider type to known list of collider types, and automatically assign a number to this collider type (16 Max).  myCC:addName( colliderName )   colliderName  - String containing name for new collider type.   \nlocal myCC = ssk.cc.newCalculator()\n\nmyCC:addName(  block  )\n\nmyCC:addName(  redBall  )\n\nmyCC:addName(  greenBall  )", 
            "title": "addName"
        }, 
        {
            "location": "/libraries/cc/#addnames", 
            "text": "Same as  addNames , but takes multiple strings in one call.  myCC:addNames( ... )   ...  - One or more strings containing name for new collider type.   \nlocal myCC = ssk.cc.newCalculator()\n\nmyCC:addNames(  block ,  redBall ,  greenBall  )", 
            "title": "addNames"
        }, 
        {
            "location": "/libraries/cc/#collideswith", 
            "text": "Automatically configure named collider A to collide with one or more other named colliders.   Returns true if named type was successfully added to known colliders list, false otherwise.  myCC:collidesWith( colliderNameA, ... )   colliderNameA  - A string containing the name of the collider that is being configured.  ...  - One or more strings identifying previously added collider types that collide with colliderNameA.   \nlocal myCC = ssk.cc.newCalculator()\n\n-- 'redBall' collides with 'block' and 'greenBall'\n myCC:collidesWith(  redBall , {  block ,  greenBall  } )", 
            "title": "collidesWith"
        }, 
        {
            "location": "/libraries/cc/#getcollisionfilter", 
            "text": "Get collision filter for the named collider.  myCC:getCollisionFilter( colliderName )   colliderName  - A string containing the name of the collider you want the CollisionFilter for.   -- Create an Object with a Collision Body (Get Filter)\n\nlocal tmp = display.newCircle( 100, 100, 10 )\n\ntmp:setFillColor( 1, 0, 0 )\n\nphysics.addBody( tmp,  dynamic , { radius = 10, filter = myCC:getCollisionFilter(  redBall  ) } )", 
            "title": "getCollisionFilter"
        }, 
        {
            "location": "/libraries/cc/#getcategorybits", 
            "text": "Get category bits for the named collider.  Note:  Rarely used.  Use the  getCollisionFilter()  function instead.  myCC:getCategoryBits( colliderName )   colliderName  - A string containing the name of the collider you want the CategoryBits for.   \nlocal myCC = ssk.cc.newCalculator()\n\nmyCC:getCategoryBits()", 
            "title": "getCategoryBits"
        }, 
        {
            "location": "/libraries/cc/#getmaskbits", 
            "text": "Get mask bits for the named collider.  Note:  Rarely used.  Use the  getCollisionFilter()  function instead.  myCC:getMaskBits( colliderName )   colliderName  - A string containing the name of the collider you want the MaskBits for.   \nlocal myCC = ssk.cc.newCalculator()\n\nmyCC:getMaskBits()", 
            "title": "getMaskBits"
        }, 
        {
            "location": "/libraries/cc/#dump", 
            "text": "(Debug Feature) Prints collider names, numbers, category bits, and masks.  \nlocal myCC = ssk.cc.newCalculator()\n\nmyCC:addNames(  block ,  redBall ,  greenBall  )\n\nmyCC:collidesWith(  redBall , {  block ,  greenBall  } )\n\nmyCC:dump()  Prints:   *********************************************\nDumping collision settings...\n          name | num | cat bits | col mask\n-------------- | --- | -------- | --------\nredBall        |  2  |  2       |  5\nblock          |  1  |  1       |  2\ngreenBall      |  3  |  4       |  2\n\n*********************************************     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "dump"
        }, 
        {
            "location": "/libraries/easy_inputs/", 
            "text": "Easy Inputs (ssk.easyInputs.*)\n\n\nThis library provides a number of \nfactories\n that create easy input object \ninstances\n.  These objects dispatch Runtime events when touched.  To use these events you simply add \nlisteners\n to any part of your code that cares about the input.\n\n\n(\nImages below have \ndebugEn == true\n.  Normally, the touch areas are invisible.\n)\n\n\n\n\n\n\n\n\nOne Touch\n\n\nTwo Touch\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOne Touch\n - The entire screen is a button.\n\n\nTwo Touch\n -  The screen is split down the middle and each half (left \n right) is treated as a button.\n\n\n\n\n\n\n\n\n\n\nOne Stick\n\n\nTwo Stick\n\n\nOne Stick + One Touch\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOne Stick\n - A single virtual joystick is created anywhere you touch the screen and tracks your finger till you lift it. \n\n\nTwo Stick\n - The screen is split in half horizontally, each side (left \n right) hosting a virtual joystick. \n\n\nOne Stick + One Touch\n -  One side of the screen is a button, one side hosts a virtual joystick. \n\n\n\n\nNote:\n Each of the three 'stick' factories uses the '\nJoystick Factory\n' to build the virtual joystick(s).\n\n\nEasy Input Factories\n\n\noneTouch\n\n\nThe entire screen is a button.\n\n\nssk.easyInputs.oneTouch.create( [ group [ , params ]] )\n\n\n\n\n\n\ngroup\n (\ndisplay.currentStage\n) - Display group to put input display object(s) into.\n\n\nparams\n - Parameters used to configure the input object(s).\n\n\ndebugEn\n (\nfalse\n) - Enable visual feedback to show input instance is working.\n\n\nfill\n (\n{1,0,0}\n) - Fill color to use for 'touch area'.\n\n\nalpha\n (\n0\n) - Alpha to use for touch area.  \n\n\nIf \ndebugEn\n is \ntrue\n this defaults to \n0.25\n.\n\n\n\n\n\n\neventName\n (\nonOneTouch\n) - Touching the 'touch area' \nposts\n (dispatches) a Runtime event with this name.\n\n\nSee '\nEasy Input Listeners\n' below to learn about writing listeners.\n\n\n\n\n\n\nkeyboardEn\n (\nfalse\n) - If this is \ntrue\n, you can use the keyboard while on the simulator to dispatch events.\n\n\nw\n and \nup\n (arrow) both \npost\n \neventName\n.\n\n\n\n\n\n\nappleTVEn\n (\nfalse\n) - This special setting lets you use the same input object on AppleTV.\n\n\nNote:\n Pressing \nbuttonZ\n on the Apple TV remote/controller \nposts\n \neventName\n.\n\n\n\n\n\n\n\n\n\n\n\n\n\nssk.easyInputs.oneTouch.create( group, { debugEn = true, keyboardEn = true } )\n\n\n\n\n\ntwoTouch\n\n\nThe screen is split down the middle and each half (left \n right) is treated as a button.\n\n\nssk.easyInputs.twoTouch.create( [ group [ , params ]] )\n\n\n\n\n\n\ngroup\n (\ndisplay.currentStage\n) - Display group to put input display object(s) into.\n\n\nparams\n - Parameters used to configure the input object(s).\n\n\ndebugEn\n (\nfalse\n) - Enable visual feedback to show input instance is working.\n\n\nleftFill\n (\n{0,0,1}\n) - Fill color to use for left 'touch area'.\n\n\nrightFill\n (\n{1,0,0}\n) - Fill color to use for right 'touch area'.\n\n\nalpha\n (\n0\n) - Alpha to use for left \n right touch area.  \n\n\nIf \ndebugEn\n is \ntrue\n this defaults to \n0.25\n.\n\n\n\n\n\n\nleftEventName\n (\nonTwoTouchLeft\n) - Touching the left 'touch area' \nposts\n (dispatches) a Runtime event with this name.\n\n\nrightEventName\n (\nonTwoTouchRight\n) - Touching the right 'touch area' \nposts\n (dispatches) a Runtime event with this name.\n\n\nSee '\nEasy Input Listeners\n' below to learn about writing listeners. \n\n\n\n\n\n\nkeyboardEn\n (\nfalse\n) - If this is \ntrue\n, you can use the keyboard while on the simulator to dispatch events.\n\n\na\n and \nleft\n (arrow) both \npost\n \nleftEventName\n.\n\n\nd\n and \nright\n (arrow) both \npost\n \nrightEventName\n.\n\n\n\n\n\n\n\n\n\n\n\n\n\nssk.easyInputs.twoTouch.create( group, { debugEn = true, keyboardEn = true } )\n\n\n\n\n\noneStick\n\n\nA single virtual joystick is created anywhere you touch the screen and tracks your finger till you lift it. \n\n\nssk.easyInputs.oneStick.create( [ group [ , params ]] )\n\n\n\n\n\n\ngroup\n (\ndisplay.currentStage\n) - Display group to put input display object(s) into.\n\n\nparams\n - Parameters used to configure the input object(s).\n\n\ngroup\n (\ndisplay.currentStage\n) - Display group to put input display object(s) into.\n\n\nparams\n - Parameters used to configure the input object(s).\n\n\ndebugEn\n (\nfalse\n) - Enable visual feedback to show input instance is working.\n\n\nfill\n (\n{1,0,0}\n) - Fill color to use for 'touch area'.\n\n\nalpha\n (\n0\n) - Alpha to use for touch area.  \n\n\nIf \ndebugEn\n is \ntrue\n this defaults to \n0.25\n.\n\n\n\n\n\n\neventName\n (\nonJoystick\n) - Touching the 'touch area' \nposts\n (dispatches) a Runtime event with this name.\n\n\nSee '\nEasy Input Listeners\n' below to learn about writing listeners.\n\n\n\n\n\n\njoyParams\n (\n{}\n) - A table that is passed to the joystick helper to build joystick.\n\n\nSee '\nJoystick Factory\n' below for more details on this table.\n\n\n\n\n\n\n\n\n\n\n\n\n\nssk.easyInputs.oneStick.create( group, { debugEn = true, joyParams = { doNorm = true } } )\n\n\n\n\n\ntwoStick\n\n\nThe screen is split in half horizontally, each side (left \n right) hosting a virtual joystick. \n\n\nssk.easyInputs.twoStick.create( [ group [ , params ]] )\n\n\n\n\n\n\ngroup\n (\ndisplay.currentStage\n) - Display group to put input display object(s) into.\n\n\nparams\n - Parameters used to configure the input object(s).\n\n\ndebugEn\n (\nfalse\n) - Enable visual feedback to show input instance is working.\n\n\nleftFill\n (\n{0,0,1}\n) - Fill color to use for left 'touch area'.\n\n\nrightFill\n (\n{1,0,0}\n) - Fill color to use for right 'touch area'.\n\n\nalpha\n (\n0\n) - Alpha to use for left \n right touch area.  \n\n\nIf \ndebugEn\n is \ntrue\n this defaults to \n0.25\n.\n\n\n\n\n\n\nleftEventName\n (\nonLeftJoystick\n) - Touching the left 'touch area' \nposts\n (dispatches) a Runtime event with this name.\n\n\nrightEventName\n (\nonRightJoystick\n) - Touching the right 'touch area' \nposts\n (dispatches) a Runtime event with this name.\n\n\nSee '\nEasy Input Listeners\n' below to learn about writing listeners. \n\n\n\n\n\n\nkeyboardEn\n (\nfalse\n) - If this is \ntrue\n, you can use the keyboard while on the simulator to dispatch events.\n\n\na\n and \nleft\n (arrow) both \npost\n \nleftEventName\n.\n\n\nd\n and \nright\n (arrow) both \npost\n \nrightEventName\n.\n\n\n\n\n\n\nleftJoyParams\n (\n{}\n) - A table that is passed to the joystick helper to build joystick.\n\n\nrightJoyParams\n (\n{}\n) - A table that is passed to the joystick helper to build joystick.\n\n\nSee '\nJoystick Factory\n' below for more details on the joystick parameter tables.\n\n\n\n\n\n\n\n\n\n\n\n\n\nssk.easyInputs.twoStick.create( group, { debugEn = true, joyParams = { doNorm = true } } )\n\n\n\n\n\noneStickOneTouch\n\n\nOne side of the screen is a button, one side hosts a virtual joystick.  \n\n\nBy default, the left-side is the joystick and the right is the button, but this can be swapped.\n\n\nssk.easyInputs.oneStickOneTouch.create( [ group [ , params ]] )\n\n\n\n\n\n\ngroup\n (\ndisplay.currentStage\n) - Display group to put input display object(s) into.\n\n\nparams\n - Parameters used to configure the input object(s).\n\n\ndebugEn\n (\nfalse\n) - Enable visual feedback to show input instance is working.\n\n\nleftFill\n (\n{0,0,1}\n) - Fill color to use for left 'touch area'.\n\n\nrightFill\n (\n{1,0,0}\n) - Fill color to use for right 'touch area'.\n\n\nalpha\n (\n0\n) - Alpha to use for left \n right touch area.  \n\n\nIf \ndebugEn\n is \ntrue\n this defaults to \n0.25\n.\n\n\n\n\n\n\nstickOnRight\n (\nfalse\n) - If \ntrue\n the virtual joystick will be on the right and the button on the left.\n\n\ntouchEventName\n (\nonOneTouch\n) - Touching the left 'touch area' \nposts\n (dispatches) a Runtime event with this name.\n\n\nstickEventName\n (\nonJoystick\n) - Touching the right 'touch area' \nposts\n (dispatches) a Runtime event with this name.\n\n\nSee '\nEasy Input Listeners\n' below to learn about writing listeners. \n\n\n\n\n\n\nkeyboardEn\n (\nfalse\n) - If this is \ntrue\n, you can use the keyboard while on the simulator to dispatch the button events.\n\n\nw\n and \nup\n (arrow) both \npost\n \ntouchEventName\n.\n\n\n\n\n\n\njoyParams\n (\n{}\n) - A table that is passed to the joystick helper to build joystick.\n\n\nSee '\nJoystick Factory\n' below for more details on this table.\n\n\n\n\n\n\n\n\n\n\n\n\n\nssk.easyInputs.oneStickOneTouch.create( group, { debugEn = true, joyParams = { doNorm = true } } )\n\n\n\n\n\nJoystick Factory\n\n\nThis factory produces a 'virtual' fixed- or floating- joystick.  The prior stays in place, while the latter moves to the beginning of the touch event that triggered it.\n\n\nVirtual joysticks dispatch a Runtime event that can be listened for anywhere and by any object(s).  See '\nEasy Input Listeners\n' below to learn more about this.\n\n\nssk.easyInputs.joystick.create( group, x, y, joyParams  )\n\n\n\n\n\n\ngroup\n (\ndisplay.currentStage\n) - Display group to put input display object(s) into.\n\n\nx\n, \ny\n - \n x, y \n position to initially place joystick at.\n\n\n\n\njoyParams\n (\n{}\n) - A table of parameters defining how this virtual joystick looks and behaves.\n\n\n\n\nouterRadius\n (\n60\n) - Radius of entire virtual joystick touch area.\n\n\nouterImg\n (\nnil\n) - Optional image to use for this part of the virtual joystick.\n\n\nouterFill\n (\n{1,1,1,0}\n) - Fill color.\n\n\nouterStrokeColor\n (\n{0.25,0.25,0.25,1}\n) - Stroke color.\n\n\nouterStrokeWidth\n (\n4\n) - Stroke width.\n\n\nouterAlpha\n (\n1\n) - Alpha.  \n\n\nparams.alpha\n - Can be used to set this too.\n\n\n\n\n\n\nstickRadius\n (\nouterRadius/2\n) - Radius of the stick/thumb part of the virtual joystick touch area.\n\n\nstickImg\n (\nnil\n) - Optional image to use for this part of the virtual joystick.\n\n\nstickFill\n (\n{1,1,1,0}\n) - Fill color.\n\n\nstickStrokeColor\n (\n{0.25,0.25,0.25,1}\n) - Stroke color.\n\n\nstickStrokeWidth\n (\n4\n) - Stroke width.\n\n\nstickAlpha\n (\n1\n) - Alpha.  \n\n\nparams.alpha\n - Can be used to set this too.\n\n\n\n\n\n\nouterRadius\n (\nouterRadius/2\n) - Radius of dead zone.\n\n    Touches within this space are registered, but given the event \nstate\n of `off.\n\n\ndeadZoneImg\n (\nnil\n) - Optional image to use for this part of the virtual joystick.\n\n\ndeadZoneFill\n (\n{1,1,1,0}\n) - Fill color.\n\n\ndeadZoneStrokeColor\n (\n{0.25,0.25,0.25,1}\n) - Stroke color.\n\n\ndeadZoneStrokeWidth\n (\n4\n) - Stroke width.\n\n\n\n\ndeadZoneAlpha\n (\n1\n) - Alpha.  \n\n\n\n\nparams.alpha\n - Can be used to set this too.\n\n\n\n\n\n\n\n\neventName\n (\nonJoystick\n) - The virtual joystick \nposts\n (dispatches) a Runtime event with this name when it is used.\n\n\n\n\ninputObj\n (\nnil\n) - Object to use as touch proxy for joystick.\n\n\nIf this object \nIS NOT PROVIDED\n, the joystick is stationary and acts as its own touch catching object.\n\n\nIf this object \nIS PROVIDED\n the virtual joystick \nfloats\n.  That is, it moves to wherever the touch 'begins', then stays in place till the touch ends.\n\n\n\n\n\n\ninUseAlpha\n (\n1\n) - The alpha property of the virtual joystick rises to this value when you activate it.\n\n\nnotInUseAlpha\n (\n0\n) - This is the alpha for the virtual joystick when it is not inuse.\n\n\nuseAlphaFadeTime\n (\n0\n) - This controls how long alpha in-use/not-in-use changes take to complete.\n\n\ndoNorm\n (\nfalse\n) - By default, the virtual joystick does not include the normalized vector representation of the joystick pointing vector.  However, if you need this, you can set this property to \ntrue\n.  \n\n\nIf this is \ntrue\n, the virtual joystick event will include two fields, \nnx\n and \nny\n which are the normalized versions of \nvx\n and \nvy\n respectively.\n\n\n\n\n\n\n\n\n\n\n\n\n\njoystick.create( nil, left + 30, bottom - 30 )\n\n\n\n\n\nEasy Input Instances\n\n\nOne Touch Instance\n\n\nThe 'One Touch Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime event.  This event can the be listed for for anywhere and by any object(s).\n\n\nAdditionally, this 'instance' has these methods:\n\n\n\n\ndestroy()\n - Destroys and cleans up the object listeners entirely.\n\n\nsleep()\n - Temorarily ignore inputs.\n\n\nwake()\n - Resume listenting for inputs.\n\n\ngetPressed()\n - Returns \ntrue\n if the instance is currently being 'touched'.\n\n\nfinalize()\n - The factory adds its own '\nfinalize\n' method, so don't add one yourself.\n\n\n\n\nTwo Touch Instance\n\n\nThe 'Two Touch Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime events.  These events can the be listed for for anywhere and by any object(s).\n\n\nAdditionally, this 'instance' has these methods:\n\n\n\n\ndestroy()\n - Destroys and cleans up the object listeners entirely.\n\n\nsleep()\n - Temorarily ignore inputs.\n\n\nwake()\n - Resume listenting for inputs.\n\n\nfinalize()\n - The factory adds its own '\nfinalize\n' method, so don't add one yourself.\n\n\n\n\nOne Stick Instance\n\n\nThe 'One Stick Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime event.  This event can the be listed for for anywhere and by any object(s).\n\n\nAdditionally, this 'instance' has this methods:\n\n\n\n\ndestroy()\n - Destroys and cleans up the object listeners entirely.\n\n\n\n\nTwo Stick Instance\n\n\nThe 'Two Stick Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime events.  These events can the be listed for for anywhere and by any object(s).\n\n\nAdditionally, this 'instance' has this methods:\n\n\n\n\ndestroy()\n - Destroys and cleans up the object listeners entirely.\n\n\n\n\nOne Stick + One Touch Instance\n\n\nThe 'One Stick + One Touch Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime events.  These events can the be listed for for anywhere and by any object(s).\n\n\nAdditionally, this 'instance' has these methods:\n\n\n\n\ndestroy()\n - Destroys and cleans up the object listeners entirely.\n\n\nsleep()\n - Temorarily ignore inputs.\n\n\nwake()\n - Resume listenting for inputs.\n\n\ngetPressed()\n - Returns \ntrue\n if the button side of the instance is currently being 'touched'.\n\n\nfinalize()\n - The factory adds its own '\nfinalize\n' method, so don't add one yourself.\n\n\n\n\nJoystick Instance\n\n\nThe 'Joystick Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime events.  These events can the be listed for for anywhere and by any object(s).\n\n\nIt has no special methods attached to it.\n\n\nEasy Input Listeners\n\n\nOne Touch Listeners\n\n\nOne Touch objects produce a custom Runtime event with all the same properties as the standard Corona SDK \ntouch event\n.\n\n\nException:\n The \nname\n field has been changed from \n\"touch\"\n to whatever custom event name the instance is using (Ex: \n\"onOneTouch\"\n).\n\n\n\n-- One Touch Function Listener\n\nssk.easyInputs.oneTouch.create( group )\n\nlocal function onOneTouch( event )\n\n   table.dump( event )\n\nend; listen( \nonOneTouch\n, onOneTouch )\n\n\n\n\n\n\n-- One Touch Table Listener\n\nssk.easyInputs.oneTouch.create( group )\n\nlocal player = newImagRect( group, centerX, centerY, \nimages/player.png\n)\n\nfunction player.onOneTouch( self, event )\n\n   table.dump( event )\n\nend; listen( \nonOneTouch\n, player )\n\n\n\n\n\nTwo Touch Listeners\n\n\nTwo Touch objects produce a custom Runtime event with all the same properties as the standard Corona SDK \ntouch event\n.\n\n\nException:\n The \nname\n field has been changed from \n\"touch\"\n to whatever custom event name the instance is using (Ex: \n\"onTwoTouchLeft\"\n or \n\"onTwoTouchRight\"\n ).\n\n\n\n-- Two Touch Function Listener\n\nssk.easyInputs.twoTouch.create( group )\n\nlocal function onTwoTouchLeft( event )\n\n   table.dump( event )\n\nend; listen( \nonTwoTouchLeft\n, onTwoTouchLeft )\n\nlocal function onTwoTouchRight( event )\n\n   table.dump( event )\n\nend; listen( \nonTwoTouchRight\n, onTwoTouchRight )\n\n\n\n\n\n\n\n-- Two Touch Table Listener\n\nssk.easyInputs.twoTouch.create( group )\n\nlocal player = newImagRect( group, centerX, centerY, \nimages/player.png\n)\n\nfunction player.onTwoTouchLeft( self, event )\n\n   table.dump( event )\n\nend; listen( \nonTwoTouchLeft\n, player )\n\nfunction player.onTwoTouchRight( self, event )\n\n   table.dump( event )\n\nend; listen( \nonTwoTouchRight\n, player )\n\n\n\n\n\nOne Stick + One Touch Listeners\n\n\n'One Stick + One Touch' objects need both a \nOne Touch Listener\n and a \nOne Stick Listener\n.\n\n\nOne Stick Listeners\n\n\nTwo Stick Listeners\n\n\nThe 'One' and 'Two' stick listeners both produce virtual joystick events.\n\n\nVirtual Joystick Listeners\n\n\nVirtual joysticks produce a custom Runtime event that includes these properties:\n\n\n\n\nangle\n - Angle the stick is pointed in, where 0 is up, 90 is right, etc.\n\n\nvx\n, \nvy\n - Vector x- and y- representations of \nangle\n, where length of vector is a function of how far the 'stick' is from the center of the virtual joystick.\n\n\nnx\n, \nny\n - Normalized version of \nvx\n and \nvy\n respecrtively.\n\n\nONLY IF:\n doNorm was set to \ntrue\n when creating the virtual joystick.\n\n\n\n\n\n\npercent\n - A value between 0 and 100 representing how far along the total stick movement distance the stick has moved away from the center of the virtual joystick.\n\n\nphase\n - \"began\", \"moved,\", or \"ended\".\n\n\nstate\n - '\"OFF\"' or '\"ON\"', depending on whether the stick is in our out of the 'dead zone' respectively.\n\n\ntime\n - Simulation time of the event.\n\n\n\n\n\n-- Two Touch Function Listener\n\nssk.easyInputs.oneStick.create( group )\n\nlocal function onJoystick( event )\n\n   table.dump( event )\n\nend; listen( \nonJoystick\n, onJoystick )\n\n\n\n\n\n\n\n-- Two Touch Table Listener\n\nssk.easyInputs.oneStick.create( group )\n\nlocal player = newImagRect( group, centerX, centerY, \nimages/player.png\n)\n\nfunction player.onJoystick( self, event )\n\n   table.dump( event )\n\nend; listen( \nonJoystick\n, player )\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.easyInputs.*"
        }, 
        {
            "location": "/libraries/easy_inputs/#easy-inputs-sskeasyinputs", 
            "text": "This library provides a number of  factories  that create easy input object  instances .  These objects dispatch Runtime events when touched.  To use these events you simply add  listeners  to any part of your code that cares about the input.  ( Images below have  debugEn == true .  Normally, the touch areas are invisible. )     One Touch  Two Touch            One Touch  - The entire screen is a button.  Two Touch  -  The screen is split down the middle and each half (left   right) is treated as a button.      One Stick  Two Stick  One Stick + One Touch             One Stick  - A single virtual joystick is created anywhere you touch the screen and tracks your finger till you lift it.   Two Stick  - The screen is split in half horizontally, each side (left   right) hosting a virtual joystick.   One Stick + One Touch  -  One side of the screen is a button, one side hosts a virtual joystick.    Note:  Each of the three 'stick' factories uses the ' Joystick Factory ' to build the virtual joystick(s).", 
            "title": "Easy Inputs (ssk.easyInputs.*)"
        }, 
        {
            "location": "/libraries/easy_inputs/#easy-input-factories", 
            "text": "", 
            "title": "Easy Input Factories"
        }, 
        {
            "location": "/libraries/easy_inputs/#onetouch", 
            "text": "The entire screen is a button.  ssk.easyInputs.oneTouch.create( [ group [ , params ]] )   group  ( display.currentStage ) - Display group to put input display object(s) into.  params  - Parameters used to configure the input object(s).  debugEn  ( false ) - Enable visual feedback to show input instance is working.  fill  ( {1,0,0} ) - Fill color to use for 'touch area'.  alpha  ( 0 ) - Alpha to use for touch area.    If  debugEn  is  true  this defaults to  0.25 .    eventName  ( onOneTouch ) - Touching the 'touch area'  posts  (dispatches) a Runtime event with this name.  See ' Easy Input Listeners ' below to learn about writing listeners.    keyboardEn  ( false ) - If this is  true , you can use the keyboard while on the simulator to dispatch events.  w  and  up  (arrow) both  post   eventName .    appleTVEn  ( false ) - This special setting lets you use the same input object on AppleTV.  Note:  Pressing  buttonZ  on the Apple TV remote/controller  posts   eventName .       \nssk.easyInputs.oneTouch.create( group, { debugEn = true, keyboardEn = true } )", 
            "title": "oneTouch"
        }, 
        {
            "location": "/libraries/easy_inputs/#twotouch", 
            "text": "The screen is split down the middle and each half (left   right) is treated as a button.  ssk.easyInputs.twoTouch.create( [ group [ , params ]] )   group  ( display.currentStage ) - Display group to put input display object(s) into.  params  - Parameters used to configure the input object(s).  debugEn  ( false ) - Enable visual feedback to show input instance is working.  leftFill  ( {0,0,1} ) - Fill color to use for left 'touch area'.  rightFill  ( {1,0,0} ) - Fill color to use for right 'touch area'.  alpha  ( 0 ) - Alpha to use for left   right touch area.    If  debugEn  is  true  this defaults to  0.25 .    leftEventName  ( onTwoTouchLeft ) - Touching the left 'touch area'  posts  (dispatches) a Runtime event with this name.  rightEventName  ( onTwoTouchRight ) - Touching the right 'touch area'  posts  (dispatches) a Runtime event with this name.  See ' Easy Input Listeners ' below to learn about writing listeners.     keyboardEn  ( false ) - If this is  true , you can use the keyboard while on the simulator to dispatch events.  a  and  left  (arrow) both  post   leftEventName .  d  and  right  (arrow) both  post   rightEventName .       \nssk.easyInputs.twoTouch.create( group, { debugEn = true, keyboardEn = true } )", 
            "title": "twoTouch"
        }, 
        {
            "location": "/libraries/easy_inputs/#onestick", 
            "text": "A single virtual joystick is created anywhere you touch the screen and tracks your finger till you lift it.   ssk.easyInputs.oneStick.create( [ group [ , params ]] )   group  ( display.currentStage ) - Display group to put input display object(s) into.  params  - Parameters used to configure the input object(s).  group  ( display.currentStage ) - Display group to put input display object(s) into.  params  - Parameters used to configure the input object(s).  debugEn  ( false ) - Enable visual feedback to show input instance is working.  fill  ( {1,0,0} ) - Fill color to use for 'touch area'.  alpha  ( 0 ) - Alpha to use for touch area.    If  debugEn  is  true  this defaults to  0.25 .    eventName  ( onJoystick ) - Touching the 'touch area'  posts  (dispatches) a Runtime event with this name.  See ' Easy Input Listeners ' below to learn about writing listeners.    joyParams  ( {} ) - A table that is passed to the joystick helper to build joystick.  See ' Joystick Factory ' below for more details on this table.       \nssk.easyInputs.oneStick.create( group, { debugEn = true, joyParams = { doNorm = true } } )", 
            "title": "oneStick"
        }, 
        {
            "location": "/libraries/easy_inputs/#twostick", 
            "text": "The screen is split in half horizontally, each side (left   right) hosting a virtual joystick.   ssk.easyInputs.twoStick.create( [ group [ , params ]] )   group  ( display.currentStage ) - Display group to put input display object(s) into.  params  - Parameters used to configure the input object(s).  debugEn  ( false ) - Enable visual feedback to show input instance is working.  leftFill  ( {0,0,1} ) - Fill color to use for left 'touch area'.  rightFill  ( {1,0,0} ) - Fill color to use for right 'touch area'.  alpha  ( 0 ) - Alpha to use for left   right touch area.    If  debugEn  is  true  this defaults to  0.25 .    leftEventName  ( onLeftJoystick ) - Touching the left 'touch area'  posts  (dispatches) a Runtime event with this name.  rightEventName  ( onRightJoystick ) - Touching the right 'touch area'  posts  (dispatches) a Runtime event with this name.  See ' Easy Input Listeners ' below to learn about writing listeners.     keyboardEn  ( false ) - If this is  true , you can use the keyboard while on the simulator to dispatch events.  a  and  left  (arrow) both  post   leftEventName .  d  and  right  (arrow) both  post   rightEventName .    leftJoyParams  ( {} ) - A table that is passed to the joystick helper to build joystick.  rightJoyParams  ( {} ) - A table that is passed to the joystick helper to build joystick.  See ' Joystick Factory ' below for more details on the joystick parameter tables.       \nssk.easyInputs.twoStick.create( group, { debugEn = true, joyParams = { doNorm = true } } )", 
            "title": "twoStick"
        }, 
        {
            "location": "/libraries/easy_inputs/#onestickonetouch", 
            "text": "One side of the screen is a button, one side hosts a virtual joystick.    By default, the left-side is the joystick and the right is the button, but this can be swapped.  ssk.easyInputs.oneStickOneTouch.create( [ group [ , params ]] )   group  ( display.currentStage ) - Display group to put input display object(s) into.  params  - Parameters used to configure the input object(s).  debugEn  ( false ) - Enable visual feedback to show input instance is working.  leftFill  ( {0,0,1} ) - Fill color to use for left 'touch area'.  rightFill  ( {1,0,0} ) - Fill color to use for right 'touch area'.  alpha  ( 0 ) - Alpha to use for left   right touch area.    If  debugEn  is  true  this defaults to  0.25 .    stickOnRight  ( false ) - If  true  the virtual joystick will be on the right and the button on the left.  touchEventName  ( onOneTouch ) - Touching the left 'touch area'  posts  (dispatches) a Runtime event with this name.  stickEventName  ( onJoystick ) - Touching the right 'touch area'  posts  (dispatches) a Runtime event with this name.  See ' Easy Input Listeners ' below to learn about writing listeners.     keyboardEn  ( false ) - If this is  true , you can use the keyboard while on the simulator to dispatch the button events.  w  and  up  (arrow) both  post   touchEventName .    joyParams  ( {} ) - A table that is passed to the joystick helper to build joystick.  See ' Joystick Factory ' below for more details on this table.       \nssk.easyInputs.oneStickOneTouch.create( group, { debugEn = true, joyParams = { doNorm = true } } )", 
            "title": "oneStickOneTouch"
        }, 
        {
            "location": "/libraries/easy_inputs/#joystick-factory", 
            "text": "This factory produces a 'virtual' fixed- or floating- joystick.  The prior stays in place, while the latter moves to the beginning of the touch event that triggered it.  Virtual joysticks dispatch a Runtime event that can be listened for anywhere and by any object(s).  See ' Easy Input Listeners ' below to learn more about this.  ssk.easyInputs.joystick.create( group, x, y, joyParams  )   group  ( display.currentStage ) - Display group to put input display object(s) into.  x ,  y  -   x, y   position to initially place joystick at.   joyParams  ( {} ) - A table of parameters defining how this virtual joystick looks and behaves.   outerRadius  ( 60 ) - Radius of entire virtual joystick touch area.  outerImg  ( nil ) - Optional image to use for this part of the virtual joystick.  outerFill  ( {1,1,1,0} ) - Fill color.  outerStrokeColor  ( {0.25,0.25,0.25,1} ) - Stroke color.  outerStrokeWidth  ( 4 ) - Stroke width.  outerAlpha  ( 1 ) - Alpha.    params.alpha  - Can be used to set this too.    stickRadius  ( outerRadius/2 ) - Radius of the stick/thumb part of the virtual joystick touch area.  stickImg  ( nil ) - Optional image to use for this part of the virtual joystick.  stickFill  ( {1,1,1,0} ) - Fill color.  stickStrokeColor  ( {0.25,0.25,0.25,1} ) - Stroke color.  stickStrokeWidth  ( 4 ) - Stroke width.  stickAlpha  ( 1 ) - Alpha.    params.alpha  - Can be used to set this too.    outerRadius  ( outerRadius/2 ) - Radius of dead zone. \n    Touches within this space are registered, but given the event  state  of `off.  deadZoneImg  ( nil ) - Optional image to use for this part of the virtual joystick.  deadZoneFill  ( {1,1,1,0} ) - Fill color.  deadZoneStrokeColor  ( {0.25,0.25,0.25,1} ) - Stroke color.  deadZoneStrokeWidth  ( 4 ) - Stroke width.   deadZoneAlpha  ( 1 ) - Alpha.     params.alpha  - Can be used to set this too.     eventName  ( onJoystick ) - The virtual joystick  posts  (dispatches) a Runtime event with this name when it is used.   inputObj  ( nil ) - Object to use as touch proxy for joystick.  If this object  IS NOT PROVIDED , the joystick is stationary and acts as its own touch catching object.  If this object  IS PROVIDED  the virtual joystick  floats .  That is, it moves to wherever the touch 'begins', then stays in place till the touch ends.    inUseAlpha  ( 1 ) - The alpha property of the virtual joystick rises to this value when you activate it.  notInUseAlpha  ( 0 ) - This is the alpha for the virtual joystick when it is not inuse.  useAlphaFadeTime  ( 0 ) - This controls how long alpha in-use/not-in-use changes take to complete.  doNorm  ( false ) - By default, the virtual joystick does not include the normalized vector representation of the joystick pointing vector.  However, if you need this, you can set this property to  true .    If this is  true , the virtual joystick event will include two fields,  nx  and  ny  which are the normalized versions of  vx  and  vy  respectively.       \njoystick.create( nil, left + 30, bottom - 30 )", 
            "title": "Joystick Factory"
        }, 
        {
            "location": "/libraries/easy_inputs/#easy-input-instances", 
            "text": "", 
            "title": "Easy Input Instances"
        }, 
        {
            "location": "/libraries/easy_inputs/#one-touch-instance", 
            "text": "The 'One Touch Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime event.  This event can the be listed for for anywhere and by any object(s).  Additionally, this 'instance' has these methods:   destroy()  - Destroys and cleans up the object listeners entirely.  sleep()  - Temorarily ignore inputs.  wake()  - Resume listenting for inputs.  getPressed()  - Returns  true  if the instance is currently being 'touched'.  finalize()  - The factory adds its own ' finalize ' method, so don't add one yourself.", 
            "title": "One Touch Instance"
        }, 
        {
            "location": "/libraries/easy_inputs/#two-touch-instance", 
            "text": "The 'Two Touch Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime events.  These events can the be listed for for anywhere and by any object(s).  Additionally, this 'instance' has these methods:   destroy()  - Destroys and cleans up the object listeners entirely.  sleep()  - Temorarily ignore inputs.  wake()  - Resume listenting for inputs.  finalize()  - The factory adds its own ' finalize ' method, so don't add one yourself.", 
            "title": "Two Touch Instance"
        }, 
        {
            "location": "/libraries/easy_inputs/#one-stick-instance", 
            "text": "The 'One Stick Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime event.  This event can the be listed for for anywhere and by any object(s).  Additionally, this 'instance' has this methods:   destroy()  - Destroys and cleans up the object listeners entirely.", 
            "title": "One Stick Instance"
        }, 
        {
            "location": "/libraries/easy_inputs/#two-stick-instance", 
            "text": "The 'Two Stick Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime events.  These events can the be listed for for anywhere and by any object(s).  Additionally, this 'instance' has this methods:   destroy()  - Destroys and cleans up the object listeners entirely.", 
            "title": "Two Stick Instance"
        }, 
        {
            "location": "/libraries/easy_inputs/#one-stick-one-touch-instance", 
            "text": "The 'One Stick + One Touch Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime events.  These events can the be listed for for anywhere and by any object(s).  Additionally, this 'instance' has these methods:   destroy()  - Destroys and cleans up the object listeners entirely.  sleep()  - Temorarily ignore inputs.  wake()  - Resume listenting for inputs.  getPressed()  - Returns  true  if the button side of the instance is currently being 'touched'.  finalize()  - The factory adds its own ' finalize ' method, so don't add one yourself.", 
            "title": "One Stick + One Touch Instance"
        }, 
        {
            "location": "/libraries/easy_inputs/#joystick-instance", 
            "text": "The 'Joystick Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime events.  These events can the be listed for for anywhere and by any object(s).  It has no special methods attached to it.", 
            "title": "Joystick Instance"
        }, 
        {
            "location": "/libraries/easy_inputs/#easy-input-listeners", 
            "text": "", 
            "title": "Easy Input Listeners"
        }, 
        {
            "location": "/libraries/easy_inputs/#one-touch-listeners", 
            "text": "One Touch objects produce a custom Runtime event with all the same properties as the standard Corona SDK  touch event .  Exception:  The  name  field has been changed from  \"touch\"  to whatever custom event name the instance is using (Ex:  \"onOneTouch\" ).  \n-- One Touch Function Listener\n\nssk.easyInputs.oneTouch.create( group )\n\nlocal function onOneTouch( event )\n\n   table.dump( event )\n\nend; listen(  onOneTouch , onOneTouch )  \n-- One Touch Table Listener\n\nssk.easyInputs.oneTouch.create( group )\n\nlocal player = newImagRect( group, centerX, centerY,  images/player.png )\n\nfunction player.onOneTouch( self, event )\n\n   table.dump( event )\n\nend; listen(  onOneTouch , player )", 
            "title": "One Touch Listeners"
        }, 
        {
            "location": "/libraries/easy_inputs/#two-touch-listeners", 
            "text": "Two Touch objects produce a custom Runtime event with all the same properties as the standard Corona SDK  touch event .  Exception:  The  name  field has been changed from  \"touch\"  to whatever custom event name the instance is using (Ex:  \"onTwoTouchLeft\"  or  \"onTwoTouchRight\"  ).  \n-- Two Touch Function Listener\n\nssk.easyInputs.twoTouch.create( group )\n\nlocal function onTwoTouchLeft( event )\n\n   table.dump( event )\n\nend; listen(  onTwoTouchLeft , onTwoTouchLeft )\n\nlocal function onTwoTouchRight( event )\n\n   table.dump( event )\n\nend; listen(  onTwoTouchRight , onTwoTouchRight )  \n-- Two Touch Table Listener\n\nssk.easyInputs.twoTouch.create( group )\n\nlocal player = newImagRect( group, centerX, centerY,  images/player.png )\n\nfunction player.onTwoTouchLeft( self, event )\n\n   table.dump( event )\n\nend; listen(  onTwoTouchLeft , player )\n\nfunction player.onTwoTouchRight( self, event )\n\n   table.dump( event )\n\nend; listen(  onTwoTouchRight , player )", 
            "title": "Two Touch Listeners"
        }, 
        {
            "location": "/libraries/easy_inputs/#one-stick-one-touch-listeners", 
            "text": "'One Stick + One Touch' objects need both a  One Touch Listener  and a  One Stick Listener .", 
            "title": "One Stick + One Touch Listeners"
        }, 
        {
            "location": "/libraries/easy_inputs/#one-stick-listeners", 
            "text": "", 
            "title": "One Stick Listeners"
        }, 
        {
            "location": "/libraries/easy_inputs/#two-stick-listeners", 
            "text": "The 'One' and 'Two' stick listeners both produce virtual joystick events.", 
            "title": "Two Stick Listeners"
        }, 
        {
            "location": "/libraries/easy_inputs/#virtual-joystick-listeners", 
            "text": "Virtual joysticks produce a custom Runtime event that includes these properties:   angle  - Angle the stick is pointed in, where 0 is up, 90 is right, etc.  vx ,  vy  - Vector x- and y- representations of  angle , where length of vector is a function of how far the 'stick' is from the center of the virtual joystick.  nx ,  ny  - Normalized version of  vx  and  vy  respecrtively.  ONLY IF:  doNorm was set to  true  when creating the virtual joystick.    percent  - A value between 0 and 100 representing how far along the total stick movement distance the stick has moved away from the center of the virtual joystick.  phase  - \"began\", \"moved,\", or \"ended\".  state  - '\"OFF\"' or '\"ON\"', depending on whether the stick is in our out of the 'dead zone' respectively.  time  - Simulation time of the event.   \n-- Two Touch Function Listener\n\nssk.easyInputs.oneStick.create( group )\n\nlocal function onJoystick( event )\n\n   table.dump( event )\n\nend; listen(  onJoystick , onJoystick )  \n-- Two Touch Table Listener\n\nssk.easyInputs.oneStick.create( group )\n\nlocal player = newImagRect( group, centerX, centerY,  images/player.png )\n\nfunction player.onJoystick( self, event )\n\n   table.dump( event )\n\nend; listen(  onJoystick , player )     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Virtual Joystick Listeners"
        }, 
        {
            "location": "/libraries/math2D/", 
            "text": "2D Math (ssk.math2d.*)\n\n\nSSK2 comes with a complete library of fundamental 2D operations.\n\n\nAdditionally, if you own the \nMath2D Plugin\n, SSK can use that instead.\n\n\n\n-- Use Math2D Plugin if you own it!\n_G.ssk.init( { math2DPlugin = true } )\n\n\n\n\n\nTip:\n The paid version of the \nMath2D Plugin\n is both faster than the SSK2 (Pure Lua) version and incorporates a number of additional features, so you should definitely check it out!\n\n\nVector Representations\n\n\nIn the context of these docs, a vector is any table or object with both an x- and a y-field.  Additionally, we often deal with vectors as discrete collections of \nx\n and \ny\n values. \n\n\n-- A table as a 2d-vector: \n 10, 15 \n\nlocal v1 = { x = 10, y = 15 } \n\n-- A circle display object; Also a 2d-vector: \n 10, 15 \n\nlocal circ = display.newCircle( 10, 15, 5 )\n\n-- Four discrete values repsenting the vectors: \n 10, 15 \n and \n -1, 0 \n\nlocal x1 = 10\nlocal y1 = 15\nlocal x2 = -1\nlocal y2 = 0\n\n\n\n\nStandard Operations\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAddition\n\n\nSubtraction\n\n\nDifference\n\n\nLength\n\n\n\n\n\n\nSquared Length\n\n\nScaling\n\n\nNormalizing\n\n\nDot Product\n\n\n\n\n\n\nCross Product\n\n\nNormals\n\n\nAngle To Vector\n\n\nVector To Angle\n\n\n\n\n\n\nAngle Between\n\n\nDistance Between\n\n\nIs Within Distance\n\n\n\n\n\n\n\n\n\n\nAddition\n\n\nTable/Object Vectors\n\n\nmath2d.add( v1, v2 [, altRet ] )\n\n\n\n\nAdds two vectors \nv1\n and \nv2\n and returns a (table) vector unless \naltRet\n is \ntrue\n.  \n\n\n\n\nv1, v2 - Vectors one and two.\n\n\naltRet\n - If this is \ntrue\n, the function returns two discrete values.\n\n\n\n\nlocal circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.add( circ, rect ) -- Return a table\nprint(\nResults: \n, vec.x, vec.y )\n\nlocal vx,vy = math2d.add( circ, rect, true ) -- Return two numbers\nprint(\nResults: \n, vx, vy ) \n\n\n\n\nDiscrete Value Vectors\n\n\nmath2d.add( x1, y1, x2, y2 [, altRet ] )\n\n\n\n\nAdds two vectors \n \nx1\n, \ny1\n \n and \n \nx2\n, \ny2\n \n and returns two discrete values unless \naltRet\n is \ntrue\n.  \n\n\n\n\nx1, y1, x2, y2 - Four discrete values representing the two vectors: \n \nx1\n, \ny1\n \n and \n \nx2\n, \ny2\n \n.\n\n\naltRet\n - If this is \ntrue\n, the function returns a (table) vector.\n\n\n\n\nlocal circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vx,vy = math2d.add( circ.x, circ.y, rect.x, rect.y ) -- Return two numbers\nprint(\nResults: \n, vx, vy ) \n\nlocal vec = math2d.add( math2d.add( circ.x, circ.y, rect.x, rect.y, true ) -- Return a table\nprint(\nResults: \n, vec.x, vec.y )\n\n\n\n\nSubtraction\n\n\nTable/Object Vectors\n\n\nmath2d.sub( v1, v2 [, altRet ] )\n\n\n\n\nSubtracts vector \nv2\n from vector \nv1\n  ( \nv1\n - \nv2\n ) and returns a (table) vector unless \naltRet\n is \ntrue\n.  \n\n\nNote:\n The returned value represents a direction vector equivalent to the direction from \nv2\n to \nv1\n translated to \n 0, 0 \n.  Adding this vector to \nv2\n gives you \nv1\n.\n\n\n\n\nv1, v2 - Vectors one and two.\n\n\naltRet\n - If this is \ntrue\n, the function returns two discrete values.\n\n\n\n\nlocal circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.sub( circ, rect ) -- Return a table\nprint(\nResults: \n, vec.x, vec.y )\n\nlocal vx,vy = math2d.sub( circ, rect, true ) -- Return two numbers\nprint(\nResults: \n, vx, vy ) \n\n\n\n\nDiscrete Value Vectors\n\n\nmath2d.sub( x1, y1, x2, y2 [, altRet ] )\n\n\n\n\nSubtracts vector \n \nx2\n, \ny2\n \n from vector \n \nx1\n, \ny1\n \n ( \n \nx1\n - \nx2\n, \ny1\n - \ny2\n \n ) and returns two discrete values unless \naltRet\n is \ntrue\n.  \n\n\nNote:\n The returned value represents a direction vector equivalent to the direction from \nv2\n to \nv1\n translated to \n 0, 0 \n.  Adding this vector to \nv2\n gives you \nv1\n.\n\n\n\n\nx1, y1, x2, y2 - Four discrete values representing the two vectors: \n \nx1\n, \ny1\n \n and \n \nx2\n, \ny2\n \n.\n\n\naltRet\n - If this is \ntrue\n, the function returns a (table) vector.\n\n\n\n\nlocal x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nlocal vx,vy = math2d.sub( x1, y1, x2, y2 ) -- Return two numbers\nprint(\nResults: \n, vx, vy ) \n\nlocal vec = math2d.sub( x1, y1, x2, y2, true ) -- Return a table\nprint(\nResults: \n, vec.x, vec.y ) \n\n\n\n\nDifference\n\n\nTable/Object Vectors\n\n\nmath2d.diff( v1, v2 [, altRet ] )\n\n\n\n\nSubtracts vector \nv1\n from vector \nv2\n  ( \nv2\n - \nv1\n ) and returns a (table) vector unless \naltRet\n is \ntrue\n.  \n\n\nNote:\n The returned value represents a direction vector equivalent to the direction from \nv1\n to \nv2\n translated to \n 0, 0 \n.  Adding this vector to \nv1\n gives you \nv2\n.\n\n\n\n\nv1, v2 - Vectors one and two.\n\n\naltRet\n - If this is \ntrue\n, the function returns two discrete values.\n\n\n\n\nlocal circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.sub( circ, rect ) -- Return a table\nprint(\nResults: \n, vec.x, vec.y )\n\nlocal vx,vy = math2d.sub( circ, rect, true ) -- Return two numbers\nprint(\nResults: \n, vx, vy ) \n\n\n\n\n\nDiscrete Value Vectors\n\n\nmath2d.diff( x1, y1, x2, y2 [, altRet ] )\n\n\n\n\nSubtracts vector \n \nx1\n, \ny1\n \n from vector \n \nx2\n, \ny2\n \n ( \n \nx2\n - \nx1\n, \ny2\n - \ny1\n \n ) and returns two discrete values unless \naltRet\n is \ntrue\n.  \n\n\nNote:\n The returned value represents a direction vector equivalent to the direction from \nv1\n to \nv2\n translated to \n 0, 0 \n.  Adding this vector to \nv1\n gives you \nv2\n.\n\n\n\n\nx1, y1, x2, y2 - Four discrete values representing the two vectors: \n \nx1\n, \ny1\n \n and \n \nx2\n, \ny2\n \n.\n\n\naltRet\n - If this is \ntrue\n, the function returns a (table) vector.\n\n\n\n\nlocal x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nlocal vx,vy = math2d.sub( x1, y1, x2, y2 ) -- Return two numbers\nprint(\nResults: \n, vx, vy ) \n\nlocal vec = math2d.sub( x1, y1, x2, y2, true ) -- Return a table\nprint(\nResults: \n, vec.x, vec.y ) \n\n\n\n\nLength\n\n\nTable/Object Vectors\n\n\nmath2d.length( v1 )\n\n\n\n\nCalculates the length (magnitude) of scalar (encoded) vector.\n\n\n\n\nv1 - Vectors whose length we want to calculate.\n\n\n\n\nlocal circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.sub( circ, rect ) -- Return a table\n\nprint(\nResult: \n, math2d.length(vec) )\n\n\n\n\nDiscrete Value Vectors\n\n\nmath2d.length( x1, y1 )\n\n\n\n\nAdds two vectors \n \nx1\n, \ny1\n \n and \n \nx2\n, \ny2\n \n and returns two discrete values unless \naltRet\n is \ntrue\n.  \n\n\n\n\nx1, y1 - Two discrete values representing the vector \n \nx1\n, \ny1\n \n whose length we want to calculate.\n\n\n\n\nlocal x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nlocal vx,vy = math2d.sub( x1, y1, x2, y2 ) -- Return two numbers\n\nprint(\nResult: \n, math2d.length(vx, vy) )\n\n\n\n\nSquared Length\n\n\nTable/Object Vectors\n\n\nmath2d.length2( v1,  )\n\n\n\n\nCalculates the squared length of a vector.\n\n\n\n\nv1 - Vectors whose squared length we want to calculate.\n\n\n\n\nlocal circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.sub( circ, rect ) -- Return a table\n\nprint(\nResult: \n, math2d.length2(vec) )\n\n\n\n\nDiscrete Value Vectors\n\n\nmath2d.length2( x1, y1 )\n\n\n\n\nCalculates the squared length of a vector.\n\n\n\n\nx1, y1 - Two discrete values representing the vector \n \nx1\n, \ny1\n \n whose squared length we want to calculate.\n\n\n\n\nlocal x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nlocal vx,vy = math2d.sub( x1, y1, x2, y2 ) -- Return two numbers\n\nprint(\nResult: \n, math2d.length2(vx, vy) )\n\n\n\n\nScaling\n\n\nTable/Object Vectors\n\n\nmath2d.scale( obj, scaleBy [, altRet]  )\n\n\n\n\nMultiply \n x, y \n components of a vector by scaleBy.\n\n\n\n\nv1 - Vector we wish to scale.\n\n\naltRet\n - If this is \ntrue\n, the function returns two discrete values.\n\n\n\n\nlocal vec = { x = 1, y = 0 }\n\nvec = math2d.scale( vec, 30 ) -- Vector is now \n 30, 0 \n\n\n\n\n\nDiscrete Value Vectors\n\n\nmath2d.scale( vx, vy, scaleBy [, altRet ] )\n\n\n\n\nMultiply \nvx\n and \nvy\n components of a vector by scaleBy.\n\n\n\n\nx1, y1 - Two discrete values representing the vector \n \nx1\n, \ny1\n \n we wish to scale.\n\n\naltRet\n - If this is \ntrue\n, the function returns a table.\n\n\n\n\nlocal vx = 1, vy = 0\n\nvx, vy = math2d.scale( vx, vy, 30 ) -- Vector is now \n 30, 0 \n\n\n\n\n\nNormalizing\n\n\nTable/Object Vectors\n\n\nmath2d.normalize( v1 [, altRet ] )\n\n\n\n\nConverts the input vector into a unit length (one) vector.\n\n\n\n\nv1 - The vector we wish to normalize.\n\n\naltRet\n - If this is \ntrue\n, the function returns two discrete values.\n\n\n\n\nlocal vec = { x = 30, y = 30 }\n\nvec = math2d.normalize( vec ) -- Vector is now \n 0.707..., 0.707... \n\n\n\n\n\nDiscrete Value Vectors\n\n\nmath2d.normalize( x1, y1 [, altRet ] )\n\n\n\n\nConverts the input vector into a unit length (one) vector.\n\n\n\n\nx1, y1 - Two discrete values representing the vector \n \nx1\n, \ny1\n \n we wish to normalize.\n\n\naltRet\n - If this is \ntrue\n, the function returns a (table) vector.\n\n\n\n\nlocal vx = 30, vy = 30\n\nvx, vy = math2d.normalize( vx, vy ) -- Vector is now \n 0.707..., 0.707... \n\n\n\n\n\nDot Product\n\n\nTable/Object Vectors\n\n\nmath2d.dot( v1, v2 )\n\n\n\n\nCalculates the inner product of two vectors \nv1\n and \nv2\n and returns a scalar value.\n\n\n\n\nv1, v2 - Vectors one and two.\n\n\n\n\nlocal circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nprint(\nResult: \n, math2d.dot( circ, rect ) )\n\n\n\n\nDiscrete Value Vectors\n\n\nmath2d.dot( x1, y1, x2, y2 )\n\n\n\n\nCalculates the inner product of two vectors \n \nx1\n, \ny1\n \n and \n \nx2\n, \ny2\n \n and returns a scalar value.\n\n\n\n\nx1, y1, x2, y2 - Four discrete values representing the two vectors: \n \nx1\n, \ny1\n \n and \n \nx2\n, \ny2\n \n.\n\n\n\n\nlocal x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nprint(\nResult: \n, math2d.dot( x1, y1, x2, y2 ) )\n\n\n\n\nCross Product\n\n\nTable/Object Vectors\n\n\nmath2d.cross( v1, v2 )\n\n\n\n\nCalculates the cross product of two vectors \nv1\n and \nv2\n and returns a scalar value.\n\n\n\n\nv1, v2 - Vectors one and two.\n\n\n\n\nlocal circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nprint(\nResult: \n, math2d.cross( circ, rect ) )\n\n\n\n\nDiscrete Value Vectors\n\n\nmath2d.cross( x1, y1, x2, y2 )\n\n\n\n\nCalculates the cross product of two vectors \n \nx1\n, \ny1\n \n and \n \nx2\n, \ny2\n \n and returns a scalar value.\n\n\n\n\nx1, y1, x2, y2 - Four discrete values representing the two vectors: \n \nx1\n, \ny1\n \n and \n \nx2\n, \ny2\n \n.\n\n\n\n\nlocal x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nprint(\nResult: \n, math2d.cross( x1, y1, x2, y2 ) )\n\n\n\n\nNormals\n\n\nTable/Object Vectors\n\n\nmath2d.normals( v1 [, altRet ] )\n\n\n\n\nReturns two normal vectors \nn1\n and \nn2\n for the given vector \nv1\n unless \naltRet\n is \ntrue\n.  \n\n\nWarning:\n The returned normals are not normalized (unit length) to save computation time.\n\n\n\n\nv1 - Vector for which we want the two normal vectors.\n\n\naltRet\n - If this is \ntrue\n, the function returns four discrete values representing two vectors.\n\n\n\n\nlocal vec = { x = 1, y = 0 }\n\nlocal n1, n2 = math2d.normals( vec ) \n\n-- n1 and n2 will contain the two vectors:\n--   \n 0, -1 \n and \n 0, 1 \n (order may vary).\n\n\n\n\nDiscrete Value Vectors\n\n\nmath2d.normals( x1, y1 [, altRet ] )\n\n\n\n\nReturns two normal vectors \n \nnx1\n, \nny1\n \n and \n \nnx2\n, \nny2\n \n for the given vector \n \nx1\n, \ny1\n \n unless \naltRet\n is \ntrue\n.  \n\n\nWarning:\n The returned normals are not normalized (unit length) to save computation time.\n\n\n\n\nx1, y1 - Two discrete values representing the vector: \n \nx1\n, \ny1\n \n for which we want two normals.\n\n\naltRet\n - If this is \ntrue\n, the function returns two tables representing two vectors.\n\n\n\n\nlocal x1 = 1, y1 = 0\n\nlocal nx1, ny1, nx2, ny2 = math2d.normals( x1, y1 ) \n\n-- \n nx1, ny1 \n and \n nx2, ny2 \n will be equivalent to: \n--   \n 0, -1 \n and \n 0, 1 \n (order may vary).\n\n\n\n\nAngle To Vector\n\n\nmath2d.angle2Vector( angle [, altRet ] )\n\n\n\n\nConverts a (screen) angle into a normalized direction vector of the form \n vx, vy \n.  \n\n\nWarning:\n This library uses screen angles NOT Cartesian or polar.\n\n\n\n\nangle - Angle whose value we wish to convert to a unit length direction vector.\n\n\naltRet\n - If this is \ntrue\n, the function returns a table otherwise it returns two scalar values.\n\n\n\n\nlocal angle = 135\n\nlocal vec = math2d.angle2Vector( angle, true ) -- Return a table\nprint(\nThe vector: \n .. vec.x .. \n, \n .. vec.y  )\n\nlocal vx,vy = math2d.angle2Vector( angle ) -- Return two numbers\nprint(\nThe vector: \n .. vx .. \n, \n .. vy  )\n\n\n\n\nVector To Angle\n\n\nTable/Object Vectors\n\n\nmath2d.vector2Angle( v1 )\n\n\n\n\nTakes a table vector and returns a screen angle.\nWarning: This library uses screen angles NOT Cartesian or polar. \n\n\n\n\nv1 - Vector we wish to calculate the angle (direction) for.\n\n\n\n\nlocal circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.sub( circ, rect ) -- Return a table\n\nprint(\nResult: \n, math2d.vector2Angle(vec) )\n\n\n\n\nDiscrete Value Vectors\n\n\nmath2d.vector2Angle( vx, vy )\n\n\n\n\nTakes a two discrete values representing a vector and returns a screen angle.\n\n\n\n\nvx, vy - Two discrete values representing a vector \n \nx1\n, \ny1\n \n we wish to calculate the angle (direction) for.\n\n\n\n\nlocal x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nlocal vx,vy = math2d.sub( x1, y1, x2, y2 ) -- Return two numbers\n\nprint(\nResult: \n, math2d.vector2Angle(vx, vy) )\n\n\n\n\nAngle Between\n\n\n\n\nmath2d.angleBetween( v1, v2 )\nmath2d.angleBetween( x1, y1, x2, y2 )\n\n\n\n\nReturns the inner (shortest) angle between two vectors.  \n\n\nTip:\n These vectors do not have to have the same tail.\n\n\n\n\nv1, v2 - Vectors one and two.\n\n\nx1, y1, x2, y2 - Four discrete values representing the two vectors: \n \nx1\n, \ny1\n \n and \n \nx2\n, \ny2\n \n.\n\n\n\n\nlocal vec1 = angle2Vector( -90, true )\nlocal vec2 = angle2Vector( -15, true )\n\nprint( math2d.angleBetween( vec1, vec2 ) ) -- ~75 degrees\n\nprint( math2d.angleBetween( vec2, vec1 ) ) -- ~75 degrees\n\n\n\n\nDistance Between\n\n\nmath2d.distanceBetween( v1, v2 )\nmath2d.distanceBetween( x1, y1, x2, y2 )\n\n\n\n\nReturns the distance between two vectors.  Shorthand notation for substraction followed by a length calculation.\n\n\n\n\nv1, v2 - Vectors one and two.\n\n\nx1, y1, x2, y2 - Four discrete values representing the two vectors: \n \nx1\n, \ny1\n \n and \n \nx2\n, \ny2\n \n.\n\n\n\n\nlocal vec1 = { x = 0, y = 100 }\nlocal vec2 = { x = 0, y = 0 }\n\nprint( math2d.distanceBetween( vec1, vec2 ) ) -- 100\n\nprint( math2d.distanceBetween( 0, 100, 0, 0 ) ) -- 100\n\n\n\n\nIs Within Distance\n\n\nmath2d.isWithinDistance( v1, v2, distance )\nmath2d.isWithinDistance( x1, y1, x2, y2, distance )\n\n\n\n\nReturns true if two vectors are with the specified \ndistance\n of each other.\n\n\n\n\nv1, v2 - Vectors one and two.\n\n\nx1, y1, x2, y2 - Four discrete values representing the two vectors: \n \nx1\n, \ny1\n \n and \n \nx2\n, \ny2\n \n.\n\n\ndistance - Distance for which true is returned.  Greater than this returns false.\n\n\n\n\nlocal vec1 = { x = 0, y = 100 }\nlocal vec2 = { x = 0, y = 0 }\n\nprint( math2d.isWithinDistance( vec1, vec2, 100 ) ) -- true\n\nprint( math2d.isWithinDistance( vec1, vec2, 99.999 ) ) -- false\n\nprint( math2d.isWithinDistance( 0, 100, 0, 0, 100 ) ) -- true\n\nprint( math2d.isWithinDistance( 0, 100, 0, 0, 99.999 ) ) -- false\n\n\n\n\nAdvanced Operations\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn Field-Of-View\n\n\n\n\n\n\n\n\n\n\n\n\nIs In Front\n\n\nIs Behind\n\n\nIs To Left\n\n\nIs To Right\n\n\n\n\n\n\nLine-Line Intersect\n\n\nSegment-Segment Intersect\n\n\nSegment-Circle Intersect\n\n\n\n\n\n\n\n\n\n\nIn Field-Of-View\n\n\n\n\n(image borrowed from \nGeek Blight\n)\n\n\nmath2d.inFOV( target, observer, fov [, offsetAngle ] )\n\n\n\n\nReturns true \ntarget\n is within \nobserver\n's field of view as defined by \nfov\n and the optional rotation \noffsetAngle\n.\n\n\n\n\ntarget - A table vector.  Usually a display object, but can be a table representing point in the world.\n\n\nobserver - A table vector containing a \nrotation\n value in addition to the \nx\n and \ny\n values.  Usually a display object.\n\n\nfov - The angle representing the entire field of vision of the observer from that observer's current forward facing vector.\n\n\noffsetAngle - Optional angle used to 'rotate' the fov from the observer's forward view.  With this you can rotate the observer's view without rotating the object itself which is useful for animations that give the effect of rotating while the display object stays fixed.\n\n\n\n\n-- See picture above for reference\n-- objectA, objecB, and player are all display objects.\n\nmath2d.inFOV( objectA, player, 90 ) -- false\n\nmath2d.inFOV( objectB, player, 90 ) -- true\n\nmath2d.inFOV( objectA, player, 90, 270 ) -- true because we rotated the FOV by 270 degrees\n\n\n\n\nIs In Front\n\n\nIs Behind\n\n\nIs To Left\n\n\nIs To Right\n\n\nmath2d.isInFront( target, observer [, offsetAngle ] )\nmath2d.isBehind( target, observer [, offsetAngle ] )\nmath2d.isToLeft( target, observer [, offsetAngle ] )\nmath2d.isToRight( target, observer [, offsetAngle ] )\n\n\n\n\nThese are all shortcut functions that will quickly tell you if an object is: in-front, behind. to-the-left, or to-the-right of another object.  This is exceptionally useful for things like missiles or enemies that need to 'steer' in the direction of a target.\n\n\nThis determiniation is based upon the current \nrotation\n of the observer and that angle can be modified with the optional \noffsetAngle\n.\n\n\n\n\ntarget - A table vector.  Usually a display object, but can be a table representing point in the world.\n\n\nobserver - A table vector containing a \nrotation\n value in addition to the \nx\n and \ny\n values.  Usually a display object.\n\n\noffsetAngle - Optional angle used to 'rotate' the observers 'forward' vector for the calculation without actually rotating the observer.\n\n\n\n\n-- See picture from 'In Field-Of-View ' above for reference\n\nmath2d.isInFront( objectA, player ) -- true\n\nmath2d.isInFront( objectB, player ) -- true \n\nmath2d.isToLeft( objectA, player ) -- true\n\nmath2d.isToRight( objectB, player ) -- true \n\n\n\n\nLine-Line Intersect\n\n\n\n\nmath2d.lineLineIntersect( l1x1, l1y1, l1x1, l1y2, l2x1, l2y1, l2x2, l2y2 )\nmath2d.lineLineIntersect( p1, p2, p3, p4 )\n\n\n\n\nChecks to see if two lines intersect and if so where. \n\n\nReturns table representing point of intersection \n{ x = ??, y = ?? }\n, or nil indicating no intersection was found.\n\n\nWarning:\n Although these 'lines' are specified as segments, they are treated as true (infinite) lines and as such any intersection of the infinite lines will be detected.\n\n\n\n\nl1x1 .. l2y2 - Points making up the two lines we wish to test.  For example, \n l1x1, l1y1 \n is the position of the first point of the first line.\n\n\np1, p2, p3, p4 - Points making up the two lines we wish to test.  \n\n\nValid point \n \n{ x = 10, y = 20 }\n\n\n\n\n\n\n\n\nlocal x1,y1,x2,y2 = display.contentCenterX, display.contentCenterY-200, \n                    display.contentCenterX, display.contentCenterY+200\nlocal line1 = display.newLine( x1,y1,x2,y2 )\nline1.strokeWidth = 2\n\nlocal x3,y3,x4,y4 = display.contentCenterX-200, display.contentCenterY, \n                    display.contentCenterX + 200, display.contentCenterY\nlocal line2 = display.newLine( x3,y3,x4,y4 )\nline2.strokeWidth = 2\n\nlocal period = 60\nlocal deltaAngle = 5\nlocal startAngle = 0\nlocal endAngle = 360\nlocal angle = startAngle\nlocal marker\n\nlocal function testLineIntersect()\n    angle = angle + deltaAngle\n    display.remove(line2)\n    display.remove(marker)\n\n    if( angle \n endAngle ) then         \n        return\n    end\n    local vec = angle2Vector( angle, true )\n    vec = scaleVec( vec, 250 )\n    vec.x = vec.x + x3\n    vec.y = vec.y + y3\n    line2 = display.newLine( x3, y3, vec.x, vec.y )\n    line2.strokeWidth = 2\n    local intersect = math2d.lineLineIntersect( x3, y3, vec.x, vec.y, x1, y1, x2, y2 )\n    if( intersect ) then \n        marker = display.newCircle( intersect.x, intersect.y, 10, true, true )\n        marker:setFillColor(0,1,0)\n    end\n\n    timer.performWithDelay( period, testLineIntersect )\nend\ntimer.performWithDelay( period, testLineIntersect )\n\n\n\n\nSegment-Segment Intersect\n\n\n\n\nmath2d.segmentSegmentIntersect( s1x1, s1y1, s1x1, s1y2, s2x1, s2y1, s2x2, s2y2 )\n\n\n\n\nChecks to see if two line segments intersect and if so where. \n\n\nReturns two points \n x, y \n if an intersection occurs or nil meaning no intersection was found.\n\n\nNote:\n For most game implementations/tests you will want to use this instead of the line-line version as it is a true segment-segment test and only checks for intersections within the limited ranges of the two segments.\n\n\n\n\ns1x1 .. s2y2 - Points making up the two lines we wish to test.  For example, \n s1x1, s1y1 \n is the position of the first point of the first segment.\n\n\n\n\nlocal x1,y1,x2,y2 = display.contentCenterX, display.contentCenterY-200, \n                    display.contentCenterX, display.contentCenterY+200\nlocal line1 = display.newLine( x1,y1,x2,y2 )\nline1.strokeWidth = 2\n\nlocal x3,y3,x4,y4 = display.contentCenterX-200, display.contentCenterY, \n                    display.contentCenterX + 200, display.contentCenterY\nlocal line2 = display.newLine( x3,y3,x4,y4 )\nline2.strokeWidth = 2\n\nlocal period = 60\nlocal deltaAngle = 5\nlocal startAngle = 0\nlocal endAngle = 360\nlocal angle = startAngle\nlocal marker\n\nlocal function testSegmentIntersect()\n    angle = angle + deltaAngle\n    display.remove(line2)\n    display.remove(marker)\n\n    if( angle \n endAngle ) then         \n        return\n    end\n    local vec = angle2Vector( angle, true )\n    vec = scaleVec( vec, 250 )\n    vec.x = vec.x + x3\n    vec.y = vec.y + y3\n    line2 = display.newLine( x3, y3, vec.x, vec.y )\n    line2.strokeWidth = 2\n    local intersect = math2d.segmentSegmentIntersect( x3, y3, vec.x, vec.y , x1, y1, x2, y2 )\n    if( intersect ) then \n        print(intersect)\n        marker = display.newCircle( intersect.x, intersect.y, 10, true, true )\n        marker:setFillColor(0,1,0)\n    end\n\n    timer.performWithDelay( period, testSegmentIntersect )\nend\ntimer.performWithDelay( period, testSegmentIntersect )\n\n\n\n\nSegment-Circle Intersect\n\n\nmath2d.segmentCircleIntersect( p1, p2, circle, radius )\n\n\n\n\n\n\nChecks to see if the line segment defined by points \np1\n and \np2\n intersects with a \ncircle\n of the specified \nradius\n.\n\n\nPossible returns:\n\n\n\n\nnil - No intersections.\n\n\ni1,  nil - Table containing point of first intersection and nil meaning no second intersection.\n\n\ni1,  i2 - Tables containing points of first and second intersection. (This is the maximum possible number of intersections that can occur.)\n\n\n\n\nCredit:\n Derived from code by: Davis Claiborne (https://github.com/davisdude/mlib/blob/master/mlib.lua)\n\n\n\n\np1, p2 - Table vectors representing the endpoints of a line segment.\n\n\ncircle - Table or object representing the position of the circle.\n\n\nradius - The radius of said circle.\n\n\n\n\nlocal x1,y1,x2,y2 = display.contentCenterX, display.contentCenterY+200, \n                    display.contentCenterX, display.contentCenterY-200\nx1 = x1 - 150\nx2 = x2\nlocal line1 = display.newLine( x1,y1,x2,y2 )\nline1.strokeWidth = 2\n\nlocal p1 = { x = x1, y = y1 }\nlocal p2 = { x = x2, y = y2 }\n\nlocal circ = display.newCircle( display.contentCenterX, display.contentCenterY, 100 )\ncirc:setFillColor(0,0,0,0)\ncirc.strokeWidth = 2\n\nlocal i1, i2 = math2d.segmentCircleIntersect( { x = p1.x, y = p1.y}, \n                                               { x = p2.x, y = p2.y}, \n                                               circ, \n                                               100 )\n\nif( i1 ) then\n    local hit = display.newCircle( i1.x, i1.y, 10 )\n    hit:setFillColor(0,1,0)\nend\n\nif( i2 ) then\n    local hit = display.newCircle( i2.x, i2.y, 10 )\n    hit:setFillColor(0,1,0)\nend\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.math2d.*"
        }, 
        {
            "location": "/libraries/math2D/#2d-math-sskmath2d", 
            "text": "SSK2 comes with a complete library of fundamental 2D operations.  Additionally, if you own the  Math2D Plugin , SSK can use that instead.  \n-- Use Math2D Plugin if you own it!\n_G.ssk.init( { math2DPlugin = true } )  Tip:  The paid version of the  Math2D Plugin  is both faster than the SSK2 (Pure Lua) version and incorporates a number of additional features, so you should definitely check it out!", 
            "title": "2D Math (ssk.math2d.*)"
        }, 
        {
            "location": "/libraries/math2D/#vector-representations", 
            "text": "In the context of these docs, a vector is any table or object with both an x- and a y-field.  Additionally, we often deal with vectors as discrete collections of  x  and  y  values.   -- A table as a 2d-vector:   10, 15  \nlocal v1 = { x = 10, y = 15 } \n\n-- A circle display object; Also a 2d-vector:   10, 15  \nlocal circ = display.newCircle( 10, 15, 5 )\n\n-- Four discrete values repsenting the vectors:   10, 15   and   -1, 0  \nlocal x1 = 10\nlocal y1 = 15\nlocal x2 = -1\nlocal y2 = 0", 
            "title": "Vector Representations"
        }, 
        {
            "location": "/libraries/math2D/#standard-operations", 
            "text": "Addition  Subtraction  Difference  Length    Squared Length  Scaling  Normalizing  Dot Product    Cross Product  Normals  Angle To Vector  Vector To Angle    Angle Between  Distance Between  Is Within Distance", 
            "title": "Standard Operations"
        }, 
        {
            "location": "/libraries/math2D/#addition", 
            "text": "", 
            "title": "Addition"
        }, 
        {
            "location": "/libraries/math2D/#tableobject-vectors", 
            "text": "math2d.add( v1, v2 [, altRet ] )  Adds two vectors  v1  and  v2  and returns a (table) vector unless  altRet  is  true .     v1, v2 - Vectors one and two.  altRet  - If this is  true , the function returns two discrete values.   local circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.add( circ, rect ) -- Return a table\nprint( Results:  , vec.x, vec.y )\n\nlocal vx,vy = math2d.add( circ, rect, true ) -- Return two numbers\nprint( Results:  , vx, vy )", 
            "title": "Table/Object Vectors"
        }, 
        {
            "location": "/libraries/math2D/#discrete-value-vectors", 
            "text": "math2d.add( x1, y1, x2, y2 [, altRet ] )  Adds two vectors    x1 ,  y1    and    x2 ,  y2    and returns two discrete values unless  altRet  is  true .     x1, y1, x2, y2 - Four discrete values representing the two vectors:    x1 ,  y1    and    x2 ,  y2   .  altRet  - If this is  true , the function returns a (table) vector.   local circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vx,vy = math2d.add( circ.x, circ.y, rect.x, rect.y ) -- Return two numbers\nprint( Results:  , vx, vy ) \n\nlocal vec = math2d.add( math2d.add( circ.x, circ.y, rect.x, rect.y, true ) -- Return a table\nprint( Results:  , vec.x, vec.y )", 
            "title": "Discrete Value Vectors"
        }, 
        {
            "location": "/libraries/math2D/#subtraction", 
            "text": "", 
            "title": "Subtraction"
        }, 
        {
            "location": "/libraries/math2D/#tableobject-vectors_1", 
            "text": "math2d.sub( v1, v2 [, altRet ] )  Subtracts vector  v2  from vector  v1   (  v1  -  v2  ) and returns a (table) vector unless  altRet  is  true .    Note:  The returned value represents a direction vector equivalent to the direction from  v2  to  v1  translated to   0, 0  .  Adding this vector to  v2  gives you  v1 .   v1, v2 - Vectors one and two.  altRet  - If this is  true , the function returns two discrete values.   local circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.sub( circ, rect ) -- Return a table\nprint( Results:  , vec.x, vec.y )\n\nlocal vx,vy = math2d.sub( circ, rect, true ) -- Return two numbers\nprint( Results:  , vx, vy )", 
            "title": "Table/Object Vectors"
        }, 
        {
            "location": "/libraries/math2D/#discrete-value-vectors_1", 
            "text": "math2d.sub( x1, y1, x2, y2 [, altRet ] )  Subtracts vector    x2 ,  y2    from vector    x1 ,  y1    (    x1  -  x2 ,  y1  -  y2    ) and returns two discrete values unless  altRet  is  true .    Note:  The returned value represents a direction vector equivalent to the direction from  v2  to  v1  translated to   0, 0  .  Adding this vector to  v2  gives you  v1 .   x1, y1, x2, y2 - Four discrete values representing the two vectors:    x1 ,  y1    and    x2 ,  y2   .  altRet  - If this is  true , the function returns a (table) vector.   local x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nlocal vx,vy = math2d.sub( x1, y1, x2, y2 ) -- Return two numbers\nprint( Results:  , vx, vy ) \n\nlocal vec = math2d.sub( x1, y1, x2, y2, true ) -- Return a table\nprint( Results:  , vec.x, vec.y )", 
            "title": "Discrete Value Vectors"
        }, 
        {
            "location": "/libraries/math2D/#difference", 
            "text": "", 
            "title": "Difference"
        }, 
        {
            "location": "/libraries/math2D/#tableobject-vectors_2", 
            "text": "math2d.diff( v1, v2 [, altRet ] )  Subtracts vector  v1  from vector  v2   (  v2  -  v1  ) and returns a (table) vector unless  altRet  is  true .    Note:  The returned value represents a direction vector equivalent to the direction from  v1  to  v2  translated to   0, 0  .  Adding this vector to  v1  gives you  v2 .   v1, v2 - Vectors one and two.  altRet  - If this is  true , the function returns two discrete values.   local circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.sub( circ, rect ) -- Return a table\nprint( Results:  , vec.x, vec.y )\n\nlocal vx,vy = math2d.sub( circ, rect, true ) -- Return two numbers\nprint( Results:  , vx, vy )", 
            "title": "Table/Object Vectors"
        }, 
        {
            "location": "/libraries/math2D/#discrete-value-vectors_2", 
            "text": "math2d.diff( x1, y1, x2, y2 [, altRet ] )  Subtracts vector    x1 ,  y1    from vector    x2 ,  y2    (    x2  -  x1 ,  y2  -  y1    ) and returns two discrete values unless  altRet  is  true .    Note:  The returned value represents a direction vector equivalent to the direction from  v1  to  v2  translated to   0, 0  .  Adding this vector to  v1  gives you  v2 .   x1, y1, x2, y2 - Four discrete values representing the two vectors:    x1 ,  y1    and    x2 ,  y2   .  altRet  - If this is  true , the function returns a (table) vector.   local x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nlocal vx,vy = math2d.sub( x1, y1, x2, y2 ) -- Return two numbers\nprint( Results:  , vx, vy ) \n\nlocal vec = math2d.sub( x1, y1, x2, y2, true ) -- Return a table\nprint( Results:  , vec.x, vec.y )", 
            "title": "Discrete Value Vectors"
        }, 
        {
            "location": "/libraries/math2D/#length", 
            "text": "", 
            "title": "Length"
        }, 
        {
            "location": "/libraries/math2D/#tableobject-vectors_3", 
            "text": "math2d.length( v1 )  Calculates the length (magnitude) of scalar (encoded) vector.   v1 - Vectors whose length we want to calculate.   local circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.sub( circ, rect ) -- Return a table\n\nprint( Result:  , math2d.length(vec) )", 
            "title": "Table/Object Vectors"
        }, 
        {
            "location": "/libraries/math2D/#discrete-value-vectors_3", 
            "text": "math2d.length( x1, y1 )  Adds two vectors    x1 ,  y1    and    x2 ,  y2    and returns two discrete values unless  altRet  is  true .     x1, y1 - Two discrete values representing the vector    x1 ,  y1    whose length we want to calculate.   local x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nlocal vx,vy = math2d.sub( x1, y1, x2, y2 ) -- Return two numbers\n\nprint( Result:  , math2d.length(vx, vy) )", 
            "title": "Discrete Value Vectors"
        }, 
        {
            "location": "/libraries/math2D/#squared-length", 
            "text": "", 
            "title": "Squared Length"
        }, 
        {
            "location": "/libraries/math2D/#tableobject-vectors_4", 
            "text": "math2d.length2( v1,  )  Calculates the squared length of a vector.   v1 - Vectors whose squared length we want to calculate.   local circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.sub( circ, rect ) -- Return a table\n\nprint( Result:  , math2d.length2(vec) )", 
            "title": "Table/Object Vectors"
        }, 
        {
            "location": "/libraries/math2D/#discrete-value-vectors_4", 
            "text": "math2d.length2( x1, y1 )  Calculates the squared length of a vector.   x1, y1 - Two discrete values representing the vector    x1 ,  y1    whose squared length we want to calculate.   local x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nlocal vx,vy = math2d.sub( x1, y1, x2, y2 ) -- Return two numbers\n\nprint( Result:  , math2d.length2(vx, vy) )", 
            "title": "Discrete Value Vectors"
        }, 
        {
            "location": "/libraries/math2D/#scaling", 
            "text": "", 
            "title": "Scaling"
        }, 
        {
            "location": "/libraries/math2D/#tableobject-vectors_5", 
            "text": "math2d.scale( obj, scaleBy [, altRet]  )  Multiply   x, y   components of a vector by scaleBy.   v1 - Vector we wish to scale.  altRet  - If this is  true , the function returns two discrete values.   local vec = { x = 1, y = 0 }\n\nvec = math2d.scale( vec, 30 ) -- Vector is now   30, 0", 
            "title": "Table/Object Vectors"
        }, 
        {
            "location": "/libraries/math2D/#discrete-value-vectors_5", 
            "text": "math2d.scale( vx, vy, scaleBy [, altRet ] )  Multiply  vx  and  vy  components of a vector by scaleBy.   x1, y1 - Two discrete values representing the vector    x1 ,  y1    we wish to scale.  altRet  - If this is  true , the function returns a table.   local vx = 1, vy = 0\n\nvx, vy = math2d.scale( vx, vy, 30 ) -- Vector is now   30, 0", 
            "title": "Discrete Value Vectors"
        }, 
        {
            "location": "/libraries/math2D/#normalizing", 
            "text": "", 
            "title": "Normalizing"
        }, 
        {
            "location": "/libraries/math2D/#tableobject-vectors_6", 
            "text": "math2d.normalize( v1 [, altRet ] )  Converts the input vector into a unit length (one) vector.   v1 - The vector we wish to normalize.  altRet  - If this is  true , the function returns two discrete values.   local vec = { x = 30, y = 30 }\n\nvec = math2d.normalize( vec ) -- Vector is now   0.707..., 0.707...", 
            "title": "Table/Object Vectors"
        }, 
        {
            "location": "/libraries/math2D/#discrete-value-vectors_6", 
            "text": "math2d.normalize( x1, y1 [, altRet ] )  Converts the input vector into a unit length (one) vector.   x1, y1 - Two discrete values representing the vector    x1 ,  y1    we wish to normalize.  altRet  - If this is  true , the function returns a (table) vector.   local vx = 30, vy = 30\n\nvx, vy = math2d.normalize( vx, vy ) -- Vector is now   0.707..., 0.707...", 
            "title": "Discrete Value Vectors"
        }, 
        {
            "location": "/libraries/math2D/#dot-product", 
            "text": "", 
            "title": "Dot Product"
        }, 
        {
            "location": "/libraries/math2D/#tableobject-vectors_7", 
            "text": "math2d.dot( v1, v2 )  Calculates the inner product of two vectors  v1  and  v2  and returns a scalar value.   v1, v2 - Vectors one and two.   local circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nprint( Result:  , math2d.dot( circ, rect ) )", 
            "title": "Table/Object Vectors"
        }, 
        {
            "location": "/libraries/math2D/#discrete-value-vectors_7", 
            "text": "math2d.dot( x1, y1, x2, y2 )  Calculates the inner product of two vectors    x1 ,  y1    and    x2 ,  y2    and returns a scalar value.   x1, y1, x2, y2 - Four discrete values representing the two vectors:    x1 ,  y1    and    x2 ,  y2   .   local x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nprint( Result:  , math2d.dot( x1, y1, x2, y2 ) )", 
            "title": "Discrete Value Vectors"
        }, 
        {
            "location": "/libraries/math2D/#cross-product", 
            "text": "", 
            "title": "Cross Product"
        }, 
        {
            "location": "/libraries/math2D/#tableobject-vectors_8", 
            "text": "math2d.cross( v1, v2 )  Calculates the cross product of two vectors  v1  and  v2  and returns a scalar value.   v1, v2 - Vectors one and two.   local circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nprint( Result:  , math2d.cross( circ, rect ) )", 
            "title": "Table/Object Vectors"
        }, 
        {
            "location": "/libraries/math2D/#discrete-value-vectors_8", 
            "text": "math2d.cross( x1, y1, x2, y2 )  Calculates the cross product of two vectors    x1 ,  y1    and    x2 ,  y2    and returns a scalar value.   x1, y1, x2, y2 - Four discrete values representing the two vectors:    x1 ,  y1    and    x2 ,  y2   .   local x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nprint( Result:  , math2d.cross( x1, y1, x2, y2 ) )", 
            "title": "Discrete Value Vectors"
        }, 
        {
            "location": "/libraries/math2D/#normals", 
            "text": "", 
            "title": "Normals"
        }, 
        {
            "location": "/libraries/math2D/#tableobject-vectors_9", 
            "text": "math2d.normals( v1 [, altRet ] )  Returns two normal vectors  n1  and  n2  for the given vector  v1  unless  altRet  is  true .    Warning:  The returned normals are not normalized (unit length) to save computation time.   v1 - Vector for which we want the two normal vectors.  altRet  - If this is  true , the function returns four discrete values representing two vectors.   local vec = { x = 1, y = 0 }\n\nlocal n1, n2 = math2d.normals( vec ) \n\n-- n1 and n2 will contain the two vectors:\n--     0, -1   and   0, 1   (order may vary).", 
            "title": "Table/Object Vectors"
        }, 
        {
            "location": "/libraries/math2D/#discrete-value-vectors_9", 
            "text": "math2d.normals( x1, y1 [, altRet ] )  Returns two normal vectors    nx1 ,  ny1    and    nx2 ,  ny2    for the given vector    x1 ,  y1    unless  altRet  is  true .    Warning:  The returned normals are not normalized (unit length) to save computation time.   x1, y1 - Two discrete values representing the vector:    x1 ,  y1    for which we want two normals.  altRet  - If this is  true , the function returns two tables representing two vectors.   local x1 = 1, y1 = 0\n\nlocal nx1, ny1, nx2, ny2 = math2d.normals( x1, y1 ) \n\n--   nx1, ny1   and   nx2, ny2   will be equivalent to: \n--     0, -1   and   0, 1   (order may vary).", 
            "title": "Discrete Value Vectors"
        }, 
        {
            "location": "/libraries/math2D/#angle-to-vector", 
            "text": "math2d.angle2Vector( angle [, altRet ] )  Converts a (screen) angle into a normalized direction vector of the form   vx, vy  .    Warning:  This library uses screen angles NOT Cartesian or polar.   angle - Angle whose value we wish to convert to a unit length direction vector.  altRet  - If this is  true , the function returns a table otherwise it returns two scalar values.   local angle = 135\n\nlocal vec = math2d.angle2Vector( angle, true ) -- Return a table\nprint( The vector:   .. vec.x ..  ,   .. vec.y  )\n\nlocal vx,vy = math2d.angle2Vector( angle ) -- Return two numbers\nprint( The vector:   .. vx ..  ,   .. vy  )", 
            "title": "Angle To Vector"
        }, 
        {
            "location": "/libraries/math2D/#vector-to-angle", 
            "text": "", 
            "title": "Vector To Angle"
        }, 
        {
            "location": "/libraries/math2D/#tableobject-vectors_10", 
            "text": "math2d.vector2Angle( v1 )  Takes a table vector and returns a screen angle.\nWarning: This library uses screen angles NOT Cartesian or polar.    v1 - Vector we wish to calculate the angle (direction) for.   local circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.sub( circ, rect ) -- Return a table\n\nprint( Result:  , math2d.vector2Angle(vec) )", 
            "title": "Table/Object Vectors"
        }, 
        {
            "location": "/libraries/math2D/#discrete-value-vectors_10", 
            "text": "math2d.vector2Angle( vx, vy )  Takes a two discrete values representing a vector and returns a screen angle.   vx, vy - Two discrete values representing a vector    x1 ,  y1    we wish to calculate the angle (direction) for.   local x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nlocal vx,vy = math2d.sub( x1, y1, x2, y2 ) -- Return two numbers\n\nprint( Result:  , math2d.vector2Angle(vx, vy) )", 
            "title": "Discrete Value Vectors"
        }, 
        {
            "location": "/libraries/math2D/#angle-between", 
            "text": "math2d.angleBetween( v1, v2 )\nmath2d.angleBetween( x1, y1, x2, y2 )  Returns the inner (shortest) angle between two vectors.    Tip:  These vectors do not have to have the same tail.   v1, v2 - Vectors one and two.  x1, y1, x2, y2 - Four discrete values representing the two vectors:    x1 ,  y1    and    x2 ,  y2   .   local vec1 = angle2Vector( -90, true )\nlocal vec2 = angle2Vector( -15, true )\n\nprint( math2d.angleBetween( vec1, vec2 ) ) -- ~75 degrees\n\nprint( math2d.angleBetween( vec2, vec1 ) ) -- ~75 degrees", 
            "title": "Angle Between"
        }, 
        {
            "location": "/libraries/math2D/#distance-between", 
            "text": "math2d.distanceBetween( v1, v2 )\nmath2d.distanceBetween( x1, y1, x2, y2 )  Returns the distance between two vectors.  Shorthand notation for substraction followed by a length calculation.   v1, v2 - Vectors one and two.  x1, y1, x2, y2 - Four discrete values representing the two vectors:    x1 ,  y1    and    x2 ,  y2   .   local vec1 = { x = 0, y = 100 }\nlocal vec2 = { x = 0, y = 0 }\n\nprint( math2d.distanceBetween( vec1, vec2 ) ) -- 100\n\nprint( math2d.distanceBetween( 0, 100, 0, 0 ) ) -- 100", 
            "title": "Distance Between"
        }, 
        {
            "location": "/libraries/math2D/#is-within-distance", 
            "text": "math2d.isWithinDistance( v1, v2, distance )\nmath2d.isWithinDistance( x1, y1, x2, y2, distance )  Returns true if two vectors are with the specified  distance  of each other.   v1, v2 - Vectors one and two.  x1, y1, x2, y2 - Four discrete values representing the two vectors:    x1 ,  y1    and    x2 ,  y2   .  distance - Distance for which true is returned.  Greater than this returns false.   local vec1 = { x = 0, y = 100 }\nlocal vec2 = { x = 0, y = 0 }\n\nprint( math2d.isWithinDistance( vec1, vec2, 100 ) ) -- true\n\nprint( math2d.isWithinDistance( vec1, vec2, 99.999 ) ) -- false\n\nprint( math2d.isWithinDistance( 0, 100, 0, 0, 100 ) ) -- true\n\nprint( math2d.isWithinDistance( 0, 100, 0, 0, 99.999 ) ) -- false", 
            "title": "Is Within Distance"
        }, 
        {
            "location": "/libraries/math2D/#advanced-operations", 
            "text": "In Field-Of-View       Is In Front  Is Behind  Is To Left  Is To Right    Line-Line Intersect  Segment-Segment Intersect  Segment-Circle Intersect", 
            "title": "Advanced Operations"
        }, 
        {
            "location": "/libraries/math2D/#in-field-of-view", 
            "text": "(image borrowed from  Geek Blight )  math2d.inFOV( target, observer, fov [, offsetAngle ] )  Returns true  target  is within  observer 's field of view as defined by  fov  and the optional rotation  offsetAngle .   target - A table vector.  Usually a display object, but can be a table representing point in the world.  observer - A table vector containing a  rotation  value in addition to the  x  and  y  values.  Usually a display object.  fov - The angle representing the entire field of vision of the observer from that observer's current forward facing vector.  offsetAngle - Optional angle used to 'rotate' the fov from the observer's forward view.  With this you can rotate the observer's view without rotating the object itself which is useful for animations that give the effect of rotating while the display object stays fixed.   -- See picture above for reference\n-- objectA, objecB, and player are all display objects.\n\nmath2d.inFOV( objectA, player, 90 ) -- false\n\nmath2d.inFOV( objectB, player, 90 ) -- true\n\nmath2d.inFOV( objectA, player, 90, 270 ) -- true because we rotated the FOV by 270 degrees", 
            "title": "In Field-Of-View"
        }, 
        {
            "location": "/libraries/math2D/#is-in-front", 
            "text": "", 
            "title": "Is In Front"
        }, 
        {
            "location": "/libraries/math2D/#is-behind", 
            "text": "", 
            "title": "Is Behind"
        }, 
        {
            "location": "/libraries/math2D/#is-to-left", 
            "text": "", 
            "title": "Is To Left"
        }, 
        {
            "location": "/libraries/math2D/#is-to-right", 
            "text": "math2d.isInFront( target, observer [, offsetAngle ] )\nmath2d.isBehind( target, observer [, offsetAngle ] )\nmath2d.isToLeft( target, observer [, offsetAngle ] )\nmath2d.isToRight( target, observer [, offsetAngle ] )  These are all shortcut functions that will quickly tell you if an object is: in-front, behind. to-the-left, or to-the-right of another object.  This is exceptionally useful for things like missiles or enemies that need to 'steer' in the direction of a target.  This determiniation is based upon the current  rotation  of the observer and that angle can be modified with the optional  offsetAngle .   target - A table vector.  Usually a display object, but can be a table representing point in the world.  observer - A table vector containing a  rotation  value in addition to the  x  and  y  values.  Usually a display object.  offsetAngle - Optional angle used to 'rotate' the observers 'forward' vector for the calculation without actually rotating the observer.   -- See picture from 'In Field-Of-View ' above for reference\n\nmath2d.isInFront( objectA, player ) -- true\n\nmath2d.isInFront( objectB, player ) -- true \n\nmath2d.isToLeft( objectA, player ) -- true\n\nmath2d.isToRight( objectB, player ) -- true", 
            "title": "Is To Right"
        }, 
        {
            "location": "/libraries/math2D/#line-line-intersect", 
            "text": "math2d.lineLineIntersect( l1x1, l1y1, l1x1, l1y2, l2x1, l2y1, l2x2, l2y2 )\nmath2d.lineLineIntersect( p1, p2, p3, p4 )  Checks to see if two lines intersect and if so where.   Returns table representing point of intersection  { x = ??, y = ?? } , or nil indicating no intersection was found.  Warning:  Although these 'lines' are specified as segments, they are treated as true (infinite) lines and as such any intersection of the infinite lines will be detected.   l1x1 .. l2y2 - Points making up the two lines we wish to test.  For example,   l1x1, l1y1   is the position of the first point of the first line.  p1, p2, p3, p4 - Points making up the two lines we wish to test.    Valid point    { x = 10, y = 20 }     local x1,y1,x2,y2 = display.contentCenterX, display.contentCenterY-200, \n                    display.contentCenterX, display.contentCenterY+200\nlocal line1 = display.newLine( x1,y1,x2,y2 )\nline1.strokeWidth = 2\n\nlocal x3,y3,x4,y4 = display.contentCenterX-200, display.contentCenterY, \n                    display.contentCenterX + 200, display.contentCenterY\nlocal line2 = display.newLine( x3,y3,x4,y4 )\nline2.strokeWidth = 2\n\nlocal period = 60\nlocal deltaAngle = 5\nlocal startAngle = 0\nlocal endAngle = 360\nlocal angle = startAngle\nlocal marker\n\nlocal function testLineIntersect()\n    angle = angle + deltaAngle\n    display.remove(line2)\n    display.remove(marker)\n\n    if( angle   endAngle ) then         \n        return\n    end\n    local vec = angle2Vector( angle, true )\n    vec = scaleVec( vec, 250 )\n    vec.x = vec.x + x3\n    vec.y = vec.y + y3\n    line2 = display.newLine( x3, y3, vec.x, vec.y )\n    line2.strokeWidth = 2\n    local intersect = math2d.lineLineIntersect( x3, y3, vec.x, vec.y, x1, y1, x2, y2 )\n    if( intersect ) then \n        marker = display.newCircle( intersect.x, intersect.y, 10, true, true )\n        marker:setFillColor(0,1,0)\n    end\n\n    timer.performWithDelay( period, testLineIntersect )\nend\ntimer.performWithDelay( period, testLineIntersect )", 
            "title": "Line-Line Intersect"
        }, 
        {
            "location": "/libraries/math2D/#segment-segment-intersect", 
            "text": "math2d.segmentSegmentIntersect( s1x1, s1y1, s1x1, s1y2, s2x1, s2y1, s2x2, s2y2 )  Checks to see if two line segments intersect and if so where.   Returns two points   x, y   if an intersection occurs or nil meaning no intersection was found.  Note:  For most game implementations/tests you will want to use this instead of the line-line version as it is a true segment-segment test and only checks for intersections within the limited ranges of the two segments.   s1x1 .. s2y2 - Points making up the two lines we wish to test.  For example,   s1x1, s1y1   is the position of the first point of the first segment.   local x1,y1,x2,y2 = display.contentCenterX, display.contentCenterY-200, \n                    display.contentCenterX, display.contentCenterY+200\nlocal line1 = display.newLine( x1,y1,x2,y2 )\nline1.strokeWidth = 2\n\nlocal x3,y3,x4,y4 = display.contentCenterX-200, display.contentCenterY, \n                    display.contentCenterX + 200, display.contentCenterY\nlocal line2 = display.newLine( x3,y3,x4,y4 )\nline2.strokeWidth = 2\n\nlocal period = 60\nlocal deltaAngle = 5\nlocal startAngle = 0\nlocal endAngle = 360\nlocal angle = startAngle\nlocal marker\n\nlocal function testSegmentIntersect()\n    angle = angle + deltaAngle\n    display.remove(line2)\n    display.remove(marker)\n\n    if( angle   endAngle ) then         \n        return\n    end\n    local vec = angle2Vector( angle, true )\n    vec = scaleVec( vec, 250 )\n    vec.x = vec.x + x3\n    vec.y = vec.y + y3\n    line2 = display.newLine( x3, y3, vec.x, vec.y )\n    line2.strokeWidth = 2\n    local intersect = math2d.segmentSegmentIntersect( x3, y3, vec.x, vec.y , x1, y1, x2, y2 )\n    if( intersect ) then \n        print(intersect)\n        marker = display.newCircle( intersect.x, intersect.y, 10, true, true )\n        marker:setFillColor(0,1,0)\n    end\n\n    timer.performWithDelay( period, testSegmentIntersect )\nend\ntimer.performWithDelay( period, testSegmentIntersect )", 
            "title": "Segment-Segment Intersect"
        }, 
        {
            "location": "/libraries/math2D/#segment-circle-intersect", 
            "text": "math2d.segmentCircleIntersect( p1, p2, circle, radius )   Checks to see if the line segment defined by points  p1  and  p2  intersects with a  circle  of the specified  radius .  Possible returns:   nil - No intersections.  i1,  nil - Table containing point of first intersection and nil meaning no second intersection.  i1,  i2 - Tables containing points of first and second intersection. (This is the maximum possible number of intersections that can occur.)   Credit:  Derived from code by: Davis Claiborne (https://github.com/davisdude/mlib/blob/master/mlib.lua)   p1, p2 - Table vectors representing the endpoints of a line segment.  circle - Table or object representing the position of the circle.  radius - The radius of said circle.   local x1,y1,x2,y2 = display.contentCenterX, display.contentCenterY+200, \n                    display.contentCenterX, display.contentCenterY-200\nx1 = x1 - 150\nx2 = x2\nlocal line1 = display.newLine( x1,y1,x2,y2 )\nline1.strokeWidth = 2\n\nlocal p1 = { x = x1, y = y1 }\nlocal p2 = { x = x2, y = y2 }\n\nlocal circ = display.newCircle( display.contentCenterX, display.contentCenterY, 100 )\ncirc:setFillColor(0,0,0,0)\ncirc.strokeWidth = 2\n\nlocal i1, i2 = math2d.segmentCircleIntersect( { x = p1.x, y = p1.y}, \n                                               { x = p2.x, y = p2.y}, \n                                               circ, \n                                               100 )\n\nif( i1 ) then\n    local hit = display.newCircle( i1.x, i1.y, 10 )\n    hit:setFillColor(0,1,0)\nend\n\nif( i2 ) then\n    local hit = display.newCircle( i2.x, i2.y, 10 )\n    hit:setFillColor(0,1,0)\nend     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Segment-Circle Intersect"
        }, 
        {
            "location": "/libraries/meters/", 
            "text": "Meters (ssk.meters.*)\n\n\nTwo basic meters to help with debugging FPS and Memory issues.\n\n\nFPS Meter\n\n\n\n\nCreates an FPS meter in the upper-left corner of the screen.  This meter stays on top of all other content.\n\n\nssk.meters.create_fps( [ allowDrag ] )\n\n\n\n\n\n\nallowDrag - Setting this to \ntrue\n allows you to touch and drag the meter around.\n\n\n\n\nMemory Meter\n\n\n\n\nCreates a memory (main and video) meter in the upper-right corner of the screen.  This meter stays on top of all other content.\n\n\nssk.meters.create_mem( [ allowDrag ] )\n\n\n\n\n\n\nallowDrag - Setting this to \ntrue\n allows you to touch and drag the meter around.\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.meters.*"
        }, 
        {
            "location": "/libraries/meters/#meters-sskmeters", 
            "text": "Two basic meters to help with debugging FPS and Memory issues.", 
            "title": "Meters (ssk.meters.*)"
        }, 
        {
            "location": "/libraries/meters/#fps-meter", 
            "text": "Creates an FPS meter in the upper-left corner of the screen.  This meter stays on top of all other content.  ssk.meters.create_fps( [ allowDrag ] )   allowDrag - Setting this to  true  allows you to touch and drag the meter around.", 
            "title": "FPS Meter"
        }, 
        {
            "location": "/libraries/meters/#memory-meter", 
            "text": "Creates a memory (main and video) meter in the upper-right corner of the screen.  This meter stays on top of all other content.  ssk.meters.create_mem( [ allowDrag ] )   allowDrag - Setting this to  true  allows you to touch and drag the meter around.      Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Memory Meter"
        }, 
        {
            "location": "/libraries/misc/", 
            "text": "Miscellaneous (ssk.misc.*)\n\n\nThis is a grab bag of functions that simply didn't fit anywhere else.  \n\n\nHaving said that, I find many of these functions to be indispensable and I think you will too.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nblockTouchesForDuration\n\n\ncountLocals\n\n\neasyAlert\n\n\n\n\n\n\neasyBlur\n\n\neasyRemoteImage\n\n\neasyShake\n\n\n\n\n\n\neasyUnderline\n\n\nfitText\n\n\ngetImageSize\n\n\n\n\n\n\nisConnectedToWWW\n\n\nisValidEmail\n\n\noBottom\n\n\n\n\n\n\noHorizCenter\n\n\noLeft\n\n\noRight\n\n\n\n\n\n\noTop\n\n\noVertCenter\n\n\nrotateAbout \n\n\n\n\n\n\nsecondsToTimer\n\n\n\n\n\n\n\n\n\n\n\n\nblockTouchesForDuration\n\n\n\n\nssk.misc.blockTouchesForDuration( [ duration [ , subtle ] ] )\n - Creates a temporary display object that will block all touches for \nduration\n (\n1000\n).     \n\n\nBy default, the blocker is black and up-fades from 0% to 50% opaque over 350 ms.  However, if you want to hide this effect, set subtle to \ntrue\n.\n\n\n\n\n\n\n\n\ncountLocals\n\n\n\n\nssk.misc.countLocals()\n - This debug feature prints out the number of local variables that are in scope at the line where you call the function.  \n\n\nLua has a limit of 200 locals in scope at any one time.  This function lets you check for how close you are.\n\n\nOnly works in simulator since it requires the 'debug' library which is not included on devices.\n\n\n\n\n\n\n\n\neasyAlert\n\n\n\n\nssk.misc.easyAlert( title, msg, buttons )\n - A simplified 'dialog' builder that uses \nnative.showAlert()\n to create a pop-up dialog.  \n\n\ntitle\n - Text at top of dialog box.  \n\n\nmsg\n - Body of message.  Multiple lines and line-breaks (\n\\n\n) allowed.\n\n\nbuttons - Table of buttons and optional functions they call when pressed.\n\n\n\n\n\n\n\n\n\nlocal function doDelete()\n    -- Delete the player.\nend\n\neasyAlert( \nDelete Player\n, \n            \nAre you sure you want to delete this player?\n,\n             { { \nYes!\n, doDelete }, {\nNever Mind\n, nil } } )\n\n\n\n\n\neasyBlur\n\n\n\n\nssk.misc.easyBlur( [ group, [ time, [ color, [ params ] ] ]  )\n - Create a display object that is a blurred image of what was on the screen when this function was called.\n\n\ngroup\n (\ndisplay.currentStage\n) - Insert blur object into this group.\n\n\ntime\n (\n0\n) - Time it takes (in millseconds) for the blur to fade in from \nalpha == 0\n.\n\n\ncolor\n (\n{0.5,0.5,0.5}\n) - Shade blur object with this fill color.\n\n\nparams\n (\n{ touchEn = true }\n) - Table of additional options.\n\n\ntouchEn\n - If \ntrue\n, touching the screen will fade the blur object our over \ntime\n then delete it.\n\n\nonComplete( obj )\n - Reference to custom function that is called when blur is about to be removed.\n\n\nblurGaussian\n properties.  The blur uses this filter and you can adjust all of its properties if you want.\n\n\n\n\n\n\n\n\n\n\n\n\neasyRemoteImage\n\n\n\n\nssk.misc.easyRemoteImage( curImg, fileName, imageURL, baseDirectory )\n - With this function you can fill an existing display object with a remote image.  You simply call this function and when the download is complete, the existing \ncurImg\n object will be filled with the remote image file.  \n\n\ncurImg\n - Display object to be filled with remote image.  \n\n\nTip:\n I usually fill this object with a local placeholder image so it looks professional till the image is received.\n\n\n\n\n\n\nfileName\n - Name to save image in.\n\n\nimageURL\n - Web path to image.\n\n\nbaseDirectory\n (\nsystem.TemporaryDirectory\n) - Base type of directory.\n\n\n\n\n\n\n\n\neasyShake\n\n\n\n\nssk.misc.easyShake( obj, amplitude, time )\n - Shake any object of the entire screen.  Nice juicy effect!\n\n\nobj\n (\ndisplay.currentStage\n) - Object or group to shake.\n\n\namplitude\n (\n100\n) - How much to shake.\n\n\ntime\n (\n1000\n) - How long to shake for.\n\n\nCredit: \nForum Post - Simple shake easing code and demo\n (\nexternal link\n)\n\n\n\n\n\n\n\n\neasyUnderline\n\n\n\n\nssk.misc.easyUnderline( obj, [ color, [ strokeWidth, [ extraWidth, [ yOffset ]]]] )\n - Draw a line under any object. I use this for text objects mostly.\n\n\nobj\n - Object to 'underline'.  Line length is automatically as wide as this object.\n\n\ncolor\n (\n_W_\n) - Color of line.\n\n\nstrokeWidth\n (\n1\n) - Stroke width of line.   \n\n\nextraWidth\n (\n0\n) - Make the line longer by this many pixels.\n\n\nyOffset\n (\n0\n) - Adjust the calculated y-position by this many pixels.  By default, the line is aligned to the bottom edge of the display object \nobj\n.\n\n\n\n\n\n\n\n\nfitText\n\n\n\n\nssk.misc.fitText( obj, origText, maxWidth )\n - Reduces the length of a string till the text object \nobj\n fits \nmaxWidth\n (pixels). \norigText\n is the initial string value of \nobj\n.\n\n\n\n\ngetImageSize\n\n\n\n\nssk.misc.getImageSize ( path [ , basePath ] )\n - Returns \nwidth\n, \nheight\n of an image.\n\n\npath\n - File name path including name of file.\n\n\nbasePath\n (\nsystem.ResourceDirectory\n) - Base type of file path.\n\n\n\n\n\n\n\n\nisConnectedToWWW\n\n\n\n\nssk.misc.isConnectedToWWW( [url] )\n - Checks to see if \nurl\n can be reached.  Default is \n\"www.google.com\"\n\n\n\n\nisValidEmail\n\n\n\n\nssk.misc.isValidEmail ( val )\n - Returns true if \nval\n \nseems\n like a valid email address.\n\n\n\n\nEdges and Centers\n\n\nTip:\n The following x-/y- position finders do not care what the anchors are.\n\n\n\n\nssk.misc.oBottom( obj )\n - Returns pixel y-position object \nobj\n bottom.\n\n\nssk.misc.oHorizCenter( obj )\n - Returns pixel x-position of object \nobj\n center.\n\n\nssk.misc.oLeft( obj )\n - Returns pixel x-position of object \nobj\n left.\n\n\nssk.misc.oRight( obj )\n - Returns pixel x-position of object \nobj\n right.\n\n\nssk.misc.oTop( obj )\n - Returns pixel y-position of object \nobj\n top.\n\n\nssk.misc.oVertCenter( obj )\n - Returns pixel y-position of object \nobj\n center.\n\n\n\n\nrotateAbout\n\n\n\n\nssk.misc.rotateAbout( obj, [ x, [ y, [ params ]]] )\n - Rotate object \nobj\n about the point \nx\n,\ny\n.\n\n\nobj\n - Object to rotate about a point.\n\n\nx\n, \ny\n (\ncenterX\n, \ncenterY\n) - The point.\n\n\nparams\n - Table of options controlling the rotate:\n\n\nradius\n (\n50\n) - Radius of rotation path.\n\n\nstartA\n (\n0\n) - Start at this rotation angle, where \n0\n is up, \n90\n is right, etc.\n\n\nendA\n (\nstartA + 360\n) - End at this rotation angle.\n\n\ntime\n (\n1000\n) - Take this long to rotate.\n\n\ndelay\n (\n0\n) - Wait this long to start rotating.\n\n\nmyEasing\n (\neasing.linear\n) - Use this transition easing.\n\n\ndebugEn\n (\nfalse\n) - Draw circles along path as rotation occurs.\n\n\nonComplete( obj )\n (\nnil\n) - Call this function when the rotation completes.\n\n\n\n\n\n\n\n\n\n\n\n\nsecondsToTimer\n\n\n\n\nssk.misc.secondsToTimer( [ seconds, [ version ] ] )\n - Converts \nseconds\n into one of three different time formats.\n\n\nseconds\n (\n0\n) - Count of seconds to convert to a timer format.\n\n\nseconds\n (\n1\n) - Timer format to produce.\n\n\n1\n - Return string with this format: \n\"minutes:seconds\"\n\n\n2\n - Return string with this format: \n\"hours:minutes.seconds\"\n\n\n3\n - Return four strings: \n\"days\"\n, \n\"hours\"\n, \n\"minutes\"\n, \n\"seconds\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.misc.*"
        }, 
        {
            "location": "/libraries/misc/#miscellaneous-sskmisc", 
            "text": "This is a grab bag of functions that simply didn't fit anywhere else.    Having said that, I find many of these functions to be indispensable and I think you will too.            blockTouchesForDuration  countLocals  easyAlert    easyBlur  easyRemoteImage  easyShake    easyUnderline  fitText  getImageSize    isConnectedToWWW  isValidEmail  oBottom    oHorizCenter  oLeft  oRight    oTop  oVertCenter  rotateAbout     secondsToTimer", 
            "title": "Miscellaneous (ssk.misc.*)"
        }, 
        {
            "location": "/libraries/misc/#blocktouchesforduration", 
            "text": "ssk.misc.blockTouchesForDuration( [ duration [ , subtle ] ] )  - Creates a temporary display object that will block all touches for  duration  ( 1000 ).       By default, the blocker is black and up-fades from 0% to 50% opaque over 350 ms.  However, if you want to hide this effect, set subtle to  true .", 
            "title": "blockTouchesForDuration"
        }, 
        {
            "location": "/libraries/misc/#countlocals", 
            "text": "ssk.misc.countLocals()  - This debug feature prints out the number of local variables that are in scope at the line where you call the function.    Lua has a limit of 200 locals in scope at any one time.  This function lets you check for how close you are.  Only works in simulator since it requires the 'debug' library which is not included on devices.", 
            "title": "countLocals"
        }, 
        {
            "location": "/libraries/misc/#easyalert", 
            "text": "ssk.misc.easyAlert( title, msg, buttons )  - A simplified 'dialog' builder that uses  native.showAlert()  to create a pop-up dialog.    title  - Text at top of dialog box.    msg  - Body of message.  Multiple lines and line-breaks ( \\n ) allowed.  buttons - Table of buttons and optional functions they call when pressed.     \nlocal function doDelete()\n    -- Delete the player.\nend\n\neasyAlert(  Delete Player , \n             Are you sure you want to delete this player? ,\n             { {  Yes! , doDelete }, { Never Mind , nil } } )", 
            "title": "easyAlert"
        }, 
        {
            "location": "/libraries/misc/#easyblur", 
            "text": "ssk.misc.easyBlur( [ group, [ time, [ color, [ params ] ] ]  )  - Create a display object that is a blurred image of what was on the screen when this function was called.  group  ( display.currentStage ) - Insert blur object into this group.  time  ( 0 ) - Time it takes (in millseconds) for the blur to fade in from  alpha == 0 .  color  ( {0.5,0.5,0.5} ) - Shade blur object with this fill color.  params  ( { touchEn = true } ) - Table of additional options.  touchEn  - If  true , touching the screen will fade the blur object our over  time  then delete it.  onComplete( obj )  - Reference to custom function that is called when blur is about to be removed.  blurGaussian  properties.  The blur uses this filter and you can adjust all of its properties if you want.", 
            "title": "easyBlur"
        }, 
        {
            "location": "/libraries/misc/#easyremoteimage", 
            "text": "ssk.misc.easyRemoteImage( curImg, fileName, imageURL, baseDirectory )  - With this function you can fill an existing display object with a remote image.  You simply call this function and when the download is complete, the existing  curImg  object will be filled with the remote image file.    curImg  - Display object to be filled with remote image.    Tip:  I usually fill this object with a local placeholder image so it looks professional till the image is received.    fileName  - Name to save image in.  imageURL  - Web path to image.  baseDirectory  ( system.TemporaryDirectory ) - Base type of directory.", 
            "title": "easyRemoteImage"
        }, 
        {
            "location": "/libraries/misc/#easyshake", 
            "text": "ssk.misc.easyShake( obj, amplitude, time )  - Shake any object of the entire screen.  Nice juicy effect!  obj  ( display.currentStage ) - Object or group to shake.  amplitude  ( 100 ) - How much to shake.  time  ( 1000 ) - How long to shake for.  Credit:  Forum Post - Simple shake easing code and demo  ( external link )", 
            "title": "easyShake"
        }, 
        {
            "location": "/libraries/misc/#easyunderline", 
            "text": "ssk.misc.easyUnderline( obj, [ color, [ strokeWidth, [ extraWidth, [ yOffset ]]]] )  - Draw a line under any object. I use this for text objects mostly.  obj  - Object to 'underline'.  Line length is automatically as wide as this object.  color  ( _W_ ) - Color of line.  strokeWidth  ( 1 ) - Stroke width of line.     extraWidth  ( 0 ) - Make the line longer by this many pixels.  yOffset  ( 0 ) - Adjust the calculated y-position by this many pixels.  By default, the line is aligned to the bottom edge of the display object  obj .", 
            "title": "easyUnderline"
        }, 
        {
            "location": "/libraries/misc/#fittext", 
            "text": "ssk.misc.fitText( obj, origText, maxWidth )  - Reduces the length of a string till the text object  obj  fits  maxWidth  (pixels).  origText  is the initial string value of  obj .", 
            "title": "fitText"
        }, 
        {
            "location": "/libraries/misc/#getimagesize", 
            "text": "ssk.misc.getImageSize ( path [ , basePath ] )  - Returns  width ,  height  of an image.  path  - File name path including name of file.  basePath  ( system.ResourceDirectory ) - Base type of file path.", 
            "title": "getImageSize"
        }, 
        {
            "location": "/libraries/misc/#isconnectedtowww", 
            "text": "ssk.misc.isConnectedToWWW( [url] )  - Checks to see if  url  can be reached.  Default is  \"www.google.com\"", 
            "title": "isConnectedToWWW"
        }, 
        {
            "location": "/libraries/misc/#isvalidemail", 
            "text": "ssk.misc.isValidEmail ( val )  - Returns true if  val   seems  like a valid email address.", 
            "title": "isValidEmail"
        }, 
        {
            "location": "/libraries/misc/#edges-and-centers", 
            "text": "Tip:  The following x-/y- position finders do not care what the anchors are.   ssk.misc.oBottom( obj )  - Returns pixel y-position object  obj  bottom.  ssk.misc.oHorizCenter( obj )  - Returns pixel x-position of object  obj  center.  ssk.misc.oLeft( obj )  - Returns pixel x-position of object  obj  left.  ssk.misc.oRight( obj )  - Returns pixel x-position of object  obj  right.  ssk.misc.oTop( obj )  - Returns pixel y-position of object  obj  top.  ssk.misc.oVertCenter( obj )  - Returns pixel y-position of object  obj  center.", 
            "title": "Edges and Centers"
        }, 
        {
            "location": "/libraries/misc/#rotateabout", 
            "text": "ssk.misc.rotateAbout( obj, [ x, [ y, [ params ]]] )  - Rotate object  obj  about the point  x , y .  obj  - Object to rotate about a point.  x ,  y  ( centerX ,  centerY ) - The point.  params  - Table of options controlling the rotate:  radius  ( 50 ) - Radius of rotation path.  startA  ( 0 ) - Start at this rotation angle, where  0  is up,  90  is right, etc.  endA  ( startA + 360 ) - End at this rotation angle.  time  ( 1000 ) - Take this long to rotate.  delay  ( 0 ) - Wait this long to start rotating.  myEasing  ( easing.linear ) - Use this transition easing.  debugEn  ( false ) - Draw circles along path as rotation occurs.  onComplete( obj )  ( nil ) - Call this function when the rotation completes.", 
            "title": "rotateAbout"
        }, 
        {
            "location": "/libraries/misc/#secondstotimer", 
            "text": "ssk.misc.secondsToTimer( [ seconds, [ version ] ] )  - Converts  seconds  into one of three different time formats.  seconds  ( 0 ) - Count of seconds to convert to a timer format.  seconds  ( 1 ) - Timer format to produce.  1  - Return string with this format:  \"minutes:seconds\"  2  - Return string with this format:  \"hours:minutes.seconds\"  3  - Return four strings:  \"days\" ,  \"hours\" ,  \"minutes\" ,  \"seconds\"          Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "secondsToTimer"
        }, 
        {
            "location": "/libraries/persist/", 
            "text": "Persistent Data (ssk.persist.*)\n\n\nThis library provides a handy way to automatically save and restore (persist) data.\n\n\nCurrently this feature works on all platforms, excluding Apple TV.\n\n\n\n\nApple TV support will be added in the future. - The Roaming Gamer\n\n\n\n\nSetting Default Values\n\n\nThe \nssk.persist\n library lets you set 'default' values for any named field.  This way, if you call \nget()\n for a named field before you \nset()\n it, you will get a valid value.\n\n\nTo set a defaut value for a field in a persistent data set, use this function:\n\n\nssk.persist.setDefault( fileName, fieldName, value [ , params ] )\n\n\n\n\n\n\nfileName\n - Name of file to save persistent data in.\n\n\nfieldName\n - Name of setting to set default for.\n\n\nvalue\n - Value to set as default for \nfieldName\n.\n\n\nparams\n (\n{}\n) - Optional table of parameters.\n\n\nsave\n (\ntrue\n) - Save immediately to file.\n\n\nbase\n (\nsystem.DocumentsDirectory\n) - Base folder type for save file.\n\n\n\n\n\n\n\n\nSetting and Getting Values\n\n\nUse these functions set and get values respectively:\n\n\nssk.persist.set( fileName, fieldName, value [ , params ] )\n\nssk.persist.get( fileName, fieldName [ , params ] )\n\n\n\n\n\n\nfileName\n - Name of file to save persistent data in.\n\n\nfieldName\n - Name of setting to set default for.\n\n\nvalue\n - Value to set as default for \nfieldName\n.\n\n\nparams\n (\n{}\n) - Optional table of parameters.\n\n\nsave\n (\ntrue\n) - Save immediately to file.\n\n\nbase\n (\nsystem.DocumentsDirectory\n) - Base folder type for save file.\n\n\n\n\n\n\n\n\nSetting Secure Mode\n\n\nIf you wish, you can ask \nssk.persist\n to use the \nssk.security\n module when saving and loading data with this function:\n\n\nssk.persist.setSecure()\n\n\n\n\nJust be sure you turn on \nsecure mode\n before you first use the module.  (See \nComplete Example\n below.)\n\n\nMultiple Sets Allowed?\n\n\nAs you may have determined already, this module supports multiple separate data sets.  Simply use different names for the \nfileName\n setting and your data will be separated into independent sets.   (See \nComplete Example\n below.)\n\n\nData Caching\n\n\nThis library utilizes caching to speed up data accesses.\n\n\nWhenever a persistent data set is mofified the following checks occur:\n\n\n\n\nIs data cached?  \n\n\nIf not, load it from file or create blank record.\n\n\nCache data in persist module.\n\n\n\n\n\n\nIs there a value for the field user is accessing?\n\n\nIf not, and if there is a default set,\n\n\nSet field in cached copy to default\n\n\nReturn default value.\n\n\n\n\n\n\n\n\n\n\nDid user set \nsave\n parameter to \nfalse\n?\n\n\nIf not, save cached data immediately\n\n\n\n\n\n\n\n\n\n\nI will be modifying this slightly in the future to handle back to back set/setDefault calls with save set to true.\nThis modification will prevent these saves from blocking and affecting frame rate.\n\n\n\n\nComplete Persist Example\n\n\nThe following example shows a example usage with automatic \nsecure mode\n enabling when on device.\n\n\n\n-- Enable secure mode if on device, but use un-encoded saves when on the simulator\n-- Tip: This makes checking your saves and hand-modifying them easy while testing in the simulator.\n--\nif( ssk.system.onDevice ) then\n   ssk.persist.setSecure()\nend\n\n-- Set up two data sets with defaults\n--\nssk.persist.setDefault( \niap.json\n, \ndisabled_ads\n, false , { save = false } )\nssk.persist.setDefault( \niap.json\n, \nbought_extra_content\n, false )\n\nssk.persist.setDefault( \nsettings.json\n, \nsound_enabled\n, true, { save = false } )\nssk.persist.setDefault( \nsettings.json\n, \nlast_score\n, 0 )\n\n-- Check persistent data fields\nprint( \nAds disabled? \n, ssk.persist( \niap.json\n, \ndisabled_ads\n) )\n\nprint( \nLast Score: \n, ssk.persist( \nsettings.json\n, \nlast_score\n ) )\n\n-- Set 'last score' to a random value\nssk.persist.set( \nsettings.json\n, \nlast_score\n, math.random(100, 10000) )\n\n-- Check persistent data fields again\nprint( \nAds disabled? \n, ssk.persist( \niap.json\n, \ndisabled_ads\n) )\n\nprint( \nLast Score: \n, ssk.persist( \nsettings.json\n, \nlast_score\n ) )\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.persist.*"
        }, 
        {
            "location": "/libraries/persist/#persistent-data-sskpersist", 
            "text": "This library provides a handy way to automatically save and restore (persist) data.  Currently this feature works on all platforms, excluding Apple TV.   Apple TV support will be added in the future. - The Roaming Gamer", 
            "title": "Persistent Data (ssk.persist.*)"
        }, 
        {
            "location": "/libraries/persist/#setting-default-values", 
            "text": "The  ssk.persist  library lets you set 'default' values for any named field.  This way, if you call  get()  for a named field before you  set()  it, you will get a valid value.  To set a defaut value for a field in a persistent data set, use this function:  ssk.persist.setDefault( fileName, fieldName, value [ , params ] )   fileName  - Name of file to save persistent data in.  fieldName  - Name of setting to set default for.  value  - Value to set as default for  fieldName .  params  ( {} ) - Optional table of parameters.  save  ( true ) - Save immediately to file.  base  ( system.DocumentsDirectory ) - Base folder type for save file.", 
            "title": "Setting Default Values"
        }, 
        {
            "location": "/libraries/persist/#setting-and-getting-values", 
            "text": "Use these functions set and get values respectively:  ssk.persist.set( fileName, fieldName, value [ , params ] )\n\nssk.persist.get( fileName, fieldName [ , params ] )   fileName  - Name of file to save persistent data in.  fieldName  - Name of setting to set default for.  value  - Value to set as default for  fieldName .  params  ( {} ) - Optional table of parameters.  save  ( true ) - Save immediately to file.  base  ( system.DocumentsDirectory ) - Base folder type for save file.", 
            "title": "Setting and Getting Values"
        }, 
        {
            "location": "/libraries/persist/#setting-secure-mode", 
            "text": "If you wish, you can ask  ssk.persist  to use the  ssk.security  module when saving and loading data with this function:  ssk.persist.setSecure()  Just be sure you turn on  secure mode  before you first use the module.  (See  Complete Example  below.)", 
            "title": "Setting Secure Mode"
        }, 
        {
            "location": "/libraries/persist/#multiple-sets-allowed", 
            "text": "As you may have determined already, this module supports multiple separate data sets.  Simply use different names for the  fileName  setting and your data will be separated into independent sets.   (See  Complete Example  below.)", 
            "title": "Multiple Sets Allowed?"
        }, 
        {
            "location": "/libraries/persist/#data-caching", 
            "text": "This library utilizes caching to speed up data accesses.  Whenever a persistent data set is mofified the following checks occur:   Is data cached?    If not, load it from file or create blank record.  Cache data in persist module.    Is there a value for the field user is accessing?  If not, and if there is a default set,  Set field in cached copy to default  Return default value.      Did user set  save  parameter to  false ?  If not, save cached data immediately      I will be modifying this slightly in the future to handle back to back set/setDefault calls with save set to true.\nThis modification will prevent these saves from blocking and affecting frame rate.", 
            "title": "Data Caching"
        }, 
        {
            "location": "/libraries/persist/#complete-persist-example", 
            "text": "The following example shows a example usage with automatic  secure mode  enabling when on device.  \n-- Enable secure mode if on device, but use un-encoded saves when on the simulator\n-- Tip: This makes checking your saves and hand-modifying them easy while testing in the simulator.\n--\nif( ssk.system.onDevice ) then\n   ssk.persist.setSecure()\nend\n\n-- Set up two data sets with defaults\n--\nssk.persist.setDefault(  iap.json ,  disabled_ads , false , { save = false } )\nssk.persist.setDefault(  iap.json ,  bought_extra_content , false )\n\nssk.persist.setDefault(  settings.json ,  sound_enabled , true, { save = false } )\nssk.persist.setDefault(  settings.json ,  last_score , 0 )\n\n-- Check persistent data fields\nprint(  Ads disabled?  , ssk.persist(  iap.json ,  disabled_ads ) )\n\nprint(  Last Score:  , ssk.persist(  settings.json ,  last_score  ) )\n\n-- Set 'last score' to a random value\nssk.persist.set(  settings.json ,  last_score , math.random(100, 10000) )\n\n-- Check persistent data fields again\nprint(  Ads disabled?  , ssk.persist(  iap.json ,  disabled_ads ) )\n\nprint(  Last Score:  , ssk.persist(  settings.json ,  last_score  ) )     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Complete Persist Example"
        }, 
        {
            "location": "/libraries/points/", 
            "text": "Points Library (ssk.points.*)\n\n\nThis is a general Lua library for creating lists of points \n{ x = value, y = value }\n.\n\n\nThese lists are used by the \nLine Factories\n, but may be useful in other contexts too.\n\n\nCreating a Points List\n\n\nYou can create a new points list with this function, which returns a \npoints instance\n.\n\n\nssk.points.new( ... )\n\n\n\n\n\n\n...\n - Optional sequence of x, y values to initialized the points list with.\n\n\n\n\n\n-- Create a points list with these points: \n--  { x = 10, y = 10 }\n--  { x = 20, y = 20 }\n--  { x = 15, y = 35 }\n--\nlocal pointsList = ssk.points.new( 10, 10, 20, 20, 15, 35 )\n\n\n\n\n\nTip:\n Points lists are numerically indexed tables, so you can do things like this:\n\n\n\nfor 1 = 1, #pointsList do\n   print( \nX @ index \n .. i .. \n == \n .. tostring( pointsList[i].x ) )\n   print( \nY @ index \n .. i .. \n == \n .. tostring( pointsList[i].y ) )\nend\n\n\n\n\n\nWarning:\n Points lists cannot be saved to JSON because they have functions attached to them.\n\n\nPoints Instance Methods\n\n\nPoints list instances have all of these methods:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nadd(...)\n\n\nAdd new points using x, y pairs (\n...\n)\n\n\n\n\n\n\ninsert(index, ...)\n\n\nInsert x, y pairs in list \n...\n to curent point list starting at \nindex\n.\n\n\n\n\n\n\nget(index)\n\n\nReturns point (as table) at \nindex\n in list, or \nnil\n if no such \nindex\n exists.\n\n\n\n\n\n\nremove(index)\n\n\nRemove point (x, y pair) at \nindex\n from list.\n\n\n\n\n\n\npush(...)\n\n\nAdd a new point(s) at end of list.\n\n\n\n\n\n\npeek()\n\n\nGet point from end of list without removing it from the list.  Returns \nnil\n if list is empty.\n\n\n\n\n\n\npop()\n\n\nLike \npeek()\n, but removes point from list at same time.\n\n\n\n\n\n\npush_head(...)\n\n\nAdd new point(s) to beginning of list.  Synonym for \nadd( 1, ... )\n.\n\n\n\n\n\n\npeek_head()\n\n\nGet point from beginning (index 1) of the list.  Returns \nnil\n if list is empty.\n\n\n\n\n\n\npop_head( )\n\n\nLike \npeek_head()\n, but removes point from list at same time.\n\n\n\n\n\n\n\n\nComplete Points Example\n\n\n\n-- 1. Create blank list\nlocal pointsList = ssk.points.new( )\n\n-- 2.  Add points\npointsList:add( 15, 35 )\n\n-- Points list is now:\n--  { x = 15, y = 35 }\n\n-- 3. Insert points at index 1\npointsList:insert( 1, 10, 10, 20, 20 )\n\n-- Points list is now:\n--  { x = 10, y = 10 }\n--  { x = 20, y = 20 }\n--  { x = 15, y = 35 }\n\n-- 4. Pop Head\npointsList:pop_head()\n\n-- Points list is now:\n--  { x = 20, y = 20 }\n--  { x = 15, y = 35 }\n\n-- 5. Pop Tail\npointsList:pop()\n\n-- Points list is now:\n--  { x = 20, y = 20 }\n\n-- 6. Push Point to Tail\npointsList:push( 10, 10 )\n\n-- Points list is now:\n--  { x = 20, y = 20 }\n--  { x = 10, y = 10 }\n\n-- 7. Push Point to Head\npointsList:push_head( 15, 25 )\n\n-- Points list is now:\n--  { x = 15, y = 25 }\n--  { x = 20, y = 20 }\n--  { x = 10, y = 10 }\n\n-- 8. Dump the Points\nfor i = 1, #pointsList do\n    table.dump(pointsList:get(i), nil, \nIndex: \n .. tostring(i) )\nend\n\n\n\n\n\nWhen executed, the above code prints (something like) this in the console:\n\n\n\n22:01:20.583  Table Dump:\n22:01:20.583  -----\n22:01:20.583  x (string)                     == 15 (number)                   \n22:01:20.583  y (string)                     == 25 (number)                   \n22:01:20.583  Index: 1-----\n22:01:20.583  \n22:01:20.583  Table Dump:\n22:01:20.583  -----\n22:01:20.583  x (string)                     == 20 (number)                   \n22:01:20.583  y (string)                     == 20 (number)                   \n22:01:20.583  Index: 2-----\n22:01:20.583  \n22:01:20.583  Table Dump:\n22:01:20.583  -----\n22:01:20.583  x (string)                     == 10 (number)                   \n22:01:20.583  y (string)                     == 10 (number)                   \n22:01:20.583  Index: 3-----\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.points.*"
        }, 
        {
            "location": "/libraries/points/#points-library-sskpoints", 
            "text": "This is a general Lua library for creating lists of points  { x = value, y = value } .  These lists are used by the  Line Factories , but may be useful in other contexts too.", 
            "title": "Points Library (ssk.points.*)"
        }, 
        {
            "location": "/libraries/points/#creating-a-points-list", 
            "text": "You can create a new points list with this function, which returns a  points instance .  ssk.points.new( ... )   ...  - Optional sequence of x, y values to initialized the points list with.   \n-- Create a points list with these points: \n--  { x = 10, y = 10 }\n--  { x = 20, y = 20 }\n--  { x = 15, y = 35 }\n--\nlocal pointsList = ssk.points.new( 10, 10, 20, 20, 15, 35 )  Tip:  Points lists are numerically indexed tables, so you can do things like this:  \nfor 1 = 1, #pointsList do\n   print(  X @ index   .. i ..   ==   .. tostring( pointsList[i].x ) )\n   print(  Y @ index   .. i ..   ==   .. tostring( pointsList[i].y ) )\nend  Warning:  Points lists cannot be saved to JSON because they have functions attached to them.", 
            "title": "Creating a Points List"
        }, 
        {
            "location": "/libraries/points/#points-instance-methods", 
            "text": "Points list instances have all of these methods:           add(...)  Add new points using x, y pairs ( ... )    insert(index, ...)  Insert x, y pairs in list  ...  to curent point list starting at  index .    get(index)  Returns point (as table) at  index  in list, or  nil  if no such  index  exists.    remove(index)  Remove point (x, y pair) at  index  from list.    push(...)  Add a new point(s) at end of list.    peek()  Get point from end of list without removing it from the list.  Returns  nil  if list is empty.    pop()  Like  peek() , but removes point from list at same time.    push_head(...)  Add new point(s) to beginning of list.  Synonym for  add( 1, ... ) .    peek_head()  Get point from beginning (index 1) of the list.  Returns  nil  if list is empty.    pop_head( )  Like  peek_head() , but removes point from list at same time.", 
            "title": "Points Instance Methods"
        }, 
        {
            "location": "/libraries/points/#complete-points-example", 
            "text": "-- 1. Create blank list\nlocal pointsList = ssk.points.new( )\n\n-- 2.  Add points\npointsList:add( 15, 35 )\n\n-- Points list is now:\n--  { x = 15, y = 35 }\n\n-- 3. Insert points at index 1\npointsList:insert( 1, 10, 10, 20, 20 )\n\n-- Points list is now:\n--  { x = 10, y = 10 }\n--  { x = 20, y = 20 }\n--  { x = 15, y = 35 }\n\n-- 4. Pop Head\npointsList:pop_head()\n\n-- Points list is now:\n--  { x = 20, y = 20 }\n--  { x = 15, y = 35 }\n\n-- 5. Pop Tail\npointsList:pop()\n\n-- Points list is now:\n--  { x = 20, y = 20 }\n\n-- 6. Push Point to Tail\npointsList:push( 10, 10 )\n\n-- Points list is now:\n--  { x = 20, y = 20 }\n--  { x = 10, y = 10 }\n\n-- 7. Push Point to Head\npointsList:push_head( 15, 25 )\n\n-- Points list is now:\n--  { x = 15, y = 25 }\n--  { x = 20, y = 20 }\n--  { x = 10, y = 10 }\n\n-- 8. Dump the Points\nfor i = 1, #pointsList do\n    table.dump(pointsList:get(i), nil,  Index:   .. tostring(i) )\nend  When executed, the above code prints (something like) this in the console:  \n22:01:20.583  Table Dump:\n22:01:20.583  -----\n22:01:20.583  x (string)                     == 15 (number)                   \n22:01:20.583  y (string)                     == 25 (number)                   \n22:01:20.583  Index: 1-----\n22:01:20.583  \n22:01:20.583  Table Dump:\n22:01:20.583  -----\n22:01:20.583  x (string)                     == 20 (number)                   \n22:01:20.583  y (string)                     == 20 (number)                   \n22:01:20.583  Index: 2-----\n22:01:20.583  \n22:01:20.583  Table Dump:\n22:01:20.583  -----\n22:01:20.583  x (string)                     == 10 (number)                   \n22:01:20.583  y (string)                     == 10 (number)                   \n22:01:20.583  Index: 3-----     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Complete Points Example"
        }, 
        {
            "location": "/libraries/security/", 
            "text": "Simple Security (ssk.security.*)\n\n\nThis library gives you security without using heavy-weight and restricted encryption technologies.\n\n\nThe purpose of this module is to make it difficult for end-users to read and modify saved files.  It is great for obfuscating game settings like score, IAP purchase flags, etc.\n\n\nThis library uses a substitution-cypher to encode and decode strings.  \n\n\nWhile difficult to crack, this is \nNOT STRONG\n security.  It should not be used to secure sensitive data.  \n\n\nSecurity Operations (ssk.security:*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngenKey\n\n\n\n\n\n\n\n\nencode\n\n\ndecode\n\n\n\n\n\n\nsaveKey\n\n\nloadKey\n\n\n\n\n\n\nprintKeyString\n\n\nloadKeyFromKeyString\n\n\n\n\n\n\ngetKeyString\n\n\n\n\n\n\n\n\n\n\nGenerating A Key\n\n\nAfter exeucuting this code, the security module will be using a new randomly generated key (cypher):\n\n\n\nssk.security.genKey() \n\n\n\n\n\nEncoding\n\n\nTo encode a string with the current key (cypher) do this:\n\n\n\nlocal origString = \nThis is a random string 1234567890.\n\n\nlocal encodedString = ssk.security.encode( origString )\n\n\n\n\n\nNow, \nencodedString\n contains a obfuscated version of \norigString\n.\n\n\nDecoding\n\n\nTo decode a previously obfuscated string:\n\n\n\nlocal decodedString = ssk.security.decode( encodedString )\n\n\n\n\n\nAssuming \nssk.security\n was configured with the same key (cypher) used to encode  \nencodedString\n, \ndecodedString\n will now contain the original un-encoded string.\n\n\nSaving A Key\n\n\nYou can save the current key (cypher) to a file with this function:\n\n\nssk.security.saveKey( fileName [ , base  ])\n\n\n\n\n\n\nfileName\n - File to save key in.\n\n\nbase\n (\nsystem.DocumentsDirectory\n) - Base folder for key file.\n\n\n\n\nExample\n\n\n\n-- Save current key as file key.json (in system.DocumentsDirectory) \nssk.security.saveKey( \nkey.json\n )\n\n\n\n\n\nRestoring A Key\n\n\nYou can restoring a key (cypher) from a key previously stored in a file with this function\n\n\nssk.security.loadKey( fileName [ , base  ])\n\n\n\n\n\n\nfileName\n - File to load key from.\n\n\nbase\n (\nsystem.DocumentsDirectory\n) - Base folder for key file.\n\n\n\n\nExample\n\n\n\n-- Load key from file key.json (in system.DocumentsDirectory) \nssk.security.loadKey( \nkey.json\n )\n\n\n\n\n\nAssuming \nssk.security\n was configured with the same key (cypher) used to encode  \nencodedString\n, \ndecodedString\n will now contain the original un-encoded string.\n\n\nEmbedding A Key\n\n\nInstead of saving and loading to/from a file, you may find it easier to embed a key right in your app/game code.\n\n\nTo do this, follow these steps:\n\n\n1. Generate \n Print Key\n\n\nDo this in the simulator:\n\n\n\n-- Generate random key\nssk.security.genKey() \n\n-- Print To Console\nssk.security.printKeyString() \n\n\n\n\n\n2. Get Key From Console\n\n\nLook in your console and find a statement like this:\n\n\n21:20:38.762  'a\nbKc=d e.f;goh:ijj]ktlPmzn\nolpWqQrFsHtau`v!wSxEyRzsAMB0CCDTE8FUGrHYI6J-KhL[MANcO9PfQ5RnSpTbU@VdW\nXZYwZI1}2k3)4g5_6(728O9?0m!i@##V$%%{^y\nN*B(v)$_++D-^=4`3~* G,u.x\ne\n7[1]L{X}~/q?|;J:,|/'\n\n\n\n\nThis is the key:\n\n\n'a\nbKc=d e.f;goh:ijj]ktlPmzn\nolpWqQrFsHtau`v!wSxEyRzsAMB0CCDTE8FUGrHYI6J-KhL[MANcO9PfQ5RnSpTbU@VdW\nXZYwZI1}2k3)4g5_6(728O9?0m!i@##V$%%{^y\nN*B(v)$_++D-^=4`3~* G,u.x\ne\n7[1]L{X}~/q?|;J:,|/'\n\n\n\n\nCopy it (including the start and end tics \n'\n) to your cut-copy-paste buffer.  \n\n\n3. Write Code To Load Key String\n\n\nNow, write this code in main.lua or in your initialization code (be sure to use key in your cut-copy-paste buffer):\n\n\n\n-- Paste your key into this variable:\nlocal keyString = 'a\nbKc=d e.f;goh:ijj]ktlPmzn\nolpWqQrFsHtau`v!wSxEyRzsAMB0CCDTE8FUGrHYI6J-KhL[MANcO9PfQ5RnSpTbU@VdW\nXZYwZI1}2k3)4g5_6(728O9?0m!i@##V$%%{^y\nN*B(v)$_++D-^=4`3~* G,u.x\ne\n7[1]L{X}~/q?|;J:,|/'\n\n-- Now initialize ssk.security with it:\nssk.security.loadKeyFromKeyString( keyString )\n\n\n\n\n\nGetting A Key String\n\n\nAt any time, you can get the current key (cypher) from \nssk.security()\n with this function:\n\n\nlocal keyString = ssk.security.getKeyString( )\n\n\n\n\nComplete Security Example\n\n\nlocal test = {}\n\n-- Localize security module\nlocal security = ssk.security\n\nfunction test.run( group, params )\n   group = group or display.currentStage\n   params = params or {}\n\n   table.dump(security)\n\n   -- Print current key (default key)\n   local curKey = security.getKeyString()\n   print( \nDefault Key: \n, curKey)\n\n   -- Generate and set a new key\n   security.genKey()\n   local newKey = security.getKeyString()\n   print( \nGenerated key: \n, newKey )\n\n   -- Test encoding and decoding.\n   local origString = \nThis is a random string 1234567890.\n\n   local encodedString = security.encode( origString )\n   local decodedString = security.decode( encodedString )\n\n   print( \n   Original string: \n .. tostring( origString ) )\n   print( \n    Encoded string: \n .. tostring( encodedString ) )\n   print( \n    Decoded string: \n .. tostring( decodedString ) )\n   print( \n    Strings match?: \n .. tostring( origString == decodedString ) )\n\n   -- Save key\n   security.saveKey( \nkey.json\n )\n\n   -- Generate a new key\n   security.genKey() \n\n   -- Load saved key   \n    security.loadKey( \nkey.json\n)\n\n\n    -- Test saved, generated, reloaded key\n   local reDecodedString = security.decode( encodedString )\n\n   print( \n Re-Decoded string: \n .. tostring( reDecodedString ) )\n   print( \n    Strings match?: \n .. tostring( origString == decodedString ) )\nend\n\nreturn test\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.security.*"
        }, 
        {
            "location": "/libraries/security/#simple-security-ssksecurity", 
            "text": "This library gives you security without using heavy-weight and restricted encryption technologies.  The purpose of this module is to make it difficult for end-users to read and modify saved files.  It is great for obfuscating game settings like score, IAP purchase flags, etc.  This library uses a substitution-cypher to encode and decode strings.    While difficult to crack, this is  NOT STRONG  security.  It should not be used to secure sensitive data.", 
            "title": "Simple Security (ssk.security.*)"
        }, 
        {
            "location": "/libraries/security/#security-operations-ssksecurity", 
            "text": "genKey     encode  decode    saveKey  loadKey    printKeyString  loadKeyFromKeyString    getKeyString", 
            "title": "Security Operations (ssk.security:*)"
        }, 
        {
            "location": "/libraries/security/#generating-a-key", 
            "text": "After exeucuting this code, the security module will be using a new randomly generated key (cypher):  \nssk.security.genKey()", 
            "title": "Generating A Key"
        }, 
        {
            "location": "/libraries/security/#encoding", 
            "text": "To encode a string with the current key (cypher) do this:  \nlocal origString =  This is a random string 1234567890. \n\nlocal encodedString = ssk.security.encode( origString )  Now,  encodedString  contains a obfuscated version of  origString .", 
            "title": "Encoding"
        }, 
        {
            "location": "/libraries/security/#decoding", 
            "text": "To decode a previously obfuscated string:  \nlocal decodedString = ssk.security.decode( encodedString )  Assuming  ssk.security  was configured with the same key (cypher) used to encode   encodedString ,  decodedString  will now contain the original un-encoded string.", 
            "title": "Decoding"
        }, 
        {
            "location": "/libraries/security/#saving-a-key", 
            "text": "You can save the current key (cypher) to a file with this function:  ssk.security.saveKey( fileName [ , base  ])   fileName  - File to save key in.  base  ( system.DocumentsDirectory ) - Base folder for key file.", 
            "title": "Saving A Key"
        }, 
        {
            "location": "/libraries/security/#example", 
            "text": "-- Save current key as file key.json (in system.DocumentsDirectory) \nssk.security.saveKey(  key.json  )", 
            "title": "Example"
        }, 
        {
            "location": "/libraries/security/#restoring-a-key", 
            "text": "You can restoring a key (cypher) from a key previously stored in a file with this function  ssk.security.loadKey( fileName [ , base  ])   fileName  - File to load key from.  base  ( system.DocumentsDirectory ) - Base folder for key file.", 
            "title": "Restoring A Key"
        }, 
        {
            "location": "/libraries/security/#example_1", 
            "text": "-- Load key from file key.json (in system.DocumentsDirectory) \nssk.security.loadKey(  key.json  )  Assuming  ssk.security  was configured with the same key (cypher) used to encode   encodedString ,  decodedString  will now contain the original un-encoded string.", 
            "title": "Example"
        }, 
        {
            "location": "/libraries/security/#embedding-a-key", 
            "text": "Instead of saving and loading to/from a file, you may find it easier to embed a key right in your app/game code.  To do this, follow these steps:", 
            "title": "Embedding A Key"
        }, 
        {
            "location": "/libraries/security/#1-generate-print-key", 
            "text": "Do this in the simulator:  \n-- Generate random key\nssk.security.genKey() \n\n-- Print To Console\nssk.security.printKeyString()", 
            "title": "1. Generate &amp; Print Key"
        }, 
        {
            "location": "/libraries/security/#2-get-key-from-console", 
            "text": "Look in your console and find a statement like this:  21:20:38.762  'a bKc=d e.f;goh:ijj]ktlPmzn olpWqQrFsHtau`v!wSxEyRzsAMB0CCDTE8FUGrHYI6J-KhL[MANcO9PfQ5RnSpTbU@VdW XZYwZI1}2k3)4g5_6(728O9?0m!i@##V$%%{^y N*B(v)$_++D-^=4`3~* G,u.x e 7[1]L{X}~/q?|;J:,|/'  This is the key:  'a bKc=d e.f;goh:ijj]ktlPmzn olpWqQrFsHtau`v!wSxEyRzsAMB0CCDTE8FUGrHYI6J-KhL[MANcO9PfQ5RnSpTbU@VdW XZYwZI1}2k3)4g5_6(728O9?0m!i@##V$%%{^y N*B(v)$_++D-^=4`3~* G,u.x e 7[1]L{X}~/q?|;J:,|/'  Copy it (including the start and end tics  ' ) to your cut-copy-paste buffer.", 
            "title": "2. Get Key From Console"
        }, 
        {
            "location": "/libraries/security/#3-write-code-to-load-key-string", 
            "text": "Now, write this code in main.lua or in your initialization code (be sure to use key in your cut-copy-paste buffer):  \n-- Paste your key into this variable:\nlocal keyString = 'a bKc=d e.f;goh:ijj]ktlPmzn olpWqQrFsHtau`v!wSxEyRzsAMB0CCDTE8FUGrHYI6J-KhL[MANcO9PfQ5RnSpTbU@VdW XZYwZI1}2k3)4g5_6(728O9?0m!i@##V$%%{^y N*B(v)$_++D-^=4`3~* G,u.x e 7[1]L{X}~/q?|;J:,|/'\n\n-- Now initialize ssk.security with it:\nssk.security.loadKeyFromKeyString( keyString )", 
            "title": "3. Write Code To Load Key String"
        }, 
        {
            "location": "/libraries/security/#getting-a-key-string", 
            "text": "At any time, you can get the current key (cypher) from  ssk.security()  with this function:  local keyString = ssk.security.getKeyString( )", 
            "title": "Getting A Key String"
        }, 
        {
            "location": "/libraries/security/#complete-security-example", 
            "text": "local test = {}\n\n-- Localize security module\nlocal security = ssk.security\n\nfunction test.run( group, params )\n   group = group or display.currentStage\n   params = params or {}\n\n   table.dump(security)\n\n   -- Print current key (default key)\n   local curKey = security.getKeyString()\n   print(  Default Key:  , curKey)\n\n   -- Generate and set a new key\n   security.genKey()\n   local newKey = security.getKeyString()\n   print(  Generated key:  , newKey )\n\n   -- Test encoding and decoding.\n   local origString =  This is a random string 1234567890. \n   local encodedString = security.encode( origString )\n   local decodedString = security.decode( encodedString )\n\n   print(     Original string:   .. tostring( origString ) )\n   print(      Encoded string:   .. tostring( encodedString ) )\n   print(      Decoded string:   .. tostring( decodedString ) )\n   print(      Strings match?:   .. tostring( origString == decodedString ) )\n\n   -- Save key\n   security.saveKey(  key.json  )\n\n   -- Generate a new key\n   security.genKey() \n\n   -- Load saved key   \n    security.loadKey(  key.json )\n\n\n    -- Test saved, generated, reloaded key\n   local reDecodedString = security.decode( encodedString )\n\n   print(   Re-Decoded string:   .. tostring( reDecodedString ) )\n   print(      Strings match?:   .. tostring( origString == decodedString ) )\nend\n\nreturn test     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Complete Security Example"
        }, 
        {
            "location": "/libraries/shufflebag/", 
            "text": "Shuffle Bags (ssk.shufflebag.*)\n\n\nThis library is used to create \nShuffle Bags\n.\n\n\n\n\nA \nShuffle Bag\n is a technique for controlling randomness to create the distribution we desire.\n\nenvatotuts+\n\n\n\n\nIn short, if you want to create a random set of 'things' and control the random distribution of each 'thing' in that set, this is the answer.\n\n\nTip:\n 'Things' can be strings, numbers, object references, table reference, function referenes, ... pretty much any Lua referable entity.\n\n\nCreating a Shuffle Bag\n\n\nCreating a new myCC is as easy as:\n\n\n\nlocal bag = ssk.shuffleBag.new()\n\n\n\n\n\nTip:\n The \nnew()\n function takes an optional list of 'things'  to add directly to the new bag.\n\n\n\nlocal bag = ssk.shuffleBag.new( \njack.png\n, \nking.png\n, \nqueen.png\n, \nace.png\n )\n\n\n\n\n\nShuffle Bag Methods (bag:*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nget\n\n\ngetCounts\n\n\ninsert\n\n\n\n\n\n\nputBack\n\n\nshuffle\n\n\ntake\n\n\n\n\n\n\n\n\ninsert\n\n\nAdd 'thing' to shuffle bag.\n\n\nbag:insert( thing )\n\n\n\n\n\n\nthing\n - 'Thing' to add to bag.\n\n\n\n\n\nlocal cards = shuffleBag.new()\n\ncards:insert( \njack.png\n )\ncards:insert( \nking.png\n )\ncards:insert( \nqueen.png\n )\ncards:insert( \nace.png\n )\n\n\n\n\n\nshuffle\n\n\nRandomize the bag.\n\n\nbag:shuffle( )\n\n\n\n\n\ncards:shuffle()\n\n\n\n\n\nget\n\n\nGet one random entry from bag. \n\n\nTip:\n By default, bags autoshuffle. This way, if you try to get an entry from the bag and it is empty, the bag will automatically re-fill and shuffle, then return a new object.\n\n\nbag:get( [autoShuffle] )\n\n\n\n\n\n\nautoShuffle\n (\ntrue\n) - If \ntrue\n, and out of entries, automatically shuffle the bag.\n\n\n\n\n\nlocal file = cards:get()         \n\n\n\n\n\ngetCounts\n\n\nReturn count of \nUnused\n, \nUsed\n, and \nOut\n entries\n\n\n\n\nUnused\n Entry - An entry in the bag that has not been 'gotten' since the last shuffle.\n\n\nUsed\n Entry - An entry in the bag that has been 'gotten' since the last shuffle.  Can't be gotten again till a new shuffle occurs.\n\n\nOut\n Entry - A \nused\n entry that can't be gotten till it is \nputBack\n and a shuffle is done.  \nTaken\n entries are marked as \nout\n.\n\n\n\n\nbag:getCounts( )\n\n\n\n\n\nlocal unused, used, out = cards:getCounts()\n\nprint(\nUnused entries: \n, unused )\nprint(\n  Used entries: \n, used )\nprint(\n   Out entries: \n, out )\n\n\n\n\n\ntake\n\n\nSame as a \nget()\n, but entry is marked as \nOut\n.  This entry will not be takeable again until:\n\n\n\n\nIt is \nputBack()\n, and\n\n\nThe bag is re-shuffled.\n\n\n\n\nTip:\n By default, bags autoshuffle. This way, if you try to get an entry from the bag and it is empty, the bag will automatically re-fill and shuffle, then return a new object.\n\n\nbag:take( [autoShuffle] )\n\n\n\n\n\n\nautoShuffle\n (\ntrue\n) - If \ntrue\n, and out of entries, automatically shuffle the bag.\n\n\n\n\n\nlocal file = cards:take()         \n\n\n\n\n\nputBack\n\n\nUsed to return an \nOut\n entry. \n\n\nWarning:\n When you put back an entry it must be a valid entry that exactly matches a previously taken entry.  You are responsible for tracking references to entries you \ntake()\n.\n\n\nbag:putBack( [entry] )\n\n\n\n\n\n\nentry\n (\nnil\n) - The exact entry you removed from the bag previously with \ntake()\n.\n\n\nTip:\n: If you pass nil (call with no argument), the last \nOut\n entry will be put back.\n\n\n\n\n\n\n\n\n\ncards:putBack( file )\n\n\n\n\n\nComplete Shuffle Bag Examples\n\n\n\nlocal bag1\n\nlocal bag2\n\nlocal shuffleBag = ssk.shuffleBag\n\nlocal test = {}\n\nfunction test.run( group, params )\n   group = group or display.currentStage\n   params = params or {}\n\n   -- Run tests\n   bag1(group)\n\n   bag2(group)   \n\nend\n\n\n-- ==========================================================\n-- === Shuffle Bag Example 1\n-- ==========================================================\nbag1 = function( group )  \n\n    local cardGroup = display.newGroup()\n    group:insert( cardGroup )\n\n   local cards = shuffleBag.new( \njack.png\n, \nking.png\n, \nqueen.png\n, \nace.png\n )\n\n   cards:shuffle()\n\n   local function showCards( button )\n      display.remove(cardGroup)\n      cardGroup = display.newGroup()\n      group:insert( cardGroup )\n\n      for i = 1, 4 do\n         local file = cards:get()         \n         local card = display.newImageRect( cardGroup, \nimages/kenney/\n .. file, 140, 190 )\n         card.x = button.x + 160 * i\n         card.y = button.y\n      end\n   end\n\n   --\n   -- Basic button to 'run' showCards() when touched.\n   --   \n   local function onDeal( event )\n    showCards( event.target )\n   end\n   easyIFC:presetPush( group, \ndefault\n, \n                       left + 75, centerY - 110, 100, 40, \n                       \nDeal\n, onDeal, { strokeWidth = 3 } )\nend\n\n\n-- ==========================================================\n-- === Shuffle Bag Example 2 - Insert +  Auto Reshuffle\n-- ==========================================================\nbag2 = function( group )  \n\n    local cardGroup = display.newGroup()\n    group:insert( cardGroup )\n\n   local cards = shuffleBag.new()\n\n   cards:insert( \njack.png\n )\n   cards:insert( \nking.png\n )\n   cards:insert( \nqueen.png\n )\n   cards:insert( \nace.png\n )\n\n   cards:shuffle()\n\n   local group = display.newGroup()\n\n   local function showCards( button )\n      display.remove(cardGroup)\n      cardGroup = display.newGroup()\n      group:insert( cardGroup )\n\n      for i = 1, 5 do\n         local file = cards:get()         \n         local card = display.newImageRect( cardGroup, \nimages/kenney/\n .. file, 140, 190 )\n         card.x = button.x + 160 * i\n         card.y = button.y\n      end\n   end\n\n   --\n   -- Basic button to 'run' showCards() when touched.\n   --   \n   local function onDeal( event )\n    showCards( event.target )\n   end\n   easyIFC:presetPush( group, \ndefault\n, \n                       left + 75, centerY + 110, 100, 40, \n                       \nDeal\n, onDeal, { strokeWidth = 3 } )\nend\n\nreturn test\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.shufflebag.*"
        }, 
        {
            "location": "/libraries/shufflebag/#shuffle-bags-sskshufflebag", 
            "text": "This library is used to create  Shuffle Bags .   A  Shuffle Bag  is a technique for controlling randomness to create the distribution we desire. envatotuts+   In short, if you want to create a random set of 'things' and control the random distribution of each 'thing' in that set, this is the answer.  Tip:  'Things' can be strings, numbers, object references, table reference, function referenes, ... pretty much any Lua referable entity.", 
            "title": "Shuffle Bags (ssk.shufflebag.*)"
        }, 
        {
            "location": "/libraries/shufflebag/#creating-a-shuffle-bag", 
            "text": "Creating a new myCC is as easy as:  \nlocal bag = ssk.shuffleBag.new()  Tip:  The  new()  function takes an optional list of 'things'  to add directly to the new bag.  \nlocal bag = ssk.shuffleBag.new(  jack.png ,  king.png ,  queen.png ,  ace.png  )", 
            "title": "Creating a Shuffle Bag"
        }, 
        {
            "location": "/libraries/shufflebag/#shuffle-bag-methods-bag", 
            "text": "get  getCounts  insert    putBack  shuffle  take", 
            "title": "Shuffle Bag Methods (bag:*)"
        }, 
        {
            "location": "/libraries/shufflebag/#insert", 
            "text": "Add 'thing' to shuffle bag.  bag:insert( thing )   thing  - 'Thing' to add to bag.   \nlocal cards = shuffleBag.new()\n\ncards:insert(  jack.png  )\ncards:insert(  king.png  )\ncards:insert(  queen.png  )\ncards:insert(  ace.png  )", 
            "title": "insert"
        }, 
        {
            "location": "/libraries/shufflebag/#shuffle", 
            "text": "Randomize the bag.  bag:shuffle( )  \ncards:shuffle()", 
            "title": "shuffle"
        }, 
        {
            "location": "/libraries/shufflebag/#get", 
            "text": "Get one random entry from bag.   Tip:  By default, bags autoshuffle. This way, if you try to get an entry from the bag and it is empty, the bag will automatically re-fill and shuffle, then return a new object.  bag:get( [autoShuffle] )   autoShuffle  ( true ) - If  true , and out of entries, automatically shuffle the bag.   \nlocal file = cards:get()", 
            "title": "get"
        }, 
        {
            "location": "/libraries/shufflebag/#getcounts", 
            "text": "Return count of  Unused ,  Used , and  Out  entries   Unused  Entry - An entry in the bag that has not been 'gotten' since the last shuffle.  Used  Entry - An entry in the bag that has been 'gotten' since the last shuffle.  Can't be gotten again till a new shuffle occurs.  Out  Entry - A  used  entry that can't be gotten till it is  putBack  and a shuffle is done.   Taken  entries are marked as  out .   bag:getCounts( )  \nlocal unused, used, out = cards:getCounts()\n\nprint( Unused entries:  , unused )\nprint(   Used entries:  , used )\nprint(    Out entries:  , out )", 
            "title": "getCounts"
        }, 
        {
            "location": "/libraries/shufflebag/#take", 
            "text": "Same as a  get() , but entry is marked as  Out .  This entry will not be takeable again until:   It is  putBack() , and  The bag is re-shuffled.   Tip:  By default, bags autoshuffle. This way, if you try to get an entry from the bag and it is empty, the bag will automatically re-fill and shuffle, then return a new object.  bag:take( [autoShuffle] )   autoShuffle  ( true ) - If  true , and out of entries, automatically shuffle the bag.   \nlocal file = cards:take()", 
            "title": "take"
        }, 
        {
            "location": "/libraries/shufflebag/#putback", 
            "text": "Used to return an  Out  entry.   Warning:  When you put back an entry it must be a valid entry that exactly matches a previously taken entry.  You are responsible for tracking references to entries you  take() .  bag:putBack( [entry] )   entry  ( nil ) - The exact entry you removed from the bag previously with  take() .  Tip: : If you pass nil (call with no argument), the last  Out  entry will be put back.     \ncards:putBack( file )", 
            "title": "putBack"
        }, 
        {
            "location": "/libraries/shufflebag/#complete-shuffle-bag-examples", 
            "text": "local bag1\n\nlocal bag2\n\nlocal shuffleBag = ssk.shuffleBag\n\nlocal test = {}\n\nfunction test.run( group, params )\n   group = group or display.currentStage\n   params = params or {}\n\n   -- Run tests\n   bag1(group)\n\n   bag2(group)   \n\nend\n\n\n-- ==========================================================\n-- === Shuffle Bag Example 1\n-- ==========================================================\nbag1 = function( group )  \n\n    local cardGroup = display.newGroup()\n    group:insert( cardGroup )\n\n   local cards = shuffleBag.new(  jack.png ,  king.png ,  queen.png ,  ace.png  )\n\n   cards:shuffle()\n\n   local function showCards( button )\n      display.remove(cardGroup)\n      cardGroup = display.newGroup()\n      group:insert( cardGroup )\n\n      for i = 1, 4 do\n         local file = cards:get()         \n         local card = display.newImageRect( cardGroup,  images/kenney/  .. file, 140, 190 )\n         card.x = button.x + 160 * i\n         card.y = button.y\n      end\n   end\n\n   --\n   -- Basic button to 'run' showCards() when touched.\n   --   \n   local function onDeal( event )\n    showCards( event.target )\n   end\n   easyIFC:presetPush( group,  default , \n                       left + 75, centerY - 110, 100, 40, \n                        Deal , onDeal, { strokeWidth = 3 } )\nend\n\n\n-- ==========================================================\n-- === Shuffle Bag Example 2 - Insert +  Auto Reshuffle\n-- ==========================================================\nbag2 = function( group )  \n\n    local cardGroup = display.newGroup()\n    group:insert( cardGroup )\n\n   local cards = shuffleBag.new()\n\n   cards:insert(  jack.png  )\n   cards:insert(  king.png  )\n   cards:insert(  queen.png  )\n   cards:insert(  ace.png  )\n\n   cards:shuffle()\n\n   local group = display.newGroup()\n\n   local function showCards( button )\n      display.remove(cardGroup)\n      cardGroup = display.newGroup()\n      group:insert( cardGroup )\n\n      for i = 1, 5 do\n         local file = cards:get()         \n         local card = display.newImageRect( cardGroup,  images/kenney/  .. file, 140, 190 )\n         card.x = button.x + 160 * i\n         card.y = button.y\n      end\n   end\n\n   --\n   -- Basic button to 'run' showCards() when touched.\n   --   \n   local function onDeal( event )\n    showCards( event.target )\n   end\n   easyIFC:presetPush( group,  default , \n                       left + 75, centerY + 110, 100, 40, \n                        Deal , onDeal, { strokeWidth = 3 } )\nend\n\nreturn test     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Complete Shuffle Bag Examples"
        }, 
        {
            "location": "/libraries/social/", 
            "text": "(Easy Social) ssk.social.*\n\n\nThis module contains a couple 'helper' functions to simplify sharing and rating apps.\n\n\nrate\n\n\nOpen rate interface in appropriate store for app identified \nid\n.\n\n\nssk.social.rate( id [, appName [, preProcessed ] ] )\n\n\n\n\n\n\nid\n - ID of app, varies by store (see 'Supported Stores' below)\n\n\nappName\n (\nnil\n) - (Optional) Name of app (used for tvOS).\n\n\npreProcessed\n (\nfalse\n) - Set this to 'true' if you have already converted your app name to a 'proper' string for the URL, otherwise rate() will try to convert the appName into a 'proper' string.\n\n\n\n\nSupported Stores:\n\n\n\n\nTested\n\n\nGoogle Play \n\n\nid\n == \"Package Name\" used when buiding app\n\n\n\n\n\n\niTunes Connect \n\n\nid\n == Numeric App ID found on your store page when submitting app.\n\n\n\n\n\n\n\n\n\n\nUntested\n\n\nAmazon (\nuntested\n) \n\n\nid\n == \"Package Name\" used when buiding app\n\n\n\n\n\n\n(Apple) tvOS Store (\nuntested\n) \n\n\nid\n == Numeric App ID found on your store page when submitting app.\n\n\nappName\n == Name of app.  Utility will clean it for you.\n\n\n\n\n\n\n\n\n\n\n\n\nExample:\n\n\n\n-- Rate Sudoku For.. game on Android  or iOS\nif( onAndroid ) then\n\n   ssk.social.rate( 'com.roaminggamer.sudoku4' ) -- Google Play ID\n\nelseif( oniOS ) then\n\n   ssk.social.rate( '1150939979' ) -- iTunes Connect ID\n\nend\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.social.*"
        }, 
        {
            "location": "/libraries/social/#easy-social-ssksocial", 
            "text": "This module contains a couple 'helper' functions to simplify sharing and rating apps.", 
            "title": "(Easy Social) ssk.social.*"
        }, 
        {
            "location": "/libraries/social/#rate", 
            "text": "Open rate interface in appropriate store for app identified  id .  ssk.social.rate( id [, appName [, preProcessed ] ] )   id  - ID of app, varies by store (see 'Supported Stores' below)  appName  ( nil ) - (Optional) Name of app (used for tvOS).  preProcessed  ( false ) - Set this to 'true' if you have already converted your app name to a 'proper' string for the URL, otherwise rate() will try to convert the appName into a 'proper' string.", 
            "title": "rate"
        }, 
        {
            "location": "/libraries/social/#supported-stores", 
            "text": "Tested  Google Play   id  == \"Package Name\" used when buiding app    iTunes Connect   id  == Numeric App ID found on your store page when submitting app.      Untested  Amazon ( untested )   id  == \"Package Name\" used when buiding app    (Apple) tvOS Store ( untested )   id  == Numeric App ID found on your store page when submitting app.  appName  == Name of app.  Utility will clean it for you.       Example:  \n-- Rate Sudoku For.. game on Android  or iOS\nif( onAndroid ) then\n\n   ssk.social.rate( 'com.roaminggamer.sudoku4' ) -- Google Play ID\n\nelseif( oniOS ) then\n\n   ssk.social.rate( '1150939979' ) -- iTunes Connect ID\n\nend     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Supported Stores:"
        }, 
        {
            "location": "/libraries/soundMgr/", 
            "text": "Sound Manager (ssk.soundMgr.*)\n\n\nThe \nSound Manager\n is a basic sound effects and music manager with these functions and listeners:\n\n\n\n\n\n\n\n\nFunctions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nadd\n\n\naddEffect\n\n\naddMusic\n\n\ndump\n\n\n\n\n\n\nenableSFX\n\n\nenableMusic\n\n\nload\n\n\nsetDebugLevel\n\n\n\n\n\n\nsetMaxMusicChannels\n\n\nsetVolume\n\n\nstop\n\n\nstopAll\n\n\n\n\n\n\nrelease\n\n\nreleaseAll\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nListeners\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nonSound (Effect)\n\n\nonSound (Music)\n\n\n\n\n\n\n\n\n\n\n\n\nAdding Sounds\n\n\nThere is one 'generic' function for adding sounds and two helper functions that call it.\n\n\nssk.soundMgr.add( name, path [, params ] )\n\n\n\n\nssk.soundMgr.addEffect( name, path [, params ] )\n\n\n\n\nssk.soundMgr.addMusic( name, path [, params ] )\n\n\n\n\n\n\nname\n - Name to identify sound by in future.\n\n\nMust be unique.\n\n\nCase-sensitive.\n\n\n\n\n\n\npath\n - Full path (including file name) to sound file.\n\n\nparams\n (\n{}\n) - Table of named parameters to configure sound.\n\n\nsoundType\n (\neffect\n) - Must be \neffect\n or \nmusic\n.\n\n\nHelper functions override this parameter to match their type.\n\n\n\n\n\n\nbaseDir\n (\nsystem.ResourceDirectory\n) - Folder type for path.\n\n\npreload\n (\nfalse\n) - Preload this sound.\n\n\nsticky\n (\nnil\n) - If \ntrue\n, this sound is skipped during normal release.\n\n\nminTweenTime\n (\nnil\n) - Set this to a positive non-zero value to keep sounds from flooding (playing repeatedly and too quickly).\n\n\nThis prevents this sound from repeating any sooner than \nminTweenTime\n milliseconds.\n\n\nThis is handy for sound effects that can happen quickly and can be used as a basic 'flood control'.\n\n\n\n\n\n\n\n\n\n\n\n\n\nsoundMgr.add( \nclick\n, \nsounds/sfx/click.mp3\n, { soundType = \neffect\n, preload = true, minTweenTime = 200 } )\n\nsoundMgr.addEffect( \nexplosion\n, \nsounds/sfx/explosion.wav\n, { preload = true, sticky = true } )\n\nsoundMgr.addMusic( \nSugar Plum Breakdown\n, \nsounds/music/Sugar Plum Breakdown.mp3\n )\n\n\n\n\n\nLoading Sounds\n\n\nWhen \nadding sounds\n you may specify to preload or not preload each sound.  Additionally, you may force a sound file to load at any time.  \n\n\nTip 1:\n Once a file is loaded it won't re-load if you try to load again.\n\n\nTip 2:\n If you attempt to play an un-loaded sound, it will be loaded automatically, but this could cause a slight delay for large sounds files.  So, preloading or force-loading before you need to play a sound is generally a good idea.\n\n\nssk.soundMgr.addMusic( name )\n\n\n\n\n\n\nname\n - Name of previously added sound that you wish to load.\n\n\n\n\nPlaying Sounds\n\n\nThere is no function to play a sound directly.  Instead, sound effects and music are both played using the \nonSound\n event.  \n\n\nThis may seem \nweird\n at first, but it is by design.  The idea is that, once you have configured the sound manager, you should be able to play a sound from anywhere with a single line of code.  \nNo fuss, no muss.\n\n\nThe \nonSound\n event takes a number of (mostly optional) arguments:\n\n\n\n\nsound\n (required) - Name of sound (must match previously added sound).\n\n\nloops\n (\n1\n) - Optional number of times to loop sound:\n\n\n-1\n or \n0\n - Infinite.\n\n\nN \n 0\n - \nN\n times.\n\n\n\n\n\n\nduration\n (\nnil\n) - If specified, sound plays up to this many milliseconds and auto-stops.    \n\n\nfadein\n (\nnil\n) - If specified, fade up from 0 to channel volume over \nfadein\n milliseconds.\n\n\nonComplete\n (\nnil\n) - Optional listener to execute when done playing sound.\n\n\n\n\nPlaying Sound Effects\n\n\n\npost( \nonSound\n, { sound = \nclick\n } )\n\n\n\n\n\nPlaying Music\n\n\n\npost( \nonSound\n, { sound = \nSugar Plum Breakdown\n, fadein = 1500 } )\n\n\n\n\n\nTip:\n If you try to play the same music while it is playing already, you will get a warning and the second attempt will fail.  \n\n\nStopping Sounds\n\n\nYou can stop individual sounds, categories or sounds (\n\"effect\"\n or \n\"music\"\n) or all sounds.\n\n\nUnlike \nplaying sounds\n, stopping sounds is a direct call because it is typically done from a single location in games and apps, so there is no need for 'distributed access'.\n\n\nStop\n\n\nUse this function to stop all playing instances of a specific sound:\n\n\nssk.soundMgr.stop( name ) \n\n\n\n\n\n\nname\n - Name of sound to stop.\n\n\n\n\nStop All\n\n\nUse this function to stop categories of sounds (\n\"effect\"\n or \n\"music\"\n) or all sounds.\n\n\nssk.soundMgr.stopAll( [ stopType ] ) \n\n\n\n\n\n\nstopType\n (\nnil\n) - Type of sounds to stop.\n\n\nnil\n - All sounds.\n\n\n\"effect\"\n - Effect sounds.\n\n\n\"music\"\n - Music sounds.\n\n\n\n\n\n\n\n\nFreeing (Releasing) Memory\n\n\nYou are responsible for freeing memory used by sounds you no longer need loaded.  Fortunately, the \nSound Manager\n makes this easy.\n\n\nWarning:\n Releasing a sound will stop any instance(s) of that sound currently being played.\n\n\nRelease\n\n\nYou can release the memory associated with any single sound (as long as it is not currently playing) with this function:\n\n\nssk.soundMgr.release( name [, force ] ) \n\n\n\n\n\n\nname\n - Name of sound (must match previously added sound).\n\n\nforce\n (\nfalse\n) - Set this to \ntrue\n for force \nsticky\n sounds to be removed.\n\n\n\n\nRelease All\n\n\nYou can release the memory associated with any single sound (as long as it is not currently playing) with this function:\n\n\nssk.soundMgr.releaseAll( [ releaseType [, force ] ] ) \n\n\n\n\n\n\nreleaseType\n (\nnil\n) - Type of sounds to release.\n\n\nnil\n - All sounds.\n\n\n\"effect\"\n - Effect sounds.\n\n\n\"music\"\n - Music sounds.\n\n\n\n\n\n\nforce\n (\nfalse\n) - Set this to \ntrue\n for force \nsticky\n sounds to be removed.\n\n\n\n\nTip:\n If you try to play the same music while it is playing already, you will get a warning and the second attempt will fail.  \n\n\nConfiguring the Sound Manager\n\n\nMax Music Channels\n\n\nBy default, the manager allocates four music channels for music and the rest (28) are for sound effects.  This is typically enough, but if you feel it won't be, simply call this function with the number of \nmax\n channels you want held aside for music.\n\n\nTip:\n Do this before you start \nplaying sounds\n.\n\n\nssk.soundMgr.setMaxMusicChannels( [ max ] ) \n\n\n\n\nVolume Control\n\n\nBy default, all channels are set at max volume (\n1.0\n), but the \nSound Manager\n give you complete control of these volume:\n\n\n\n\nGlobal Volume\n - Multiplier for all channels.\n\n\nEffect Volume\n - Multiplier for \n\"effect\"\n channels.\n\n\nMusic Volume\n - Multiplier for \n\"music\"\n channels.\n\n\n\n\nThe volume for any sound is determined by this equation:\n\n\n\n\nChannel Volume == \nGlobal Volume\n x \nType Volume\n \n\n\n\n\nssk.soundMgr.setVolume( volume [ , volType ] )\n\n\n\n\n\n\nvolume\n (\n1.0\n) - Volume level in range [\n0\n,\n1\n].\n\n\nvolType\n (\nnil\n) - Volume type to set:\n\n\nnil\n - Global\n\n\neffect\n - Effect channels.\n\n\nmusic\n - Music channels.\n\n\n\n\n\n\n\n\nTip:\n While you usually do this during initialization, you can change volumes any time.\n\n\nEnabling Effects\n\n\nBy default, effect sounds are enabled, but you can disable them at any time by passing \nfalse\n to this function (defaults to \ntrue\n):\n\n\nssk.soundMgr.enableSFX( [ enable ] )\n\n\n\n\nTip:\n Disabling does not \nstop\n currently \nplaying sounds\n.  It prevents new ones from starting.\n\n\nEnabling Music\n\n\nBy default, music sounds are enabled, but you can disable them at any time by passing \nfalse\n to this function (defaults to \ntrue\n):\n\n\nssk.soundMgr.enableMusic( [ enable ] )\n\n\n\n\nTip:\n Disabling does not \nstop\n currently \nplaying sounds\n.  It prevents new ones from starting.\n\n\nDebugging\n\n\nBy default, only warnings and error messages are printed to the console.  However, while you are working on your game/app, you may find it useful to get additional information.  This module supports three levels of debug messaging.\n\n\nssk.soundMgr.setDebugLevel( [ level ] )\n\n\n\n\n\n\nlevel\n (\n0\n) - Debug messaging level to use after this call.\n\n\n0\n - None.\n\n\n1\n - Basic messages.\n\n\n2\n - Verbose.\n\n\n\n\n\n\n\n\nTip:\n Disabling does not \nstop\n currently \nplaying sounds\n.  It prevents new ones from starting.\n\n\nComplete Example\n\n\n\nlocal soundMgr = ssk.soundMgr\n\nsoundMgr.enableSFX( true )\n\nsoundMgr.enableMusic( true )\n\nsoundMgr.setVolume(0.8)\n\nsoundMgr.setVolume(0.5, \nmusic\n)\n\nsoundMgr.setDebugLevel( 1 )\n\nsoundMgr.add( \nclick\n, \nsounds/sfx/click.mp3\n, { preload = true, minTweenTime = 200 } )\n\nsoundMgr.addEffect( \nexplosion\n, \nsounds/sfx/explosion.wav\n, { preload = true, sticky = true } )\n\nsoundMgr.addMusic( \nSugar Plum Breakdown\n, \nsounds/music/Sugar Plum Breakdown.mp3\n )\n\nsoundMgr.release( \nclick\n )\n\nsoundMgr.release( \nexplosion\n )\n\npost( \nonSound\n, { sound = \nclick\n } )\n\nnextFrame( function() post( \nonSound\n, { sound = \nclick\n } ) end, 100 )\n\ntimer.performWithDelay( 2000, \n    function()\n        post( \nonSound\n, { sound = \nexplosion\n } )\n        nextFrame( function() post( \nonSound\n, { sound = \nexplosion\n } ) end, 250 )\n    end )\n\nlocal function onComplete()\n    print(\nAll sounds should be done.\n)\n    soundMgr.dump()\nend\n\ntimer.performWithDelay( 3000, \n    function()\n        post( \nonSound\n, \n              { sound = \nSugar Plum Breakdown\n, fadein = 1500, \n                loops = 0, onComplete = onComplete } )\n    end )\n\ntimer.performWithDelay( 3500, \n    function()\n        print(\nStopping early.\n)\n        soundMgr.stopAll(\nmusic\n)\n    end )\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.soundMgr.*"
        }, 
        {
            "location": "/libraries/soundMgr/#sound-manager-ssksoundmgr", 
            "text": "The  Sound Manager  is a basic sound effects and music manager with these functions and listeners:     Functions         add  addEffect  addMusic  dump    enableSFX  enableMusic  load  setDebugLevel    setMaxMusicChannels  setVolume  stop  stopAll    release  releaseAll          Listeners         onSound (Effect)  onSound (Music)", 
            "title": "Sound Manager (ssk.soundMgr.*)"
        }, 
        {
            "location": "/libraries/soundMgr/#adding-sounds", 
            "text": "There is one 'generic' function for adding sounds and two helper functions that call it.  ssk.soundMgr.add( name, path [, params ] )  ssk.soundMgr.addEffect( name, path [, params ] )  ssk.soundMgr.addMusic( name, path [, params ] )   name  - Name to identify sound by in future.  Must be unique.  Case-sensitive.    path  - Full path (including file name) to sound file.  params  ( {} ) - Table of named parameters to configure sound.  soundType  ( effect ) - Must be  effect  or  music .  Helper functions override this parameter to match their type.    baseDir  ( system.ResourceDirectory ) - Folder type for path.  preload  ( false ) - Preload this sound.  sticky  ( nil ) - If  true , this sound is skipped during normal release.  minTweenTime  ( nil ) - Set this to a positive non-zero value to keep sounds from flooding (playing repeatedly and too quickly).  This prevents this sound from repeating any sooner than  minTweenTime  milliseconds.  This is handy for sound effects that can happen quickly and can be used as a basic 'flood control'.       \nsoundMgr.add(  click ,  sounds/sfx/click.mp3 , { soundType =  effect , preload = true, minTweenTime = 200 } )\n\nsoundMgr.addEffect(  explosion ,  sounds/sfx/explosion.wav , { preload = true, sticky = true } )\n\nsoundMgr.addMusic(  Sugar Plum Breakdown ,  sounds/music/Sugar Plum Breakdown.mp3  )", 
            "title": "Adding Sounds"
        }, 
        {
            "location": "/libraries/soundMgr/#loading-sounds", 
            "text": "When  adding sounds  you may specify to preload or not preload each sound.  Additionally, you may force a sound file to load at any time.    Tip 1:  Once a file is loaded it won't re-load if you try to load again.  Tip 2:  If you attempt to play an un-loaded sound, it will be loaded automatically, but this could cause a slight delay for large sounds files.  So, preloading or force-loading before you need to play a sound is generally a good idea.  ssk.soundMgr.addMusic( name )   name  - Name of previously added sound that you wish to load.", 
            "title": "Loading Sounds"
        }, 
        {
            "location": "/libraries/soundMgr/#playing-sounds", 
            "text": "There is no function to play a sound directly.  Instead, sound effects and music are both played using the  onSound  event.    This may seem  weird  at first, but it is by design.  The idea is that, once you have configured the sound manager, you should be able to play a sound from anywhere with a single line of code.   No fuss, no muss.  The  onSound  event takes a number of (mostly optional) arguments:   sound  (required) - Name of sound (must match previously added sound).  loops  ( 1 ) - Optional number of times to loop sound:  -1  or  0  - Infinite.  N   0  -  N  times.    duration  ( nil ) - If specified, sound plays up to this many milliseconds and auto-stops.      fadein  ( nil ) - If specified, fade up from 0 to channel volume over  fadein  milliseconds.  onComplete  ( nil ) - Optional listener to execute when done playing sound.", 
            "title": "Playing Sounds"
        }, 
        {
            "location": "/libraries/soundMgr/#playing-sound-effects", 
            "text": "post(  onSound , { sound =  click  } )", 
            "title": "Playing Sound Effects"
        }, 
        {
            "location": "/libraries/soundMgr/#playing-music", 
            "text": "post(  onSound , { sound =  Sugar Plum Breakdown , fadein = 1500 } )  Tip:  If you try to play the same music while it is playing already, you will get a warning and the second attempt will fail.", 
            "title": "Playing Music"
        }, 
        {
            "location": "/libraries/soundMgr/#stopping-sounds", 
            "text": "You can stop individual sounds, categories or sounds ( \"effect\"  or  \"music\" ) or all sounds.  Unlike  playing sounds , stopping sounds is a direct call because it is typically done from a single location in games and apps, so there is no need for 'distributed access'.", 
            "title": "Stopping Sounds"
        }, 
        {
            "location": "/libraries/soundMgr/#stop", 
            "text": "Use this function to stop all playing instances of a specific sound:  ssk.soundMgr.stop( name )    name  - Name of sound to stop.", 
            "title": "Stop"
        }, 
        {
            "location": "/libraries/soundMgr/#stop-all", 
            "text": "Use this function to stop categories of sounds ( \"effect\"  or  \"music\" ) or all sounds.  ssk.soundMgr.stopAll( [ stopType ] )    stopType  ( nil ) - Type of sounds to stop.  nil  - All sounds.  \"effect\"  - Effect sounds.  \"music\"  - Music sounds.", 
            "title": "Stop All"
        }, 
        {
            "location": "/libraries/soundMgr/#freeing-releasing-memory", 
            "text": "You are responsible for freeing memory used by sounds you no longer need loaded.  Fortunately, the  Sound Manager  makes this easy.  Warning:  Releasing a sound will stop any instance(s) of that sound currently being played.", 
            "title": "Freeing (Releasing) Memory"
        }, 
        {
            "location": "/libraries/soundMgr/#release", 
            "text": "You can release the memory associated with any single sound (as long as it is not currently playing) with this function:  ssk.soundMgr.release( name [, force ] )    name  - Name of sound (must match previously added sound).  force  ( false ) - Set this to  true  for force  sticky  sounds to be removed.", 
            "title": "Release"
        }, 
        {
            "location": "/libraries/soundMgr/#release-all", 
            "text": "You can release the memory associated with any single sound (as long as it is not currently playing) with this function:  ssk.soundMgr.releaseAll( [ releaseType [, force ] ] )    releaseType  ( nil ) - Type of sounds to release.  nil  - All sounds.  \"effect\"  - Effect sounds.  \"music\"  - Music sounds.    force  ( false ) - Set this to  true  for force  sticky  sounds to be removed.   Tip:  If you try to play the same music while it is playing already, you will get a warning and the second attempt will fail.", 
            "title": "Release All"
        }, 
        {
            "location": "/libraries/soundMgr/#configuring-the-sound-manager", 
            "text": "", 
            "title": "Configuring the Sound Manager"
        }, 
        {
            "location": "/libraries/soundMgr/#max-music-channels", 
            "text": "By default, the manager allocates four music channels for music and the rest (28) are for sound effects.  This is typically enough, but if you feel it won't be, simply call this function with the number of  max  channels you want held aside for music.  Tip:  Do this before you start  playing sounds .  ssk.soundMgr.setMaxMusicChannels( [ max ] )", 
            "title": "Max Music Channels"
        }, 
        {
            "location": "/libraries/soundMgr/#volume-control", 
            "text": "By default, all channels are set at max volume ( 1.0 ), but the  Sound Manager  give you complete control of these volume:   Global Volume  - Multiplier for all channels.  Effect Volume  - Multiplier for  \"effect\"  channels.  Music Volume  - Multiplier for  \"music\"  channels.   The volume for any sound is determined by this equation:   Channel Volume ==  Global Volume  x  Type Volume     ssk.soundMgr.setVolume( volume [ , volType ] )   volume  ( 1.0 ) - Volume level in range [ 0 , 1 ].  volType  ( nil ) - Volume type to set:  nil  - Global  effect  - Effect channels.  music  - Music channels.     Tip:  While you usually do this during initialization, you can change volumes any time.", 
            "title": "Volume Control"
        }, 
        {
            "location": "/libraries/soundMgr/#enabling-effects", 
            "text": "By default, effect sounds are enabled, but you can disable them at any time by passing  false  to this function (defaults to  true ):  ssk.soundMgr.enableSFX( [ enable ] )  Tip:  Disabling does not  stop  currently  playing sounds .  It prevents new ones from starting.", 
            "title": "Enabling Effects"
        }, 
        {
            "location": "/libraries/soundMgr/#enabling-music", 
            "text": "By default, music sounds are enabled, but you can disable them at any time by passing  false  to this function (defaults to  true ):  ssk.soundMgr.enableMusic( [ enable ] )  Tip:  Disabling does not  stop  currently  playing sounds .  It prevents new ones from starting.", 
            "title": "Enabling Music"
        }, 
        {
            "location": "/libraries/soundMgr/#debugging", 
            "text": "By default, only warnings and error messages are printed to the console.  However, while you are working on your game/app, you may find it useful to get additional information.  This module supports three levels of debug messaging.  ssk.soundMgr.setDebugLevel( [ level ] )   level  ( 0 ) - Debug messaging level to use after this call.  0  - None.  1  - Basic messages.  2  - Verbose.     Tip:  Disabling does not  stop  currently  playing sounds .  It prevents new ones from starting.", 
            "title": "Debugging"
        }, 
        {
            "location": "/libraries/soundMgr/#complete-example", 
            "text": "local soundMgr = ssk.soundMgr\n\nsoundMgr.enableSFX( true )\n\nsoundMgr.enableMusic( true )\n\nsoundMgr.setVolume(0.8)\n\nsoundMgr.setVolume(0.5,  music )\n\nsoundMgr.setDebugLevel( 1 )\n\nsoundMgr.add(  click ,  sounds/sfx/click.mp3 , { preload = true, minTweenTime = 200 } )\n\nsoundMgr.addEffect(  explosion ,  sounds/sfx/explosion.wav , { preload = true, sticky = true } )\n\nsoundMgr.addMusic(  Sugar Plum Breakdown ,  sounds/music/Sugar Plum Breakdown.mp3  )\n\nsoundMgr.release(  click  )\n\nsoundMgr.release(  explosion  )\n\npost(  onSound , { sound =  click  } )\n\nnextFrame( function() post(  onSound , { sound =  click  } ) end, 100 )\n\ntimer.performWithDelay( 2000, \n    function()\n        post(  onSound , { sound =  explosion  } )\n        nextFrame( function() post(  onSound , { sound =  explosion  } ) end, 250 )\n    end )\n\nlocal function onComplete()\n    print( All sounds should be done. )\n    soundMgr.dump()\nend\n\ntimer.performWithDelay( 3000, \n    function()\n        post(  onSound , \n              { sound =  Sugar Plum Breakdown , fadein = 1500, \n                loops = 0, onComplete = onComplete } )\n    end )\n\ntimer.performWithDelay( 3500, \n    function()\n        print( Stopping early. )\n        soundMgr.stopAll( music )\n    end )     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Complete Example"
        }, 
        {
            "location": "/external/", 
            "text": "External\n\n\nThis page documents content that I normally include in SSK2, but which has been sourced from external sources.\n\n\nNOTE:\n \nTo satsify the requirements of certain marketplaces hosting the SSK2 product, the external libraries/modules have been excluded from the product.\n\n\nHowever, I think you will find this content useful, so I made it very easy to intgrate into SSK2.  \n\n\nInstalling External Content\n\n\n\n\nDownload the external content: \nCLICK HERE\n\n\nExtract external.zip to any folder.\n\n\nCopy the folder \nexternal/\n  into \nssk2/\n\n\nSet \nuseExternal\n to \ntrue\n, when \ninitializing\n SSK2.\n\n\n\n\nDone!\n\n\n\n\n30Log (Roland Yonaba)\n\n\n\n\n30 Lines Of Goodness\n is a minified framework for \nobject-orientation\n in Lua.\n\n\nIt provides  \nnamed\n and \nunnamed classes\n, \nsingle inheritance\n, \nmetamethods\n and a basic support for \nmixins\n.\n\n\nSSK2 external DLC includes the 'clean' version so it is legible.\n\n\n30Log is loaded and ready to go.  Simply read \nthese docs\n to learn how to code with it.\n\n\nAutoLan \n M.Y. Developers\n\n\n\n\nThis is a modified version of the (\nnow free\n) \nAutoLan\n by M.Y. Developers. \n\n\nSubsequent to that release, I and a few other developers modified it to support IPV6.  You can read moe about that work \nHERE\n.\n\n\nSSK2 Contains the IPV6 version of AutoLan and can be accessed under:\n\n\n\n\nssk.autolan.client\n\n\nssk.autolan.server\n\n\n\n\nPortable Random (Community Code)\n\n\nNote:\n This module was original found on the Corona Labs \nCommunity Code\n page, but it has since gone MIA.  Fortunately, I have a copy in the SSK2 external DLC.\n\n\nThis module can be used to create a random number generating object that is guaranteed to produce the same sequence for the same seed on all devices.  i.e. It is fully deterministic.\n\n\nWarning:\n The generator ONLY produces integers in the range 0..255, so it may have limited usage.\n\n\nBasic Usage\n\n\n\nlocal prand = math.prand.new()\n\nprand:seed(0xed15c001)\n\nprint( \nGenerated: \n, prand:randInt( 0, 255 ) )\nprint( \nGenerated: \n, prand:randInt( 0, 255 ) )\nprint( \nGenerated: \n, prand:randInt( 0, 255 ) )\n\n\n\n\n\nThis will print (verify it yourself):\n\n\nGenerated:  73\nGenerated:  125\nGenerated:  25\n\n\n\n\nProxy (Corona Blog)\n\n\nThis is a handy little module that:\n\n\n\n\nAdds the ability to detect when a property is changed on a display object.\n\n\n~ Jonathan Beebe\n\n\n\n\nI grabbed it from \nthis cool blog post\n.\n\n\nExample\n\n\n\nlocal circle = display.newCircle( 100, 100, 10 )\n\ncircle.x = left\ncircle.y = centerY\n\ncircle = ssk.proxy.get_proxy_for( circle )\n\nfunction circle:propertyUpdate( event )\n    print(event.key, event.value)\nend\n\ncircle:addEventListener( \npropertyUpdate\n )\n\n\ntransition.to( circle, { x = right } )\n\n\n\n\nThis will print \nx ####\n every time the \ncircle\n is moved by transition. Cool, right?\n\n\nRandomLua (L\u00d6VE Community)\n\n\n\n\nThis is, yet another, Random Number Generator module.  \n\n\nIt was released under the MIT License.  I grabbed this from \nHERE\n.\n\n\nWhile this module includes three different generators, I use the Mersenne Twister exclusively.\n\n\nMersenne Twister\n\n\n\nlocal rng = ssk.randomlua.twister(10)\n\nprint( rng:random( 1, 1000 ) )\n\nprint( rng:random() )\n\nprint( rng:random(-100,100) )\n\nprint( rng:random(1.001, 10.005) )\n\n\n\n\n\nWait (StarCrunch)\n\n\n\n\nReleased under the MIT license by our very own Steve J. (aka \nStarCrunch\n of \nXibalba Studios\n), this module contains a number of helpers for doing cool stuff with Coroutines.\n\n\nWaiting Between Steps\n\n\nlocal function testSeq()\n    local start = system.getTimer()\n    print(\nYO \n .. tostring(start) )\n    ssk.wait.ms( 500 )\n    print(\n1 \n .. tostring(system.getTimer() - start) )\n\n    ssk.wait.ms( 500 )\n    print(\n2 \n .. tostring(system.getTimer() - start) )\n\n    ssk.wait.ms( 500 )\n    print(\n3 \n .. tostring(system.getTimer() - start) )\nend\n\nssk.wait.run( testSeq )\n\n\n\n\nWait In A Timer\n\n\ntimer.performWithDelay(20, \n    coroutine.wrap(\n        function(event)\n        local source = event.source -- GOTCHA: save this now!\n\n        ssk.wait.ms( 500 )\n        print(\n1\n)\n        ssk.wait.ms( 500 )\n\n        print(\n2\n)\n\n        ssk.wait.ms( 500 )\n        print(\n3\n)\n\n        timer.cancel(source)\n    end), 0)\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "External"
        }, 
        {
            "location": "/external/#external", 
            "text": "This page documents content that I normally include in SSK2, but which has been sourced from external sources.  NOTE:   To satsify the requirements of certain marketplaces hosting the SSK2 product, the external libraries/modules have been excluded from the product.  However, I think you will find this content useful, so I made it very easy to intgrate into SSK2.", 
            "title": "External"
        }, 
        {
            "location": "/external/#installing-external-content", 
            "text": "Download the external content:  CLICK HERE  Extract external.zip to any folder.  Copy the folder  external/   into  ssk2/  Set  useExternal  to  true , when  initializing  SSK2.   Done!", 
            "title": "Installing External Content"
        }, 
        {
            "location": "/external/#30log-roland-yonaba", 
            "text": "30 Lines Of Goodness  is a minified framework for  object-orientation  in Lua.  It provides   named  and  unnamed classes ,  single inheritance ,  metamethods  and a basic support for  mixins .  SSK2 external DLC includes the 'clean' version so it is legible.  30Log is loaded and ready to go.  Simply read  these docs  to learn how to code with it.", 
            "title": "30Log (Roland Yonaba)"
        }, 
        {
            "location": "/external/#autolan-my-developers", 
            "text": "This is a modified version of the ( now free )  AutoLan  by M.Y. Developers.   Subsequent to that release, I and a few other developers modified it to support IPV6.  You can read moe about that work  HERE .  SSK2 Contains the IPV6 version of AutoLan and can be accessed under:   ssk.autolan.client  ssk.autolan.server", 
            "title": "AutoLan &copy; M.Y. Developers"
        }, 
        {
            "location": "/external/#portable-random-community-code", 
            "text": "Note:  This module was original found on the Corona Labs  Community Code  page, but it has since gone MIA.  Fortunately, I have a copy in the SSK2 external DLC.  This module can be used to create a random number generating object that is guaranteed to produce the same sequence for the same seed on all devices.  i.e. It is fully deterministic.  Warning:  The generator ONLY produces integers in the range 0..255, so it may have limited usage.", 
            "title": "Portable Random (Community Code)"
        }, 
        {
            "location": "/external/#basic-usage", 
            "text": "local prand = math.prand.new()\n\nprand:seed(0xed15c001)\n\nprint(  Generated:  , prand:randInt( 0, 255 ) )\nprint(  Generated:  , prand:randInt( 0, 255 ) )\nprint(  Generated:  , prand:randInt( 0, 255 ) )  This will print (verify it yourself):  Generated:  73\nGenerated:  125\nGenerated:  25", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/external/#proxy-corona-blog", 
            "text": "This is a handy little module that:   Adds the ability to detect when a property is changed on a display object.  ~ Jonathan Beebe   I grabbed it from  this cool blog post .", 
            "title": "Proxy (Corona Blog)"
        }, 
        {
            "location": "/external/#example", 
            "text": "local circle = display.newCircle( 100, 100, 10 )\n\ncircle.x = left\ncircle.y = centerY\n\ncircle = ssk.proxy.get_proxy_for( circle )\n\nfunction circle:propertyUpdate( event )\n    print(event.key, event.value)\nend\n\ncircle:addEventListener(  propertyUpdate  )\n\n\ntransition.to( circle, { x = right } )  This will print  x ####  every time the  circle  is moved by transition. Cool, right?", 
            "title": "Example"
        }, 
        {
            "location": "/external/#randomlua-love-community", 
            "text": "This is, yet another, Random Number Generator module.    It was released under the MIT License.  I grabbed this from  HERE .  While this module includes three different generators, I use the Mersenne Twister exclusively.", 
            "title": "RandomLua (L\u00d6VE Community)"
        }, 
        {
            "location": "/external/#mersenne-twister", 
            "text": "local rng = ssk.randomlua.twister(10)\n\nprint( rng:random( 1, 1000 ) )\n\nprint( rng:random() )\n\nprint( rng:random(-100,100) )\n\nprint( rng:random(1.001, 10.005) )", 
            "title": "Mersenne Twister"
        }, 
        {
            "location": "/external/#wait-starcrunch", 
            "text": "Released under the MIT license by our very own Steve J. (aka  StarCrunch  of  Xibalba Studios ), this module contains a number of helpers for doing cool stuff with Coroutines.", 
            "title": "Wait (StarCrunch)"
        }, 
        {
            "location": "/external/#waiting-between-steps", 
            "text": "local function testSeq()\n    local start = system.getTimer()\n    print( YO   .. tostring(start) )\n    ssk.wait.ms( 500 )\n    print( 1   .. tostring(system.getTimer() - start) )\n\n    ssk.wait.ms( 500 )\n    print( 2   .. tostring(system.getTimer() - start) )\n\n    ssk.wait.ms( 500 )\n    print( 3   .. tostring(system.getTimer() - start) )\nend\n\nssk.wait.run( testSeq )", 
            "title": "Waiting Between Steps"
        }, 
        {
            "location": "/external/#wait-in-a-timer", 
            "text": "timer.performWithDelay(20, \n    coroutine.wrap(\n        function(event)\n        local source = event.source -- GOTCHA: save this now!\n\n        ssk.wait.ms( 500 )\n        print( 1 )\n        ssk.wait.ms( 500 )\n\n        print( 2 )\n\n        ssk.wait.ms( 500 )\n        print( 3 )\n\n        timer.cancel(source)\n    end), 0)     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Wait In A Timer"
        }, 
        {
            "location": "/rgdocs/", 
            "text": "Redirecting to homepage now...", 
            "title": "RG Docs Home"
        }
    ]
}