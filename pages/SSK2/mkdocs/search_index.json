{
    "docs": [
        {
            "location": "/home/", 
            "text": "Redirecting to homepage now...", 
            "title": "RG Docs (Home)"
        }, 
        {
            "location": "/", 
            "text": "Super Starter Kit 2\n\n\nSSK 2\n SUPERCHARGING the \nCorona SDK\n game development experience every day.\n\n\n\n\n\n\n\n\n\n\nWhat Is It?\n\n\nSuper Starter Kit 2 (aka SSK 2) is a collection libraries and utilities designed to take your development experience to a whole new level of efficiency and speed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGlobals\n\n\nVariables \n functions (optionally) added to the global namespace to speed up and simplify coding.\n\n\n\n\n\n\nExtensions\n\n\nAdds 60+ new and improved features to: \ndisplay.*\n, \nio.*\n, \nmath.*\n, \nstring.*\n, \ntable.*\n, \ntransition.*\n\n\n\n\n\n\nCore\n\n\nLibraries that I quite honestly \ncannot develop without\n: \n(Extended) Display Object builders\n, \nEasy Colors\n, \nEasy Interfaces\n, \nSystem Disovery\n\n\n\n\n\n\nSolutions\n\n\nTop-shelf solutions for common development challenges: \nActions Library\n, \nAndroid Helpers\n, \nScene Cameras\n, \nCollision Calculator\n, \nEasy Inputs\n, \nFiles Library\n, \n2D Math\n, \nPersistence\n, \nPoints Library\n, \nSimple Security\n, \nSharing \n Rating\n, \n... more\n\n\n\n\n\n\n\n\nWhere Can I Get It?\n\n\nYou can find \nSSK 2\n (\nand other quality Roaming Gamer products\n) on the \nCorona Marketplace\n.\n\n\n\n\nWhat About SSK Legacy?\n\n\nYes, my old version of SSK is (and always will be) available for free.  However I do not support it any longer and I am not keeping it up-to-date.\n\n\nSSK 2 on the other hand is everything SSK was in a more performant, flexible, and sexier package.  It works as a standalone library and dove-tails with a number of my co-products.\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "About"
        }, 
        {
            "location": "/#super-starter-kit-2", 
            "text": "SSK 2  SUPERCHARGING the  Corona SDK  game development experience every day.", 
            "title": "Super Starter Kit 2"
        }, 
        {
            "location": "/#what-is-it", 
            "text": "Super Starter Kit 2 (aka SSK 2) is a collection libraries and utilities designed to take your development experience to a whole new level of efficiency and speed.           Globals  Variables   functions (optionally) added to the global namespace to speed up and simplify coding.    Extensions  Adds 60+ new and improved features to:  display.* ,  io.* ,  math.* ,  string.* ,  table.* ,  transition.*    Core  Libraries that I quite honestly  cannot develop without :  (Extended) Display Object builders ,  Easy Colors ,  Easy Interfaces ,  System Disovery    Solutions  Top-shelf solutions for common development challenges:  Actions Library ,  Android Helpers ,  Scene Cameras ,  Collision Calculator ,  Easy Inputs ,  Files Library ,  2D Math ,  Persistence ,  Points Library ,  Simple Security ,  Sharing   Rating ,  ... more", 
            "title": "What Is It?"
        }, 
        {
            "location": "/#where-can-i-get-it", 
            "text": "You can find  SSK 2  ( and other quality Roaming Gamer products ) on the  Corona Marketplace .", 
            "title": "Where Can I Get It?"
        }, 
        {
            "location": "/#what-about-ssk-legacy", 
            "text": "Yes, my old version of SSK is (and always will be) available for free.  However I do not support it any longer and I am not keeping it up-to-date.  SSK 2 on the other hand is everything SSK was in a more performant, flexible, and sexier package.  It works as a standalone library and dove-tails with a number of my co-products.     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "What About SSK Legacy?"
        }, 
        {
            "location": "/quick_start/", 
            "text": "Installing SSK 2\n\n\nTo use SSK 2, simply:\n\n\n\n\nCopy the ssk2 folder and its contents to the same folder and your main.lua file.\n\n\nAdd this to main.lua at or very near the top of the file:\n\n\n\n\nrequire \nssk2.loadSSK\n\n_G.ssk.init()\n\n\n\n\nNote:\n SSK 2 adds extra features to Lua and Corona so it is best to initialize it \nprior\n to requiring any other libraries or modules.\n\n\nConfiguring SSK 2\n\n\nThe initialization example shown above uses the default settings for SSK 2.  You may want to change that.  \n\n\nssk.init()\n takes an optional table of key-value pairs \n{ key1=value1, ..., keyN=valueN }\n that allows you to configure the myriad options SSK 2 provides.\n\n\nKey-Value Pairs (\ndefault\n):\n\n\n\n\ndebugLevel\n (\n0\n) - Values higher than 0 turn on debug messaging in SSK 2 modules and libraries.\n\n\nValid range: [0, 2]\n\n\n\n\n\n\nexportCore\n (\ntrue\n)  - If set to true, SSK 2 'exports' a number of values into the global (\n_G\n) namespace.  \n\n\nSee SSK \nGlobals\n for more details.\n\n\n\n\n\n\nexportColors\n (\ntrue\n)  - If set to \ntrue\n, SSK 2 'exports' a number of color values and functions into the global (\n_G\n) namespace.  \n\n\nSee SSK \nssk.colors.*\n for more details.\n\n\n\n\n\n\nexportSystem\n (\nfalse\n)  - If set to true, SSK 2 'exports' a number of values into the global (\n_G\n) namespace.  \n\n\nSee \nssk.system.*\n for more details.\n\n\n\n\n\n\ngameFont\n (\nnative.systemFont\n) - SSK 2 uses a 'default' font for buttons and some other features.  You can specify that default font by providing the name of a valid \nttf\n or \notf\n file in this setting.\n\n\nlaunchArgs\n (\nnil\n) - Takes the value \n...\n which is only available in main.lua.  If provided it is used to further refine SSK 2 settings based on what Corona has discovered about the current 'device' and passed on to your app in the launch args.\n\n\nmath2DPlugin\n (\nfalse\n) - If set to \ntrue\n, SSK 2 will try to use the native \nmath2d\n instead of the built-in Lua-only version.  If it cannot find the plugin, it will safely fall back to the Lua version.\n\n\nmeasure\n (\nfalse\n) - If set to \ntrue\n SSK 2 will dump a listing of each library name and size to the console.\n\n\n\n\nExample\n\n\n_G.ssk.init( { launchArgs = ..., \n               measure = true,  \n               gameFont = \nRaleway-Light.ttf\n, \n               math2DPlugin = true,\n               debugLevel = 2 } )\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Quick Start"
        }, 
        {
            "location": "/quick_start/#installing-ssk-2", 
            "text": "To use SSK 2, simply:   Copy the ssk2 folder and its contents to the same folder and your main.lua file.  Add this to main.lua at or very near the top of the file:   require  ssk2.loadSSK \n_G.ssk.init()  Note:  SSK 2 adds extra features to Lua and Corona so it is best to initialize it  prior  to requiring any other libraries or modules.", 
            "title": "Installing SSK 2"
        }, 
        {
            "location": "/quick_start/#configuring-ssk-2", 
            "text": "The initialization example shown above uses the default settings for SSK 2.  You may want to change that.    ssk.init()  takes an optional table of key-value pairs  { key1=value1, ..., keyN=valueN }  that allows you to configure the myriad options SSK 2 provides.", 
            "title": "Configuring SSK 2"
        }, 
        {
            "location": "/quick_start/#key-value-pairs-default", 
            "text": "debugLevel  ( 0 ) - Values higher than 0 turn on debug messaging in SSK 2 modules and libraries.  Valid range: [0, 2]    exportCore  ( true )  - If set to true, SSK 2 'exports' a number of values into the global ( _G ) namespace.    See SSK  Globals  for more details.    exportColors  ( true )  - If set to  true , SSK 2 'exports' a number of color values and functions into the global ( _G ) namespace.    See SSK  ssk.colors.*  for more details.    exportSystem  ( false )  - If set to true, SSK 2 'exports' a number of values into the global ( _G ) namespace.    See  ssk.system.*  for more details.    gameFont  ( native.systemFont ) - SSK 2 uses a 'default' font for buttons and some other features.  You can specify that default font by providing the name of a valid  ttf  or  otf  file in this setting.  launchArgs  ( nil ) - Takes the value  ...  which is only available in main.lua.  If provided it is used to further refine SSK 2 settings based on what Corona has discovered about the current 'device' and passed on to your app in the launch args.  math2DPlugin  ( false ) - If set to  true , SSK 2 will try to use the native  math2d  instead of the built-in Lua-only version.  If it cannot find the plugin, it will safely fall back to the Lua version.  measure  ( false ) - If set to  true  SSK 2 will dump a listing of each library name and size to the console.", 
            "title": "Key-Value Pairs (default):"
        }, 
        {
            "location": "/quick_start/#example", 
            "text": "_G.ssk.init( { launchArgs = ..., \n               measure = true,  \n               gameFont =  Raleway-Light.ttf , \n               math2DPlugin = true,\n               debugLevel = 2 } )     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Example"
        }, 
        {
            "location": "/globals/", 
            "text": "Global Variables\n\n\nA set of variables designed to save typing and time, period.\n\n\n\n\n\n\n\n\nVariable(s)\n\n\nEquivalent To\n\n\n\n\n\n\n\n\n\n\nw, h\n\n\ndisplay.contentWidth\n, \ndisplay.contentHeight\n\n\n\n\n\n\ncenterX, centerY\n\n\ndisplay.actualContentWidth\n, \ndisplay.actualContentWidth\n\n\n\n\n\n\nfullw, fullh\n\n\ndisplay.actualContentWidth\n, \ndisplay.actualContentWidth\n\n\n\n\n\n\nunusedWidth, unusedHeight\n\n\nfullw - w\n and \nfullh - h\n respetively.\n\n\n\n\n\n\nleft, right, top, bottom\n\n\nCalculated\n positions for the true edges of the screen, regardless of scaling used.\n\n\n\n\n\n\n\n\nGlobal Functions\n\n\nRuntime:* Improvements\n\n\nThe following functions improve on the Runtime:* event functions.\n\n\n\n\n\n\n\n\nSyntax\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\nlisten( name, listener )\n\n\nShorthand equivalent to \nRuntime:addEventListner( event, listener )\n\n\n\n\n\n\nignore( name, listener )\n\n\nShorthand equivalent to \nRuntime:removeEventListner( event, listener )\n\n\n\n\n\n\nignoreList( list, obj )\n\n\nRemoves all listeners in table \nlist\n if found on \nobj\n.\n\n\n\n\n\n\npost( name, [ params [, debuglvl ]] )\n\n\nDispatches \nname\n event with optional \nparams\n table.\n\n\n\n\n\n\nautoIgnore( name, obj )\n\n\nStop listening for \nname\n event if \nobj\n is \ninvalid\n.\n\n\n\n\n\n\n\n\nGeneral\n\n\nA (small) set of utility functions that I use very frequently.\n\n\n\n\n\n\n\n\nSyntax\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\nfnn( ... )\n\n\nReturn first argument from list that is not nil.\n\n\n\n\n\n\nround( val [ , n  ])\n\n\nRounds a number to the nearest decimal place.\n\n\n\n\n\n\nnextFrame( func )\n\n\nExecute func in new frame. (Credit: \nSergey Lerg\n)\n\n\n\n\n\n\n\n\nStop Exporting Globals\n\n\nThe functions and variables listed above are part of ssk.core.*.  I export them as globals because I find them extremely useful.\n\n\nIf, on the other hand, you feel this 'pollutes' the global space, you can disable exporting.  Simply set \nexportCore\n to \nfalse\n when initializing SSK.\n\n\n_G.ssk.init( { exportCore = false } )\n\n\n\n\nSamples\n\n\nEFM SAMPLE USAGES OF ABOVE\n\n\nSystem Globals\n\n\nEFM Placeholder\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Globals"
        }, 
        {
            "location": "/globals/#global-variables", 
            "text": "A set of variables designed to save typing and time, period.     Variable(s)  Equivalent To      w, h  display.contentWidth ,  display.contentHeight    centerX, centerY  display.actualContentWidth ,  display.actualContentWidth    fullw, fullh  display.actualContentWidth ,  display.actualContentWidth    unusedWidth, unusedHeight  fullw - w  and  fullh - h  respetively.    left, right, top, bottom  Calculated  positions for the true edges of the screen, regardless of scaling used.", 
            "title": "Global Variables"
        }, 
        {
            "location": "/globals/#global-functions", 
            "text": "", 
            "title": "Global Functions"
        }, 
        {
            "location": "/globals/#runtime-improvements", 
            "text": "The following functions improve on the Runtime:* event functions.     Syntax  Summary      listen( name, listener )  Shorthand equivalent to  Runtime:addEventListner( event, listener )    ignore( name, listener )  Shorthand equivalent to  Runtime:removeEventListner( event, listener )    ignoreList( list, obj )  Removes all listeners in table  list  if found on  obj .    post( name, [ params [, debuglvl ]] )  Dispatches  name  event with optional  params  table.    autoIgnore( name, obj )  Stop listening for  name  event if  obj  is  invalid .", 
            "title": "Runtime:* Improvements"
        }, 
        {
            "location": "/globals/#general", 
            "text": "A (small) set of utility functions that I use very frequently.     Syntax  Summary      fnn( ... )  Return first argument from list that is not nil.    round( val [ , n  ])  Rounds a number to the nearest decimal place.    nextFrame( func )  Execute func in new frame. (Credit:  Sergey Lerg )", 
            "title": "General"
        }, 
        {
            "location": "/globals/#stop-exporting-globals", 
            "text": "The functions and variables listed above are part of ssk.core.*.  I export them as globals because I find them extremely useful.  If, on the other hand, you feel this 'pollutes' the global space, you can disable exporting.  Simply set  exportCore  to  false  when initializing SSK.  _G.ssk.init( { exportCore = false } )", 
            "title": "Stop Exporting Globals"
        }, 
        {
            "location": "/globals/#samples", 
            "text": "EFM SAMPLE USAGES OF ABOVE", 
            "title": "Samples"
        }, 
        {
            "location": "/globals/#system-globals", 
            "text": "EFM Placeholder     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "System Globals"
        }, 
        {
            "location": "/extensions/", 
            "text": "SSK extends a number of Lua and Corona libraries/functions.  \n\n\ndisplay.*\n\n\n\n\n\n\n\n\nFunction\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\nnewContainer( ... )\n\n\nAdds flags \n__isContainer = true\n and \n__isGroup = true\n to returned container.\n\n\n\n\n\n\nnewGroup()\n\n\nAdds flags \n__isContainer = false\n and \n__isGroup = true\n to returned group.\n\n\n\n\n\n\n\n\nio.*\n\n\nNote:\n Unless otherwise specified, if a function takes the (optional) argument \nbase\n, it defaults to \nsystem.DocumentsDirectory\n\n\n\n\n\n\n\n\nFunction\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\nappendFile( dataToWrite, fileName [ , base ] )\n\n\nAppend the contents of string \ndataToWrite\n to the file \nfileName\n, creating file if it does not exist.\n\n\n\n\n\n\ncleanFileName( filename )\n\n\nCleans the string \nfilename\n to ensure it is safe for use as a file name in all OSes targted by Corona SDK.\n\n\n\n\n\n\nexists( fileName [, base ] )\n\n\nReturns \ntrue\n if path exists.\n\n\n\n\n\n\nmkdir( dirName [, base ] )\n\n\nMake a new directory with the name \ndirName\n.  (\nWarning:\n Parent folders must be created first for compound paths.)\n\n\n\n\n\n\nreadFile( fileName [, base ] )\n\n\nReturns contents of file at \nfileName\n as string.\n\n\n\n\n\n\nreadFileTable( fileName [, base ] )\n\n\nRead the contens of fileName and return it as a table, where each entry is a line from the file.  Lines are separated by newline (\n\\n\n).\n\n\n\n\n\n\nrepairPath( path )\n\n\nChanges 'slashes' in path to match current OS specifications.\n\n\n\n\n\n\nwriteFile( dataToWrite, fileName [ , base ] )\n\n\nWrite the contents of string \ndataToWrite\n to the file \nfileName\n.\n\n\n\n\n\n\n\n\nmath.*\n\n\n\n\n\n\n\n\nFunction\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\ngetUID( rlen )\n\n\nGenerates and returns a unique ID of length \nrlen\n.  \nWarning:\n With a \nrlen\n of 12 or higher, it is extremely unlikely you will get an id collision, but it is your responsibility to track your prior IDs and verify no collision occurs.\n\n\n\n\n\n\nhaversine_dist( lat1, lng1, lat2, lng2 [, R ] )\n\n\nCalculate the distance from GPS position to another. Distance is a multiple of R (default is 6373 kilometers == 3961 miles.)\n\n\n\n\n\n\nnormRot( toNorm )\n (number)\n\n\nModifies number \ntoNorm\n and returns equivalent angle in range [0,360).\n\n\n\n\n\n\nnormRot( toNorm )\n (display object)\n\n\nModifies display object \ntoNorm\n, such that \nrotation\n is an equivalent value in range [0,360).\n\n\n\n\n\n\n\n\nstring.*\n\n\n\n\n\n\n\n\nFunction\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\ncomma_value( num )\n\n\nReturns a nicely comma-separated string version of number \nnum\n.\n\n\n\n\n\n\nendswith( str, piece)\n\n\nReturn \ntrue\n if \nstr\n ends with \npiece\n. Credit: https://gist.github.com/Lerg\n\n\n\n\n\n\nfirst_upper( str )\n\n\nConvert first letter in \nstr\n to upper-case.\n\n\n\n\n\n\nlpad( str, len [, char] )\n\n\nPlaces padding on left side of a string, such that the new string is at  least len characters long.\n\n\n\n\n\n\nmerge( t )\n\n\nReturn a string containing all entries in an indexed table concatenated together.\n\n\n\n\n\n\nprintf( ... )\n\n\nReplicates C-language printf().\n\n\n\n\n\n\nrpad( str, len [, char] )\n\n\nPlaces padding on right side of a string, such that the new string is at least len characters long.\n\n\n\n\n\n\nspaces2underbars( str )\n\n\nReturns string converting all spaces (\n) in \nstr\n to underbars (\n_\n).\n\n\n\n\n\n\nsplit( str, tok)\n\n\nSplit \nstr\n into a table, where elements in the string are separated by the token \ntok\n.\n\n\n\n\n\n\nstartswith( str, piece)\n\n\nReturn \ntrue\n if \nstr\n starts with \npiece\n. Credit: https://gist.github.com/Lerg\n\n\n\n\n\n\ntrim( str )\n\n\nRemove all whitespace from beginning and end of \nstr\n. Credit: https://gist.github.com/Lerg\n\n\n\n\n\n\ntruncate( str, maxLen [, appendMe ] )\n\n\nShorten \nstr\n to maxLen and optionally append \nappendMe\n to indicate string has been truncated.\n\n\n\n\n\n\nunderbars2spaces( str )\n\n\nReturns string converting all underbars (\n_\n) in \nstr\n to spaces (\n).\n\n\n\n\n\n\nurl_decode( str )\n\n\nReturns URL decoded version of \nstr\n.\n\n\n\n\n\n\nurl_encode( str )\n\n\nReturns URL encoded version of \nstr\n.\n\n\n\n\n\n\n\n\nTorque Derived String Functions\n\n\nI added a number of functions to string.* based on same-named functions from Torque.  These functions operate on:\n\n\n\n\nWords - Strings containing elements separated by a space (\n).\n\n\nFields - Strings containing elements separated by a tab (\n\\t\n)\n\n\nRecords - Strings containing elements separated by a newline (\n\\n\n)\n\n\n\n\n\n\n\n\n\n\nFunction\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\ngetWord( str [, index ] )\n\n\nReturns \nindex\n (\n1\n) word in \nstr\n.\n\n\n\n\n\n\ngetWordCount( str )\n\n\nCounts words in \nstr\n.\n\n\n\n\n\n\ngetWords( str, [ index [, endindex ]] )\n\n\nReturns a string containing all words in \nstr\n between \nindex\n (\n1\n) and \nendindex\n (\nlast word\n).\n\n\n\n\n\n\nsetWord( str, [ index [, replace ]] )\n\n\nReturns a string where the word in \nstr\n at \nindex\n (\n1\n) has been replaced with the string \nreplace\n (\nnil\n).\n\n\n\n\n\n\ngetField( str [, index ] )\n\n\nField\n equivalent of \ngetWord()\n\n\n\n\n\n\ngetFieldCount( str )\n\n\nField\n equivalent of \ngetWordCount()\n\n\n\n\n\n\ngetFields( str, [ index [, endindex ]] )\n\n\nField\n equivalent of \ngetWords()\n\n\n\n\n\n\nsetField( str, [ index [, replace ]] )\n\n\nField\n equivalent of \nsetWord()\n\n\n\n\n\n\ngetRecord( str [, index ] )\n\n\nRecord\n equivalent of \ngetWord()\n\n\n\n\n\n\ngetRecordCount( str )\n\n\nRecord\n equivalent of \ngetWordCount()\n\n\n\n\n\n\ngetRecords( str, [ index [, endindex ]] )\n\n\nRecord\n equivalent of \ngetWords()\n\n\n\n\n\n\nsetRecord( str, [ index [, replace ]] )\n\n\nRecord\n equivalent of \nsetWord()\n\n\n\n\n\n\n\n\ntable.*\n\n\nTable Debug Features\n\n\n\n\n\n\n\n\nFunction\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\ndump(theTable [ , padding [ , marker ]]  )\n\n\nDumps indexes and values inside single-level table (for debug) (SORTED).\n\n\n\n\n\n\ndumpu(theTable [ , padding [ , marker ]]  )\n\n\nDumps indexes and values inside single-level table (for debug) (UNSORTED).\n\n\n\n\n\n\nprint_r( t )\n\n\nDumps indexes and values inside multi-level table (for debug)\n\n\n\n\n\n\n\n\nSaving \n Loading Tables\n\n\nNote:\n Unless otherwise specified, if a function takes the (optional) argument \nbase\n, it defaults to \nsystem.DocumentsDirectory\n\n\n\n\n\n\n\n\nFunction\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\nload( fileName [ , base ] )\n\n\nReturns table loaded from file (Uses JSON library as intermediary)\n\n\n\n\n\n\nprettySave( theTable, fileName [ , base ] )\n\n\nSaves table to file as human readable JSON.\n\n\n\n\n\n\nrepairIndicies( theTable )\n\n\nRepair numeric indicies in table that uses numbers and other values for indexing.  Combining index types like this is bad practice if you are going to save() and load() the table.  This function repairs the indices after a load.\n\n\n\n\n\n\nsave( theTable, fileName [ , base ] )\n\n\nSaves table to file (Uses JSON library as intermediary)\n\n\n\n\n\n\nsecure_save( theTable, fileName [ , base ] )\n\n\nEquivalent to save(), but uses ssk.security.* to obfuscate save.\n\n\n\n\n\n\nsecure_load( theTable, fileName [ , base ] )\n\n\nEquivalent to load(), but uses ssk.security.* to obfuscate save.\n\n\n\n\n\n\nstripSave( theTable, fileName [ , base ] )\n\n\nSaves table to file (Uses JSON library as intermediary)\n\n\n\n\n\n\n\n\nTable Utilities\n\n\n\n\n\n\n\n\nFunction\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\ncombineUnique( ... )\n\n\nCombines n tables into a single table containing only unique members from each source table.\n\n\n\n\n\n\ncombineUnique_i( ... )\n\n\nCombines n tables into a single table containing only unique members from each source table.\n\n\n\n\n\n\ncount( t )\n\n\nCounts all entries in table (non-recursive).\n\n\n\n\n\n\ncount_r( t )\n\n\nCounts all entries in table (recursive).\n\n\n\n\n\n\ndeepCopy( src [ , dst ])\n\n\nCopies multi-level tables; handles non-integer indexes; does not copy metatable\n\n\n\n\n\n\ndeepStripCopy( src [ , dst ])\n\n\nCopies multi-level tables, but strips out metatable(s) and  Fields with these value types: functions or userdata; Fields with these these names: _class or __index.\n\n\n\n\n\n\ngetRandom( t )\n\n\nReturn randomly selected entry from table \nt\n.\n\n\n\n\n\n\nmaxIndex( t )\n\n\nDetermine the maximum index of a sparse table.\n\n\n\n\n\n\nremoveByRef( t, obj )\n\n\nLocate entry \nobj\n in numerically indexed table \nt\n and remove it.  Credit: https://gist.github.com/Lerg\n\n\n\n\n\n\nserialize( t )\n\n\nTable Serializer: https://github.com/EmmanuelOga/columns/blob/master/utils/serialize.lua\n\n\n\n\n\n\nshallowCopy( src [ , dst ])\n\n\nCopies single-level tables; handles non-integer indexes; does not copy metatable\n\n\n\n\n\n\nshallowStripCopy( src, dst )\n\n\nCopies single-level tables; handles non-integer indexes; does not copy metatable\n\n\n\n\n\n\nshuffle( t[ , iter ] )\n\n\nRandomizes the order of a numerically indexed (non-sparse) table.  Supply iteration value \niter\n (\n1\n) for better randomizing.\n\n\n\n\n\n\ntoString( t [ , flat ]) )\n\n\nConverts table to string.(serializes it): http://www.jasonschroeder.com/\n\n\n\n\n\n\n\n\ntransition.*\n\n\n\n\n\n\n\n\nFunction\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\ntransition.color( obj, colorFrom, colorTo, time, delay, ease )\n\n\nAdds ability to transition the color of display objects (including text objects) from \nfromColor\n to \ntoColor\n.  \nWarning:\n Does not currently support onComplete.\n\n\n\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Extensions"
        }, 
        {
            "location": "/extensions/#display", 
            "text": "Function  Summary      newContainer( ... )  Adds flags  __isContainer = true  and  __isGroup = true  to returned container.    newGroup()  Adds flags  __isContainer = false  and  __isGroup = true  to returned group.", 
            "title": "display.*"
        }, 
        {
            "location": "/extensions/#io", 
            "text": "Note:  Unless otherwise specified, if a function takes the (optional) argument  base , it defaults to  system.DocumentsDirectory     Function  Summary      appendFile( dataToWrite, fileName [ , base ] )  Append the contents of string  dataToWrite  to the file  fileName , creating file if it does not exist.    cleanFileName( filename )  Cleans the string  filename  to ensure it is safe for use as a file name in all OSes targted by Corona SDK.    exists( fileName [, base ] )  Returns  true  if path exists.    mkdir( dirName [, base ] )  Make a new directory with the name  dirName .  ( Warning:  Parent folders must be created first for compound paths.)    readFile( fileName [, base ] )  Returns contents of file at  fileName  as string.    readFileTable( fileName [, base ] )  Read the contens of fileName and return it as a table, where each entry is a line from the file.  Lines are separated by newline ( \\n ).    repairPath( path )  Changes 'slashes' in path to match current OS specifications.    writeFile( dataToWrite, fileName [ , base ] )  Write the contents of string  dataToWrite  to the file  fileName .", 
            "title": "io.*"
        }, 
        {
            "location": "/extensions/#math", 
            "text": "Function  Summary      getUID( rlen )  Generates and returns a unique ID of length  rlen .   Warning:  With a  rlen  of 12 or higher, it is extremely unlikely you will get an id collision, but it is your responsibility to track your prior IDs and verify no collision occurs.    haversine_dist( lat1, lng1, lat2, lng2 [, R ] )  Calculate the distance from GPS position to another. Distance is a multiple of R (default is 6373 kilometers == 3961 miles.)    normRot( toNorm )  (number)  Modifies number  toNorm  and returns equivalent angle in range [0,360).    normRot( toNorm )  (display object)  Modifies display object  toNorm , such that  rotation  is an equivalent value in range [0,360).", 
            "title": "math.*"
        }, 
        {
            "location": "/extensions/#string", 
            "text": "Function  Summary      comma_value( num )  Returns a nicely comma-separated string version of number  num .    endswith( str, piece)  Return  true  if  str  ends with  piece . Credit: https://gist.github.com/Lerg    first_upper( str )  Convert first letter in  str  to upper-case.    lpad( str, len [, char] )  Places padding on left side of a string, such that the new string is at  least len characters long.    merge( t )  Return a string containing all entries in an indexed table concatenated together.    printf( ... )  Replicates C-language printf().    rpad( str, len [, char] )  Places padding on right side of a string, such that the new string is at least len characters long.    spaces2underbars( str )  Returns string converting all spaces ( ) in  str  to underbars ( _ ).    split( str, tok)  Split  str  into a table, where elements in the string are separated by the token  tok .    startswith( str, piece)  Return  true  if  str  starts with  piece . Credit: https://gist.github.com/Lerg    trim( str )  Remove all whitespace from beginning and end of  str . Credit: https://gist.github.com/Lerg    truncate( str, maxLen [, appendMe ] )  Shorten  str  to maxLen and optionally append  appendMe  to indicate string has been truncated.    underbars2spaces( str )  Returns string converting all underbars ( _ ) in  str  to spaces ( ).    url_decode( str )  Returns URL decoded version of  str .    url_encode( str )  Returns URL encoded version of  str .", 
            "title": "string.*"
        }, 
        {
            "location": "/extensions/#torque-derived-string-functions", 
            "text": "I added a number of functions to string.* based on same-named functions from Torque.  These functions operate on:   Words - Strings containing elements separated by a space ( ).  Fields - Strings containing elements separated by a tab ( \\t )  Records - Strings containing elements separated by a newline ( \\n )      Function  Summary      getWord( str [, index ] )  Returns  index  ( 1 ) word in  str .    getWordCount( str )  Counts words in  str .    getWords( str, [ index [, endindex ]] )  Returns a string containing all words in  str  between  index  ( 1 ) and  endindex  ( last word ).    setWord( str, [ index [, replace ]] )  Returns a string where the word in  str  at  index  ( 1 ) has been replaced with the string  replace  ( nil ).    getField( str [, index ] )  Field  equivalent of  getWord()    getFieldCount( str )  Field  equivalent of  getWordCount()    getFields( str, [ index [, endindex ]] )  Field  equivalent of  getWords()    setField( str, [ index [, replace ]] )  Field  equivalent of  setWord()    getRecord( str [, index ] )  Record  equivalent of  getWord()    getRecordCount( str )  Record  equivalent of  getWordCount()    getRecords( str, [ index [, endindex ]] )  Record  equivalent of  getWords()    setRecord( str, [ index [, replace ]] )  Record  equivalent of  setWord()", 
            "title": "Torque Derived String Functions"
        }, 
        {
            "location": "/extensions/#table", 
            "text": "", 
            "title": "table.*"
        }, 
        {
            "location": "/extensions/#table-debug-features", 
            "text": "Function  Summary      dump(theTable [ , padding [ , marker ]]  )  Dumps indexes and values inside single-level table (for debug) (SORTED).    dumpu(theTable [ , padding [ , marker ]]  )  Dumps indexes and values inside single-level table (for debug) (UNSORTED).    print_r( t )  Dumps indexes and values inside multi-level table (for debug)", 
            "title": "Table Debug Features"
        }, 
        {
            "location": "/extensions/#saving-loading-tables", 
            "text": "Note:  Unless otherwise specified, if a function takes the (optional) argument  base , it defaults to  system.DocumentsDirectory     Function  Summary      load( fileName [ , base ] )  Returns table loaded from file (Uses JSON library as intermediary)    prettySave( theTable, fileName [ , base ] )  Saves table to file as human readable JSON.    repairIndicies( theTable )  Repair numeric indicies in table that uses numbers and other values for indexing.  Combining index types like this is bad practice if you are going to save() and load() the table.  This function repairs the indices after a load.    save( theTable, fileName [ , base ] )  Saves table to file (Uses JSON library as intermediary)    secure_save( theTable, fileName [ , base ] )  Equivalent to save(), but uses ssk.security.* to obfuscate save.    secure_load( theTable, fileName [ , base ] )  Equivalent to load(), but uses ssk.security.* to obfuscate save.    stripSave( theTable, fileName [ , base ] )  Saves table to file (Uses JSON library as intermediary)", 
            "title": "Saving &amp; Loading Tables"
        }, 
        {
            "location": "/extensions/#table-utilities", 
            "text": "Function  Summary      combineUnique( ... )  Combines n tables into a single table containing only unique members from each source table.    combineUnique_i( ... )  Combines n tables into a single table containing only unique members from each source table.    count( t )  Counts all entries in table (non-recursive).    count_r( t )  Counts all entries in table (recursive).    deepCopy( src [ , dst ])  Copies multi-level tables; handles non-integer indexes; does not copy metatable    deepStripCopy( src [ , dst ])  Copies multi-level tables, but strips out metatable(s) and  Fields with these value types: functions or userdata; Fields with these these names: _class or __index.    getRandom( t )  Return randomly selected entry from table  t .    maxIndex( t )  Determine the maximum index of a sparse table.    removeByRef( t, obj )  Locate entry  obj  in numerically indexed table  t  and remove it.  Credit: https://gist.github.com/Lerg    serialize( t )  Table Serializer: https://github.com/EmmanuelOga/columns/blob/master/utils/serialize.lua    shallowCopy( src [ , dst ])  Copies single-level tables; handles non-integer indexes; does not copy metatable    shallowStripCopy( src, dst )  Copies single-level tables; handles non-integer indexes; does not copy metatable    shuffle( t[ , iter ] )  Randomizes the order of a numerically indexed (non-sparse) table.  Supply iteration value  iter  ( 1 ) for better randomizing.    toString( t [ , flat ]) )  Converts table to string.(serializes it): http://www.jasonschroeder.com/", 
            "title": "Table Utilities"
        }, 
        {
            "location": "/extensions/#transition", 
            "text": "Function  Summary      transition.color( obj, colorFrom, colorTo, time, delay, ease )  Adds ability to transition the color of display objects (including text objects) from  fromColor  to  toColor .   Warning:  Does not currently support onComplete.        Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "transition.*"
        }, 
        {
            "location": "/libraries/", 
            "text": "SSK2 Quick Reference\n\n\nAn dummy page\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Alphabetic Index"
        }, 
        {
            "location": "/libraries/#ssk2-quick-reference", 
            "text": "An dummy page     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "SSK2 Quick Reference"
        }, 
        {
            "location": "/libraries/colors/", 
            "text": "Colors Library (ssk.colors.*)\n\n\nEasy Colors (ssk.colors.easy.*)\n\n\nTip:\n These variables are exported as globals when SSK \ninit()\n parameter \nexportColors\n is \ntrue\n.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n_WHITE_\n, \n_W_\n\n\n_BLACK_\n, \n_K_\n\n\n_TRANSPARENT_\n, \n_T_\n\n\n\n\n\n\n_RED_\n, \n_R_\n\n\n_GREEN_\n, \n_G_\n\n\n_BLUE_\n, \n_B_\n\n\n\n\n\n\n_LIGHTGREY_\n\n\n_GREY_\n\n\n_DARKGREY_\n\n\n\n\n\n\n_CYAN_\n, \n_C_\n\n\n_YELLOW_\n, \n_Y_\n\n\n_ORANGE_\n, \n_O_\n\n\n\n\n\n\n_PURPLE_\n\n\n_PINK_\n, \n_P_\n\n\n\n\n\n\n\n\n\n\n\nlocal circ = display.newCircle( 100, 100, 100 )\n\nrect:setFillColor( unpack( _PURPLE_ ) )\n\n\n\n\n\nColor Helpers and Utilities (ssk.colors.*)\n\n\n\n\nhexcolor( code )\n - converts hex color codes to rgba Graphics 2.0 value\n\n\nrandomColor( )\n - Returns random  color selected from 'Easy Colors'.\n\n\nrgba2( colors )\n - Converts Graphics 1.0 color table to a valid Graphics 2.0 color table.\n\n\n\n\n\nlocal rect1 = display.newRect( 100, 100, 100, 100 )\nlocal rect2 = display.newRect( 100, 100, 200, 100 )\nlocal rect3 = display.newRect( 100, 100, 300, 100 )\n\n-- Set fill color to a nice blue\nrect1:setFillColor( unpack( hexcolor( \n33AFFF\n ) ) )\n\n-- Choose a random Easy Color as the fill\nrect2:setFillColor( unpack( randomColor() ) )\n\n-- Set color to Graphics 1.0 encoded 'Pink'\nrect3:setFillColor( unpack( rgba2( { 255, 0, 255 } ) ) )\n\n\n\n\n\nRGB Functions (ssk.colors.*)\n\n\n\n\nrgb2hsl( r, g, b, a )\n - Convert RGB color to HSL color table.\n\n\nmixRGB( c1, c2 )\n - Evenly mix two RGBa colors.\n\n\nrandomRGB( [ c1 ] )\n - Generates a random RGB color.  If optional c1 is passed in, it is mixed evenly with the random color.\n\n\npastelRGB( [ c1 ] )\n - Generates a random RGB pastel color.  If optional c1 is passed in, it is mixed evenly with the random color.\n\n\nrgbOffset( r, g, b, a, angle )\n - Converts RGB color to HSL and applies hueOffset()\n\n\nrgbNeighbors( r, g, b, a, angle )\n - Converts RGB color to HSL and applies hslNeighbors(), then returns two rgb colors.\n\n\nrgbTriadic( r, g, b, a )\n - Converts RGB color to HSL and applies hslTriadic(), then returns two rgb colors.\n\n\nrgbSplitComplementary( r, g, b, a, angle )\n - Converts RGB color to HSL and applies hslSplitComplementary(), then returns two rgb colors.\n\n\n\n\nHSL Functions (ssk.colors.*)\n\n\n\n\nhsl2rgb( h, s, l, a )\n - Convert HSL color to RGB color table.\n\n\nhueOffset( h, s, l, a, angle )\n - Rotate hue by 'angle' degrees\n\n\nhslNeighbors( h, s, l, a, angle )\n - Return two arbitray angle neighbors (left and right by angle)\n\n\nhslTriadic( h, s, l, a )\n - Return two triadic neighbors of color\n\n\nhslSplitComplementary( h, s, l, a, angle )\n - Return two complementary split angle colors. \n\n\n\n\nExample 1 - RGB \n HSL\n\n\n\n\nfunction test.run( group, params )\n   group = group or display.currentStage\n   params = params or {}\n\n   local startX = left + 100\n   local startY = top + 100\n\n   local curX = startX\n   local curY = startY\n\n   -- ==============================================\n   -- Row 1 - Test conversions\n    -- ==============================================\n\n    -- RGB 2 HSL \n HSL 2 RGB\n    curX = startX\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_G_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_B_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_O_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_Y_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_P_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_PURPLE_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_GREY_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n\n   -- ==============================================\n   -- Row 2 - Test HSL HUE Offset\n    -- ==============================================\n\n    -- hueOffset\n    curX = startX\n    curY = curY + 100\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c1 = ssk.colors.hueOffset(c, 60 )\n    local c2 = ssk.colors.hsl2rgb( c1 )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c1 = ssk.colors.hueOffset(c, -60 )\n    local c2 = ssk.colors.hsl2rgb( c1 )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n   -- ==============================================\n   -- Row 3 - Test HSL Neighbors, Triadic, Split Complementary\n    -- ==============================================\n\n    -- hslNeighbors\n    curX = startX\n    curY = curY + 100\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c2,c3 = ssk.colors.hslNeighbors( c, 90 )\n    c2 = ssk.colors.hsl2rgb( c2 )\n    c3 = ssk.colors.hsl2rgb( c3 )   \n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\n\n    -- hslTriadic\n    curX = curX + 100\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c2,c3 = ssk.colors.hslTriadic( c )\n    c2 = ssk.colors.hsl2rgb( c2 )\n    c3 = ssk.colors.hsl2rgb( c3 )   \n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\n\n    -- hslSplitComplementary\n    curX = curX + 100\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c2,c3 = ssk.colors.hslSplitComplementary( c, 30 )\n    c2 = ssk.colors.hsl2rgb( c2 )\n    c3 = ssk.colors.hsl2rgb( c3 )   \n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\n\n   -- ==============================================\n   -- Row 4 - Test RGB Offset\n    -- ==============================================\n\n    -- rgbOffset\n    curX = startX\n    curY = curY + 100\n    local c1 = ssk.colors.rgbOffset( _R_, 60 )\n    newRect( group, curX, curY, { size = 80, fill = c1  } )\n\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n\n    curX = curX + 80\n    local c1 = ssk.colors.rgbOffset( _R_, -60 )\n    newRect( group, curX, curY, { size = 80, fill = c1  } )\n\n   -- ==============================================\n   -- Row 5 - Test RGB Neighbors, Triadic, Split Complementary\n    -- ==============================================\n\n    -- hslNeighbors\n    curX = startX\n    curY = curY + 100\n    local c2,c3 = ssk.colors.rgbNeighbors( _R_, 90 )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\n\n    -- rgbTriadic\n    curX = curX + 100\n    local c2,c3 = ssk.colors.rgbTriadic( _R_ )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\n\n    -- rgbSplitComplementary\n    curX = curX + 100\n    local c2,c3 = ssk.colors.rgbSplitComplementary( _R_, 30 )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\nend\n\n\n\n\nExample 2 - Pastels\n\n\n\n\n\nfunction test.run( group, params )\n   group = group or display.currentStage\n   params = params or {}\n\n   local startX = left + 100\n   local startY = top + 100\n\n   local curX = startX\n   local curY = startY\n\n    -- Pastel No Seed Color\n    for i = 1, 3 do\n        curX = startX   \n        for j = 1, 10 do\n            newRect( group, curX, curY, { size = 80, fill = ssk.colors.pastelRGB( )  } )\n            curX = curX + 80\n        end\n        curY = curY + 80\n    end\n\n    curY = curY + 40\n\n    -- Pastel Random Seed Color\n    for i = 1, 3 do\n        curX = startX   \n        for j = 1, 10 do\n            newRect( group, curX, curY, { size = 80, fill = ssk.colors.pastelRGB( randomColor() )  } )\n            curX = curX + 80\n        end\n        curY = curY + 80\n    end\n\nend\n\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.colors.*"
        }, 
        {
            "location": "/libraries/colors/#colors-library-sskcolors", 
            "text": "", 
            "title": "Colors Library (ssk.colors.*)"
        }, 
        {
            "location": "/libraries/colors/#easy-colors-sskcolorseasy", 
            "text": "Tip:  These variables are exported as globals when SSK  init()  parameter  exportColors  is  true .            _WHITE_ ,  _W_  _BLACK_ ,  _K_  _TRANSPARENT_ ,  _T_    _RED_ ,  _R_  _GREEN_ ,  _G_  _BLUE_ ,  _B_    _LIGHTGREY_  _GREY_  _DARKGREY_    _CYAN_ ,  _C_  _YELLOW_ ,  _Y_  _ORANGE_ ,  _O_    _PURPLE_  _PINK_ ,  _P_      \nlocal circ = display.newCircle( 100, 100, 100 )\n\nrect:setFillColor( unpack( _PURPLE_ ) )", 
            "title": "Easy Colors (ssk.colors.easy.*)"
        }, 
        {
            "location": "/libraries/colors/#color-helpers-and-utilities-sskcolors", 
            "text": "hexcolor( code )  - converts hex color codes to rgba Graphics 2.0 value  randomColor( )  - Returns random  color selected from 'Easy Colors'.  rgba2( colors )  - Converts Graphics 1.0 color table to a valid Graphics 2.0 color table.   \nlocal rect1 = display.newRect( 100, 100, 100, 100 )\nlocal rect2 = display.newRect( 100, 100, 200, 100 )\nlocal rect3 = display.newRect( 100, 100, 300, 100 )\n\n-- Set fill color to a nice blue\nrect1:setFillColor( unpack( hexcolor(  33AFFF  ) ) )\n\n-- Choose a random Easy Color as the fill\nrect2:setFillColor( unpack( randomColor() ) )\n\n-- Set color to Graphics 1.0 encoded 'Pink'\nrect3:setFillColor( unpack( rgba2( { 255, 0, 255 } ) ) )", 
            "title": "Color Helpers and Utilities (ssk.colors.*)"
        }, 
        {
            "location": "/libraries/colors/#rgb-functions-sskcolors", 
            "text": "rgb2hsl( r, g, b, a )  - Convert RGB color to HSL color table.  mixRGB( c1, c2 )  - Evenly mix two RGBa colors.  randomRGB( [ c1 ] )  - Generates a random RGB color.  If optional c1 is passed in, it is mixed evenly with the random color.  pastelRGB( [ c1 ] )  - Generates a random RGB pastel color.  If optional c1 is passed in, it is mixed evenly with the random color.  rgbOffset( r, g, b, a, angle )  - Converts RGB color to HSL and applies hueOffset()  rgbNeighbors( r, g, b, a, angle )  - Converts RGB color to HSL and applies hslNeighbors(), then returns two rgb colors.  rgbTriadic( r, g, b, a )  - Converts RGB color to HSL and applies hslTriadic(), then returns two rgb colors.  rgbSplitComplementary( r, g, b, a, angle )  - Converts RGB color to HSL and applies hslSplitComplementary(), then returns two rgb colors.", 
            "title": "RGB Functions (ssk.colors.*)"
        }, 
        {
            "location": "/libraries/colors/#hsl-functions-sskcolors", 
            "text": "hsl2rgb( h, s, l, a )  - Convert HSL color to RGB color table.  hueOffset( h, s, l, a, angle )  - Rotate hue by 'angle' degrees  hslNeighbors( h, s, l, a, angle )  - Return two arbitray angle neighbors (left and right by angle)  hslTriadic( h, s, l, a )  - Return two triadic neighbors of color  hslSplitComplementary( h, s, l, a, angle )  - Return two complementary split angle colors.", 
            "title": "HSL Functions (ssk.colors.*)"
        }, 
        {
            "location": "/libraries/colors/#example-1-rgb-hsl", 
            "text": "function test.run( group, params )\n   group = group or display.currentStage\n   params = params or {}\n\n   local startX = left + 100\n   local startY = top + 100\n\n   local curX = startX\n   local curY = startY\n\n   -- ==============================================\n   -- Row 1 - Test conversions\n    -- ==============================================\n\n    -- RGB 2 HSL   HSL 2 RGB\n    curX = startX\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_G_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_B_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_O_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_Y_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_P_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_PURPLE_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_GREY_)\n    local c2 = ssk.colors.hsl2rgb( c )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n\n   -- ==============================================\n   -- Row 2 - Test HSL HUE Offset\n    -- ==============================================\n\n    -- hueOffset\n    curX = startX\n    curY = curY + 100\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c1 = ssk.colors.hueOffset(c, 60 )\n    local c2 = ssk.colors.hsl2rgb( c1 )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n\n    curX = curX + 80\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c1 = ssk.colors.hueOffset(c, -60 )\n    local c2 = ssk.colors.hsl2rgb( c1 )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n\n   -- ==============================================\n   -- Row 3 - Test HSL Neighbors, Triadic, Split Complementary\n    -- ==============================================\n\n    -- hslNeighbors\n    curX = startX\n    curY = curY + 100\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c2,c3 = ssk.colors.hslNeighbors( c, 90 )\n    c2 = ssk.colors.hsl2rgb( c2 )\n    c3 = ssk.colors.hsl2rgb( c3 )   \n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\n\n    -- hslTriadic\n    curX = curX + 100\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c2,c3 = ssk.colors.hslTriadic( c )\n    c2 = ssk.colors.hsl2rgb( c2 )\n    c3 = ssk.colors.hsl2rgb( c3 )   \n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\n\n    -- hslSplitComplementary\n    curX = curX + 100\n    local c = ssk.colors.rgb2hsl(_R_)\n    local c2,c3 = ssk.colors.hslSplitComplementary( c, 30 )\n    c2 = ssk.colors.hsl2rgb( c2 )\n    c3 = ssk.colors.hsl2rgb( c3 )   \n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\n\n   -- ==============================================\n   -- Row 4 - Test RGB Offset\n    -- ==============================================\n\n    -- rgbOffset\n    curX = startX\n    curY = curY + 100\n    local c1 = ssk.colors.rgbOffset( _R_, 60 )\n    newRect( group, curX, curY, { size = 80, fill = c1  } )\n\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n\n    curX = curX + 80\n    local c1 = ssk.colors.rgbOffset( _R_, -60 )\n    newRect( group, curX, curY, { size = 80, fill = c1  } )\n\n   -- ==============================================\n   -- Row 5 - Test RGB Neighbors, Triadic, Split Complementary\n    -- ==============================================\n\n    -- hslNeighbors\n    curX = startX\n    curY = curY + 100\n    local c2,c3 = ssk.colors.rgbNeighbors( _R_, 90 )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\n\n    -- rgbTriadic\n    curX = curX + 100\n    local c2,c3 = ssk.colors.rgbTriadic( _R_ )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\n\n    -- rgbSplitComplementary\n    curX = curX + 100\n    local c2,c3 = ssk.colors.rgbSplitComplementary( _R_, 30 )\n    newRect( group, curX, curY, { size = 80, fill = c2  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = _R_  } )\n    curX = curX + 80\n    newRect( group, curX, curY, { size = 80, fill = c3  } )\nend", 
            "title": "Example 1 - RGB &amp; HSL"
        }, 
        {
            "location": "/libraries/colors/#example-2-pastels", 
            "text": "function test.run( group, params )\n   group = group or display.currentStage\n   params = params or {}\n\n   local startX = left + 100\n   local startY = top + 100\n\n   local curX = startX\n   local curY = startY\n\n    -- Pastel No Seed Color\n    for i = 1, 3 do\n        curX = startX   \n        for j = 1, 10 do\n            newRect( group, curX, curY, { size = 80, fill = ssk.colors.pastelRGB( )  } )\n            curX = curX + 80\n        end\n        curY = curY + 80\n    end\n\n    curY = curY + 40\n\n    -- Pastel Random Seed Color\n    for i = 1, 3 do\n        curX = startX   \n        for j = 1, 10 do\n            newRect( group, curX, curY, { size = 80, fill = ssk.colors.pastelRGB( randomColor() )  } )\n            curX = curX + 80\n        end\n        curY = curY + 80\n    end\n\nend     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Example 2 - Pastels"
        }, 
        {
            "location": "/libraries/display_standard/", 
            "text": "Display Object Factories (ssk.display.*)\n\n\n(\nExcluding the spinning 'color cicle', each object below was created with a single line of code.\n)\n\n\n\nStandard Factories\n\n\nSSK provides a set of improved factories to replace/extend (\n) the traditional \ndisplay.*\n factories:\n\n\n\n\nssk.display.newCircle()\n \n \ndisplay.newCircle()\n\n\nssk.display.newRect()\n \n \ndisplay.newRect()\n\n\nssk.display.newImage()\n \n \ndisplay.newImage()\n\n\nssk.display.newImageRect()\n \n \ndisplay.newImageRect()\n\n\n\n\nThe benefit of these factories over the traditional ones is that a display object can often be fully configured, colorized, have a body added, and even have listeners added, all in one easily-typed and legible line of code.\n\n\nThe SSK Way\n\n\n\nnewImageRect( group, centerX - 100 , centerY - 50,\n              \nimages/kenney/physicsAssets/yellow_round.png\n, { size = 40 }, \n              { radius = 20, bounce = 1, gravityScale = 0.2 } ) \n\nnewImageRect( group, centerX - 100, centerY + 100, \n              \nimages/kenney/physicsAssets/stone/square2.png\n, { size = 40 }, \n              { bodyType = \nstatic\n } ) \n\n\n\n\n\n\n\nThe Old Way - Blech!\n\n\n\nlocal ball = display.newImageRect( group, \nimages/kenney/physicsAssets/yellow_round.png\n, 40, 40 )\nball.x = display.contentCenterX + 100\nball.y = display.contentCenterY - 50\nphysics.addBody( ball, { radius = 20, bounce = 1, radius = 20  } )\nball.gravityScale = 0.2\n\nlocal block = display.newImageRect( group, \nimages/kenney/physicsAssets/stone/square2.png\n, 40, 40 )\nblock.x = display.contentCenterX + 100\nblock.y = display.contentCenterY + 100\nphysics.addBody( block, \nstatic\n )\n\n\n\n\n\nStandard Factory Signatures\n\n\nThese new factories have the following signatures:\n\n\n\n\nssk.display.newCircle( group, x, y [, visualParams [, bodyParams [, behaviorsList ]]] )\n\n\nssk.display.newRect( group, x, y[, visualParams [, bodyParams [, behaviorsList ]]] )\n\n\nssk.display.newImage( group, x, y, imgSrc [, visualParams [, bodyParams [, behaviorsList ]]] )\n\n\nssk.display.newImageRect( group, x, y, imgSrc [, visualParams [, bodyParams [, behaviorsList ]]] )\n\n\n\n\nStandard Factory Arguments\n\n\nAs you will have noticed, the above factories have a fairly consistent function signature and share common arguments.  Those argument can be summarized as follows:\n\n\n\n\ngroup\n - Display group to place object in.  If \nnil\n, object is placed in \ndisplay.currentStage\n.\n\n\nx\n, \ny\n - \n x, y \n position to place object at.\n\n\nimgSrc\n - A string specifying a path to the image you wish to display.\n\n\nvisualParams\n - Table of parameters controlling the look of an object.  \n\n\nSee '\nVisual Parameters\n' below.\n\n\n\n\n\n\nbodyParams\n - Table of parameters controlling the (optional) physics body.  \n\n\nSee '\nBody Parameters\n' below.\n\n\n\n\n\n\nbehaviorsList\n - Table of parameters that allows the easy addition of complex game logic to display objects. \n\n\nSee '\nBehaviors List\n' below. \n\n\nThis \nADVANCED\n feature is not ready for general usage yet.\n\n\n\n\n\n\n\n\nVisual Parameters\n\n\nThe first (common) table that all of these builders takes is the \nvisualParams\n table.  With this table, you can set almost all visual properties on the object and you can also attach or set any arbitrary property.\n\n\nvisualParams\n - 'Standard' Properties\n\n\nAside from the 'custom' and specially handled properties listed above, you may set any normal Corona property as well.\n\n\n\n-- Create a red circle with a 50% alpha\nnewCircle( nil, 100, 100 { fill = _R_, alpha = 0.5 } )\n\n\n\n\n\nSee the Corona docs for the complete list of '\nDisplay Object Properties\n'  (\nexternal link\n).\n\n\nvisualParams\n - 'Custom' Properties\n\n\n\n\ncornerRadius\n (\n0\n) - If specified for \nnewRect()\n, a rounded rectangle (\ndisplay.newRoundedRect\n) will be created.\n\n\ndiameter\n - Sets the radius to half this value for \nnewCircle()\n.\n\n\nfill\n (\n{1,1,1,1}\n) - If specified, assigns a fill to the object. Most standard paint fills are allowed:\n\n\n(Color) Paint: \nfill = { 1, 0, 0, 0.25 }\n\n\nComposite Paint\n (\nexternal link\n)\n\n\nTrick:\n You may specify a \nfillEffect\n property in the composite fill table. (Default \nfillEffect\n is \n\"composite.average\"\n.)\n\n\n\n\n\n\nBitmap Paint\n (\nexternal link\n)\n\n\nGradient Paint\n (\nexternal link\n)\n\n\nNot Supported:\n\n\nImage Sheet Paint\n (\nexternal link\n)\n\n\nCamera Fill Paint\n (\nexternal link\n)\n\n\n\n\n\n\n\n\n\n\nradius\n (\n20\n) - Sets the radius for \nnewCircle()\n.\n\n\nscale\n - If specified, the object will be scaled in the x- and y-dimension by this factor.\n\n\nTip:\n Overrides \nxScale\n and \nyScale\n parameters.\n\n\n\n\n\n\nsize\n - Sets width and height of rectangular objects.  If calling \nnewCircle()\n the radius is computed as half the \nsize\n.\n\n\nw\n and \nh\n parameters override this.\n\n\n\n\n\n\nstroke\n (\n{1,1,1,1}\n) - If specified, sets the stroke color of the display object.\n\n\nTip:\n Supports same paint fill types as \nfill\n parameter.\n\n\n\n\n\n\nstrokeWidth\n (\n0\n) - If specified, sets the stroke width of the display object.\n\n\nw\n, \nh\n (\n40\n) - Width and height.\n\n\n\n\nvisualParams\n - 'Listeners'\n\n\nIn addition to being able to set many visual properties via the \nvisualParams\n table, you can supply function references to the following property names:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\naccelerometer\n\n\naxis\n\n\ncollision\n\n\nenterFrame\n\n\n\n\n\n\nfinalize\n\n\nkey\n\n\nmouse\n\n\nsprite\n\n\n\n\n\n\ntap\n\n\ntimer\n\n\ntouch\n\n\n\n\n\n\n\n\n\n\nIf any of these parameters is specified, SSK will automatically hook-up and start the specified listener(s).\n\n\nNote:\n Only works if \nenableAutoListeners = true\n.  See \nConfigurins SSK 2\n.\n\n\nListener Example 1 - \ntouch\n\n\n\nlocal function onTouch( self, event)\n   if( event.phase == \nended\n ) then\n      print(\nMy name is: \n .. self.myName )\n   end\n   return false\nend\n\nlocal tmp = newRect( nil, 100, 100, { touch = onTouch, myName = \nRect 1\n }) \n\nlocal tmp = newRect( nil, 200, 100, { touch = onTouch, myName = \nRect 2\n })\n\n\n\n\n\nNow, if you touch either of the two rectangles created by this code, they will print: \nMy name is: Rect 1\n or  \nMy name is: Rect 2\n\n\nListener Example 2 - \nenterFrame\n\n\n\nlocal function onEnterFrame( self )\n\n   self.x = self.x + 1\n\n   if( self.x \n= right ) then\n\n      self.x = right\n\n      ignore( \nenterFrame\n, self )\n\n      self.enterFrame = nil\n\n    end\n\nend\n\nnewCircle( nil, left, centerY, { enterFrame = onEnterFrame } )\n\n\n\n\n\nThe sample above created a white circle with a radius of 20 pixels, on the very left-edge of the screen and vertically centered.\n\n\nAs soon as it was created, the circle immediately started moving one pixel to the right every frame.  \n\n\nOnce it reacheed the right-edge of the screen it will stop and remove the listener.\n\n\nvisualParams\n - 'Arbitrary' Properties\n\n\nLastly, as you may have noticed in the prior section, \nvisualParams\n can take any arbitrary property name and assign a value to it.  This is extremely handy for setting flags and other values used later in your code.\n\n\n\nlocal tmp = newRect( nil, 100, 100, { myName = \nBob\n, myAge = 21, amHappy = true }) \n\nprint( tmp.myName, tmp.myAge, tmp.amHappy )\n\n\n\n\n\nBody Parameters\n\n\nThe second optional table you can pass to all of the builder functions is the \nbodyParams\n table.\n\n\nbodyParams\n - The Default Body \n{}\n\n\nSpecifying an empty table tell SSK to add a default body to the object.\n\n\n\nnewCircle( nil, 100, 100, { radius = 50 }, {} )\n\nnewRect( nil, 100, 100, { w = 50, h = 20 }, {} )\n\n\n\n\n\nAfter the prior code executes, we will have a circle and a rectangle, both with default bodies.\n\n\nThe circle will have a circular body and the rectangle will have a rectangular body that matches the dimensions of the rectangle.\n\n\nBoth bodies will have this (default) physics configuration:\n\n\n\n\nbodyType = \"dynamic\"\n\n\nbounce = 0.2\n\n\ndensity = 1.0\n\n\nfriction = 0.3\n\n\nlinearDamping = 0\n\n\ngravityScale = 1\n\n\nisSleepingAllowed = true\n\n\nisSensor = false\n\n\nisBullet = false\n\n\nisFixedRotation = false\n\n\n\n\nbodyParams\n - 'Standard' Properties\n\n\nAs with \nvisualParams\n, you may pass key-value pairs in this table to set properties.  These properties include all the standard Physics property.\n\n\n\n-- Create a circle with a static body that is also a sensor\nnewCircle( nil, 100, 100, { radius = 50 }, { bodyType = \nstatic\n, isSensor = true } )\n\n\n\n\n\nSee the Corona docs for a full list of '\nPhysics Body Properties\n'  (\nexternal link\n).\n\n\nbodyParams\n - 'Custom' Properties\n\n\nBesides the many 'Standard' properties supported by Corona and SSK, you can specify these custom properties too:\n\n\n\n\ncalculator\n - A reference to an SSK collision calculator object.\n\n\ncolliderName\n - 'Name' of this object's type (must be specified in calculator.)\n\n\nuseOutline\n - Tells the body to use the objects image file as its shape.  \n\n\nOnly works for \nnewImage()\n and \nnewImageRect()\n.\n\n\n\n\n\n\npillParams\n - A special that tells SSK to construct a 'pill shaped' body. Pass an empty table (\n{}\n) for the default pill shape, or pass a table with any of the following parameters to modify that shape.\n\n\ncorner\n (\n0.15\n) - Amount to subtract/add from/to edges of pill.\n\n\nxScale\n, \nxScale\n (\n1\n)- Scale the shape in either dimension, x and/or y.\n\n\noffsetY\n (\n0\n)- Give the shape a vertical offset.\n\n\noffsetY\n (\n0\n)- Give the shape a horizontal offset.\n\n\n\n\n\n\n\n\n\n-- Make a circle that uses the 'player' settings from a previously created and configured Collision Calculator.\nnewCircle( nil, 100, 100, { radius = 50 }, { calculator = myCC, colliderName = \nplayer\n } )\n\n\n\n\n\nbehaviorsList\n - Behaviors List\n\n\nThis is a work-in-progress feature.\n\n\nWhen it is released, you will be able to create objects with complex behaviors like:\n\n\n\n\nDrag-and-Drop - Attach robust drag-and-drop logic to the object.\n\n\nAsteroids-Player - Create a one-line asteroids player. \n\n\n...  \n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.display.* (Standard Factories)"
        }, 
        {
            "location": "/libraries/display_standard/#display-object-factories-sskdisplay", 
            "text": "( Excluding the spinning 'color cicle', each object below was created with a single line of code. )", 
            "title": "Display Object Factories (ssk.display.*)"
        }, 
        {
            "location": "/libraries/display_standard/#standard-factories", 
            "text": "SSK provides a set of improved factories to replace/extend ( ) the traditional  display.*  factories:   ssk.display.newCircle()     display.newCircle()  ssk.display.newRect()     display.newRect()  ssk.display.newImage()     display.newImage()  ssk.display.newImageRect()     display.newImageRect()   The benefit of these factories over the traditional ones is that a display object can often be fully configured, colorized, have a body added, and even have listeners added, all in one easily-typed and legible line of code.", 
            "title": "Standard Factories"
        }, 
        {
            "location": "/libraries/display_standard/#the-ssk-way", 
            "text": "newImageRect( group, centerX - 100 , centerY - 50,\n               images/kenney/physicsAssets/yellow_round.png , { size = 40 }, \n              { radius = 20, bounce = 1, gravityScale = 0.2 } ) \n\nnewImageRect( group, centerX - 100, centerY + 100, \n               images/kenney/physicsAssets/stone/square2.png , { size = 40 }, \n              { bodyType =  static  } )", 
            "title": "The SSK Way"
        }, 
        {
            "location": "/libraries/display_standard/#the-old-way-blech", 
            "text": "local ball = display.newImageRect( group,  images/kenney/physicsAssets/yellow_round.png , 40, 40 )\nball.x = display.contentCenterX + 100\nball.y = display.contentCenterY - 50\nphysics.addBody( ball, { radius = 20, bounce = 1, radius = 20  } )\nball.gravityScale = 0.2\n\nlocal block = display.newImageRect( group,  images/kenney/physicsAssets/stone/square2.png , 40, 40 )\nblock.x = display.contentCenterX + 100\nblock.y = display.contentCenterY + 100\nphysics.addBody( block,  static  )", 
            "title": "The Old Way - Blech!"
        }, 
        {
            "location": "/libraries/display_standard/#standard-factory-signatures", 
            "text": "These new factories have the following signatures:   ssk.display.newCircle( group, x, y [, visualParams [, bodyParams [, behaviorsList ]]] )  ssk.display.newRect( group, x, y[, visualParams [, bodyParams [, behaviorsList ]]] )  ssk.display.newImage( group, x, y, imgSrc [, visualParams [, bodyParams [, behaviorsList ]]] )  ssk.display.newImageRect( group, x, y, imgSrc [, visualParams [, bodyParams [, behaviorsList ]]] )", 
            "title": "Standard Factory Signatures"
        }, 
        {
            "location": "/libraries/display_standard/#standard-factory-arguments", 
            "text": "As you will have noticed, the above factories have a fairly consistent function signature and share common arguments.  Those argument can be summarized as follows:   group  - Display group to place object in.  If  nil , object is placed in  display.currentStage .  x ,  y  -   x, y   position to place object at.  imgSrc  - A string specifying a path to the image you wish to display.  visualParams  - Table of parameters controlling the look of an object.    See ' Visual Parameters ' below.    bodyParams  - Table of parameters controlling the (optional) physics body.    See ' Body Parameters ' below.    behaviorsList  - Table of parameters that allows the easy addition of complex game logic to display objects.   See ' Behaviors List ' below.   This  ADVANCED  feature is not ready for general usage yet.", 
            "title": "Standard Factory Arguments"
        }, 
        {
            "location": "/libraries/display_standard/#visual-parameters", 
            "text": "The first (common) table that all of these builders takes is the  visualParams  table.  With this table, you can set almost all visual properties on the object and you can also attach or set any arbitrary property.", 
            "title": "Visual Parameters"
        }, 
        {
            "location": "/libraries/display_standard/#visualparams-standard-properties", 
            "text": "Aside from the 'custom' and specially handled properties listed above, you may set any normal Corona property as well.  \n-- Create a red circle with a 50% alpha\nnewCircle( nil, 100, 100 { fill = _R_, alpha = 0.5 } )  See the Corona docs for the complete list of ' Display Object Properties '  ( external link ).", 
            "title": "visualParams - 'Standard' Properties"
        }, 
        {
            "location": "/libraries/display_standard/#visualparams-custom-properties", 
            "text": "cornerRadius  ( 0 ) - If specified for  newRect() , a rounded rectangle ( display.newRoundedRect ) will be created.  diameter  - Sets the radius to half this value for  newCircle() .  fill  ( {1,1,1,1} ) - If specified, assigns a fill to the object. Most standard paint fills are allowed:  (Color) Paint:  fill = { 1, 0, 0, 0.25 }  Composite Paint  ( external link )  Trick:  You may specify a  fillEffect  property in the composite fill table. (Default  fillEffect  is  \"composite.average\" .)    Bitmap Paint  ( external link )  Gradient Paint  ( external link )  Not Supported:  Image Sheet Paint  ( external link )  Camera Fill Paint  ( external link )      radius  ( 20 ) - Sets the radius for  newCircle() .  scale  - If specified, the object will be scaled in the x- and y-dimension by this factor.  Tip:  Overrides  xScale  and  yScale  parameters.    size  - Sets width and height of rectangular objects.  If calling  newCircle()  the radius is computed as half the  size .  w  and  h  parameters override this.    stroke  ( {1,1,1,1} ) - If specified, sets the stroke color of the display object.  Tip:  Supports same paint fill types as  fill  parameter.    strokeWidth  ( 0 ) - If specified, sets the stroke width of the display object.  w ,  h  ( 40 ) - Width and height.", 
            "title": "visualParams - 'Custom' Properties"
        }, 
        {
            "location": "/libraries/display_standard/#visualparams-listeners", 
            "text": "In addition to being able to set many visual properties via the  visualParams  table, you can supply function references to the following property names:             accelerometer  axis  collision  enterFrame    finalize  key  mouse  sprite    tap  timer  touch      If any of these parameters is specified, SSK will automatically hook-up and start the specified listener(s).  Note:  Only works if  enableAutoListeners = true .  See  Configurins SSK 2 .", 
            "title": "visualParams - 'Listeners'"
        }, 
        {
            "location": "/libraries/display_standard/#listener-example-1-touch", 
            "text": "local function onTouch( self, event)\n   if( event.phase ==  ended  ) then\n      print( My name is:   .. self.myName )\n   end\n   return false\nend\n\nlocal tmp = newRect( nil, 100, 100, { touch = onTouch, myName =  Rect 1  }) \n\nlocal tmp = newRect( nil, 200, 100, { touch = onTouch, myName =  Rect 2  })  Now, if you touch either of the two rectangles created by this code, they will print:  My name is: Rect 1  or   My name is: Rect 2", 
            "title": "Listener Example 1 - touch"
        }, 
        {
            "location": "/libraries/display_standard/#listener-example-2-enterframe", 
            "text": "local function onEnterFrame( self )\n\n   self.x = self.x + 1\n\n   if( self.x  = right ) then\n\n      self.x = right\n\n      ignore(  enterFrame , self )\n\n      self.enterFrame = nil\n\n    end\n\nend\n\nnewCircle( nil, left, centerY, { enterFrame = onEnterFrame } )  The sample above created a white circle with a radius of 20 pixels, on the very left-edge of the screen and vertically centered.  As soon as it was created, the circle immediately started moving one pixel to the right every frame.    Once it reacheed the right-edge of the screen it will stop and remove the listener.", 
            "title": "Listener Example 2 - enterFrame"
        }, 
        {
            "location": "/libraries/display_standard/#visualparams-arbitrary-properties", 
            "text": "Lastly, as you may have noticed in the prior section,  visualParams  can take any arbitrary property name and assign a value to it.  This is extremely handy for setting flags and other values used later in your code.  \nlocal tmp = newRect( nil, 100, 100, { myName =  Bob , myAge = 21, amHappy = true }) \n\nprint( tmp.myName, tmp.myAge, tmp.amHappy )", 
            "title": "visualParams - 'Arbitrary' Properties"
        }, 
        {
            "location": "/libraries/display_standard/#body-parameters", 
            "text": "The second optional table you can pass to all of the builder functions is the  bodyParams  table.", 
            "title": "Body Parameters"
        }, 
        {
            "location": "/libraries/display_standard/#bodyparams-the-default-body", 
            "text": "Specifying an empty table tell SSK to add a default body to the object.  \nnewCircle( nil, 100, 100, { radius = 50 }, {} )\n\nnewRect( nil, 100, 100, { w = 50, h = 20 }, {} )  After the prior code executes, we will have a circle and a rectangle, both with default bodies.  The circle will have a circular body and the rectangle will have a rectangular body that matches the dimensions of the rectangle.  Both bodies will have this (default) physics configuration:   bodyType = \"dynamic\"  bounce = 0.2  density = 1.0  friction = 0.3  linearDamping = 0  gravityScale = 1  isSleepingAllowed = true  isSensor = false  isBullet = false  isFixedRotation = false", 
            "title": "bodyParams - The Default Body {}"
        }, 
        {
            "location": "/libraries/display_standard/#bodyparams-standard-properties", 
            "text": "As with  visualParams , you may pass key-value pairs in this table to set properties.  These properties include all the standard Physics property.  \n-- Create a circle with a static body that is also a sensor\nnewCircle( nil, 100, 100, { radius = 50 }, { bodyType =  static , isSensor = true } )  See the Corona docs for a full list of ' Physics Body Properties '  ( external link ).", 
            "title": "bodyParams - 'Standard' Properties"
        }, 
        {
            "location": "/libraries/display_standard/#bodyparams-custom-properties", 
            "text": "Besides the many 'Standard' properties supported by Corona and SSK, you can specify these custom properties too:   calculator  - A reference to an SSK collision calculator object.  colliderName  - 'Name' of this object's type (must be specified in calculator.)  useOutline  - Tells the body to use the objects image file as its shape.    Only works for  newImage()  and  newImageRect() .    pillParams  - A special that tells SSK to construct a 'pill shaped' body. Pass an empty table ( {} ) for the default pill shape, or pass a table with any of the following parameters to modify that shape.  corner  ( 0.15 ) - Amount to subtract/add from/to edges of pill.  xScale ,  xScale  ( 1 )- Scale the shape in either dimension, x and/or y.  offsetY  ( 0 )- Give the shape a vertical offset.  offsetY  ( 0 )- Give the shape a horizontal offset.     \n-- Make a circle that uses the 'player' settings from a previously created and configured Collision Calculator.\nnewCircle( nil, 100, 100, { radius = 50 }, { calculator = myCC, colliderName =  player  } )", 
            "title": "bodyParams - 'Custom' Properties"
        }, 
        {
            "location": "/libraries/display_standard/#behaviorslist-behaviors-list", 
            "text": "This is a work-in-progress feature.  When it is released, you will be able to create objects with complex behaviors like:   Drag-and-Drop - Attach robust drag-and-drop logic to the object.  Asteroids-Player - Create a one-line asteroids player.   ...        Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "behaviorsList - Behaviors List"
        }, 
        {
            "location": "/libraries/display_arcs/", 
            "text": "Arc Factories (ssk.display.*)\n\n\n\n\n\n\narc(group, x, y, params )\n - Produces an arbitrary arc out of line segments.\n\n\nDerived from original example by community member \nrmbsoft\n\n\n\n\n\n\npolyArc(group, x, y, params )\n - Produces an arbitrary arc out newing \ndisplay.newPolygon()\n\n\nDerived from original example by community member \nrmbsoft\n\n\n\n\n\n\n\n\n'Color Switch'-like Shape using Arcs\n\n\n\nlocal spinGroup = display.newGroup()\n\ngroup:insert(spinGroup)\n\nspinGroup.x = centerX - 200\n\nspinGroup.y = centerY \n\nssk.display.arc( spinGroup, 0, 0 , \n                  { w = 100, h = 100, s = 0, e = 90, \n                    strokeColor = _R_, strokeWidth = 6 })\n\nssk.display.arc( spinGroup, 0, 0 , \n                  { w = 100, h = 100, s = 90, e = 180, \n                    strokeColor = _G_, strokeWidth = 6 })\n\n    ssk.display.arc( spinGroup, 0, 0 , \n                  { w = 100, h = 100, s = 180, e = 270, \n                    strokeColor = _B_, strokeWidth = 6 })\n\nssk.display.arc( spinGroup, 0, 0 , \n                  { w = 100, h = 100, s = 270, e = 360, \n                    strokeColor = _Y_, strokeWidth = 6 })\n\n\nfunction spinGroup.enterFrame( self )\n\n   self.rotation = self.rotation + 5 \n\nend; listen(\nenterFrame\n, spinGroup)\n\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.display.* (Arc Factories)"
        }, 
        {
            "location": "/libraries/display_arcs/#arc-factories-sskdisplay", 
            "text": "arc(group, x, y, params )  - Produces an arbitrary arc out of line segments.  Derived from original example by community member  rmbsoft    polyArc(group, x, y, params )  - Produces an arbitrary arc out newing  display.newPolygon()  Derived from original example by community member  rmbsoft", 
            "title": "Arc Factories (ssk.display.*)"
        }, 
        {
            "location": "/libraries/display_arcs/#color-switch-like-shape-using-arcs", 
            "text": "local spinGroup = display.newGroup()\n\ngroup:insert(spinGroup)\n\nspinGroup.x = centerX - 200\n\nspinGroup.y = centerY \n\nssk.display.arc( spinGroup, 0, 0 , \n                  { w = 100, h = 100, s = 0, e = 90, \n                    strokeColor = _R_, strokeWidth = 6 })\n\nssk.display.arc( spinGroup, 0, 0 , \n                  { w = 100, h = 100, s = 90, e = 180, \n                    strokeColor = _G_, strokeWidth = 6 })\n\n    ssk.display.arc( spinGroup, 0, 0 , \n                  { w = 100, h = 100, s = 180, e = 270, \n                    strokeColor = _B_, strokeWidth = 6 })\n\nssk.display.arc( spinGroup, 0, 0 , \n                  { w = 100, h = 100, s = 270, e = 360, \n                    strokeColor = _Y_, strokeWidth = 6 })\n\n\nfunction spinGroup.enterFrame( self )\n\n   self.rotation = self.rotation + 5 \n\nend; listen( enterFrame , spinGroup)     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "'Color Switch'-like Shape using Arcs"
        }, 
        {
            "location": "/libraries/display_lines/", 
            "text": "Line Factories (ssk.display.*)\n\n\n\n\n\n\nnewLine( group, startX, startY, endX, endY, visualParams )\n - Hyper-configurable line-segment factory, using two end-points to define the line.\n\n\nnewAngleLine( group, startX, startY, angle, length, visualParams )\n - Hyper-configurable line-segment factory using a start-point, an angle, and a length to define the line.\n\n\nnewPointsLine( group, points, visualParams )\n - Hyper-configurable line-segment factory, using a points-list to define the line.\n\n\narrowhead( group, x, y, width, height, visualParams )\n - Arrow head utility function that is primarily used by line builders.\n\n\narrow( group, startX, startY, endX, endY, visualParams )\n - Arrow utility function that is primarily used by line builders.\n\n\narrow2( group, startX, startY, angle, length, visualParams)\n - Angle based arrow utility function that is primarily used by line builders.\n\n\n\n\n\nfunction test.run( group, params )\n   group = group or display.currentStage\n   params = params or {}\n\n   -- Basic\n   local newLine    = ssk.display.newLine\n    newLine( group, 50, top + 50, 450, top + 50 )\n    newLine( group, 50, top + 50 + 20, 450, top + 50 + 20, { w = 2, fill = _R_ } )\n    newLine( group, 50, top + 50 + 40, 450, top + 50 + 40, { w = 1, dashLen = 3, gapLen = 5, fill = _C_, style = \ndashed\n } )\n    newLine( group, 50, top + 50 + 60, 450, top + 50 + 60, { radius = 3, gapLen = 5, fill = _O_, style = \ndotted\n, stroke = _Y_, strokeWidth = 1} )\n    newLine( group, 50, top + 50 + 80, 450, top + 50 + 80, { gapLen = 10, dashLen = 6, headSize = 4, fill = _O_, style = \narrows\n} )\n    newLine( group, 50, top + 50 + 100, 450, top + 50 + 100, { gapLen = 10, dashLen = 0, headSize = 4, fill = _C_, style = \narrows\n} )\n\n\n    -- Angle lines\n    local newAngleLine = ssk.display.newAngleLine\n    local curY = top + 200\n    local tmp = newAngleLine( group, 50, curY, 135, 200 )\n    curY = curY + 20\n    local tmp = newAngleLine( group, 50, curY, 135, 200, { w = 2, fill = _R_ } )\n    curY = curY + 20\n    local tmp = newAngleLine( group, 50, curY, 135, 200, { w = 1, dashLen = 3, gapLen = 5, fill = _C_, style = \ndashed\n } )\n    curY = curY + 20\n    local tmp = newAngleLine( group, 50, curY, 135, 200, { radius = 3, gapLen = 5, fill = _O_, style = \ndotted\n, stroke = _Y_, strokeWidth = 1} )\n    curY = curY + 20\n    local tmp = newAngleLine( group, 50, curY, 135, 200, { gapLen = 10, dashLen = 6, headSize = 4, fill = _O_, style = \narrows\n} )\n    curY = curY + 20\n    local tmp = newAngleLine( group, 50, curY, 135, 200, { gapLen = 10, dashLen = 1, headSize = 4, fill = _C_, style = \narrows\n} )\n\n    -- Complex Lines\n    local newPointsLine     = ssk.display.newPointsLine\n    local newPoints         = ssk.points.new\n    local easyIFC           = ssk.easyIFC\n    local mRand             = math.random\n    local reDrawLines\n    local lastGroup\n\n    reDrawLines = function()\n        display.remove( lastGroup )\n\n        lastGroup = display.newGroup()\n        group:insert( lastGroup )\n\n        lastGroup.x  = lastGroup.x + 200\n\n        local curY = 250\n\n        local points = newPoints()\n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points  )\n\n        local points = newPoints()  \n        curY = curY + 20\n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points, { w = 2, fill = _R_ } )\n\n        local points = newPoints()\n        curY = curY + 20    \n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points, { w = 1, dashLen = 1, gapLen = 2, fill = _C_, style = \ndashed\n } )\n\n        local points = newPoints()\n        curY = curY + 20\n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points, { radius = 3, gapLen = 5, fill = _O_, style = \ndotted\n, stroke = _Y_, strokeWidth = 1} )\n\n        local points = newPoints()\n        curY = curY + 20\n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points, { gapLen = 10, dashLen = 6, headSize = 4, fill = _O_, style = \narrowheads\n} )\n\n        local points = newPoints()\n        curY = curY + 20\n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points, { fill = {1,1,1,0.2} } )\n        local tmp = newPointsLine( lastGroup, points, { gapLen = 10, dashLen = 1, headSize = 4, fill = _C_, style = \narrowheads\n} )\n\n        timer.performWithDelay( 100, reDrawLines )\n    end\n\n    reDrawLines()\nend\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.display.* (Line Factories)"
        }, 
        {
            "location": "/libraries/display_lines/#line-factories-sskdisplay", 
            "text": "newLine( group, startX, startY, endX, endY, visualParams )  - Hyper-configurable line-segment factory, using two end-points to define the line.  newAngleLine( group, startX, startY, angle, length, visualParams )  - Hyper-configurable line-segment factory using a start-point, an angle, and a length to define the line.  newPointsLine( group, points, visualParams )  - Hyper-configurable line-segment factory, using a points-list to define the line.  arrowhead( group, x, y, width, height, visualParams )  - Arrow head utility function that is primarily used by line builders.  arrow( group, startX, startY, endX, endY, visualParams )  - Arrow utility function that is primarily used by line builders.  arrow2( group, startX, startY, angle, length, visualParams)  - Angle based arrow utility function that is primarily used by line builders.   \nfunction test.run( group, params )\n   group = group or display.currentStage\n   params = params or {}\n\n   -- Basic\n   local newLine    = ssk.display.newLine\n    newLine( group, 50, top + 50, 450, top + 50 )\n    newLine( group, 50, top + 50 + 20, 450, top + 50 + 20, { w = 2, fill = _R_ } )\n    newLine( group, 50, top + 50 + 40, 450, top + 50 + 40, { w = 1, dashLen = 3, gapLen = 5, fill = _C_, style =  dashed  } )\n    newLine( group, 50, top + 50 + 60, 450, top + 50 + 60, { radius = 3, gapLen = 5, fill = _O_, style =  dotted , stroke = _Y_, strokeWidth = 1} )\n    newLine( group, 50, top + 50 + 80, 450, top + 50 + 80, { gapLen = 10, dashLen = 6, headSize = 4, fill = _O_, style =  arrows } )\n    newLine( group, 50, top + 50 + 100, 450, top + 50 + 100, { gapLen = 10, dashLen = 0, headSize = 4, fill = _C_, style =  arrows } )\n\n\n    -- Angle lines\n    local newAngleLine = ssk.display.newAngleLine\n    local curY = top + 200\n    local tmp = newAngleLine( group, 50, curY, 135, 200 )\n    curY = curY + 20\n    local tmp = newAngleLine( group, 50, curY, 135, 200, { w = 2, fill = _R_ } )\n    curY = curY + 20\n    local tmp = newAngleLine( group, 50, curY, 135, 200, { w = 1, dashLen = 3, gapLen = 5, fill = _C_, style =  dashed  } )\n    curY = curY + 20\n    local tmp = newAngleLine( group, 50, curY, 135, 200, { radius = 3, gapLen = 5, fill = _O_, style =  dotted , stroke = _Y_, strokeWidth = 1} )\n    curY = curY + 20\n    local tmp = newAngleLine( group, 50, curY, 135, 200, { gapLen = 10, dashLen = 6, headSize = 4, fill = _O_, style =  arrows } )\n    curY = curY + 20\n    local tmp = newAngleLine( group, 50, curY, 135, 200, { gapLen = 10, dashLen = 1, headSize = 4, fill = _C_, style =  arrows } )\n\n    -- Complex Lines\n    local newPointsLine     = ssk.display.newPointsLine\n    local newPoints         = ssk.points.new\n    local easyIFC           = ssk.easyIFC\n    local mRand             = math.random\n    local reDrawLines\n    local lastGroup\n\n    reDrawLines = function()\n        display.remove( lastGroup )\n\n        lastGroup = display.newGroup()\n        group:insert( lastGroup )\n\n        lastGroup.x  = lastGroup.x + 200\n\n        local curY = 250\n\n        local points = newPoints()\n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points  )\n\n        local points = newPoints()  \n        curY = curY + 20\n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points, { w = 2, fill = _R_ } )\n\n        local points = newPoints()\n        curY = curY + 20    \n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points, { w = 1, dashLen = 1, gapLen = 2, fill = _C_, style =  dashed  } )\n\n        local points = newPoints()\n        curY = curY + 20\n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points, { radius = 3, gapLen = 5, fill = _O_, style =  dotted , stroke = _Y_, strokeWidth = 1} )\n\n        local points = newPoints()\n        curY = curY + 20\n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points, { gapLen = 10, dashLen = 6, headSize = 4, fill = _O_, style =  arrowheads } )\n\n        local points = newPoints()\n        curY = curY + 20\n        for i = 1, 36 do\n            points:add( 50 + (i-1) * 10, curY + mRand(-5,5) )\n        end\n        local tmp = newPointsLine( lastGroup, points, { fill = {1,1,1,0.2} } )\n        local tmp = newPointsLine( lastGroup, points, { gapLen = 10, dashLen = 1, headSize = 4, fill = _C_, style =  arrowheads } )\n\n        timer.performWithDelay( 100, reDrawLines )\n    end\n\n    reDrawLines()\nend     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Line Factories (ssk.display.*)"
        }, 
        {
            "location": "/libraries/display_layers/", 
            "text": "Quick Layers (ssk.display.*)\n\n\n\n\nquickLayers( parentGroup, ... )\n - This function allows you to easily specify display group hierachies with optional nesting in a single call.  \n\n\n\n\nThe \nquickLayers()\n function returns a single display group (\nlayers\n) that contains the hierarchy as specified and that gives acess to each layer by its name, making game layering both fast and easy to implement.\n\n\nFurthermore, the returned \nlayers\n object provides two very useful methods:\n\n\n\n\nlayers:destroy()\n - Destroys the entire hierachy and all its children in one call.\n\n\nlayers:purge( name )\n - Purge the contents of any named layer.\n\n\nWarning:\n Do not purge layers that contain child layers as this will destroy the child layers.  Instead purge each child individually.\n\n\nEFM - Remove this restriction.\n\n\n\n\n\n\n\n\nCreating A Layer System\n\n\n\n-- Create Layers For Current Scene\nlocal layers = ssk.display.quickLayers( sceneGroup, \n   \nunderlay\n, \n   \nworld\n,\n      {  \nbackground\n, \n         \ncontent\n, \n         \nforeground\n },\n   \noverlay\n )\n\n\n\n\n\nProduces this bottom-to-top layered group hierarchy (\nparentGroup\n is \nsceneGroup\n in this example):\n\n\n\n\\ (parentGroup)\n|--\\ underlay\n|--\\ world\n   |--\\ background\n   |--\\ content\n   |--\\ foreground\n|--\\ overlay\n\n\n\n\n\nUsing A Layer System\n\n\n\n-- Create grey rectangle in background layer\n--\nlocal back = newRect( layers.background, centerX, centerY, \n                       { w = fullw, h = fullh, fill = _DARKGREY_ } )\n\n-- Add a 'player' in the 'content' layer\n--\nlocal player = newImageRect( layers.content, centerX, centerY, \nimages/smiley.png\n )\n\n\n\n\n\nPurging A Layer\n\n\n\n-- Create 100 cirlces in 'overlay' layer.\n--\nfor i = 1, 100 do\n   newRect( layers.overlay, centerX + math.radom( -200, 200), centerY + math.radom( -200, 200), \n            { fill = ssk.colors.randomColor() }   )\nend\n\n-- Wait 2 seconds, then purge the 'overlay' layer thus destroying all those circles.\n--\ntimer.performWithDelay( 2000, function() layers:purge( \noverlay\n ) end )\n\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.display.* (Quick Layers)"
        }, 
        {
            "location": "/libraries/display_layers/#quick-layers-sskdisplay", 
            "text": "quickLayers( parentGroup, ... )  - This function allows you to easily specify display group hierachies with optional nesting in a single call.     The  quickLayers()  function returns a single display group ( layers ) that contains the hierarchy as specified and that gives acess to each layer by its name, making game layering both fast and easy to implement.  Furthermore, the returned  layers  object provides two very useful methods:   layers:destroy()  - Destroys the entire hierachy and all its children in one call.  layers:purge( name )  - Purge the contents of any named layer.  Warning:  Do not purge layers that contain child layers as this will destroy the child layers.  Instead purge each child individually.  EFM - Remove this restriction.", 
            "title": "Quick Layers (ssk.display.*)"
        }, 
        {
            "location": "/libraries/display_layers/#creating-a-layer-system", 
            "text": "-- Create Layers For Current Scene\nlocal layers = ssk.display.quickLayers( sceneGroup, \n    underlay , \n    world ,\n      {   background , \n          content , \n          foreground  },\n    overlay  )  Produces this bottom-to-top layered group hierarchy ( parentGroup  is  sceneGroup  in this example):  \n\\ (parentGroup)\n|--\\ underlay\n|--\\ world\n   |--\\ background\n   |--\\ content\n   |--\\ foreground\n|--\\ overlay", 
            "title": "Creating A Layer System"
        }, 
        {
            "location": "/libraries/display_layers/#using-a-layer-system", 
            "text": "-- Create grey rectangle in background layer\n--\nlocal back = newRect( layers.background, centerX, centerY, \n                       { w = fullw, h = fullh, fill = _DARKGREY_ } )\n\n-- Add a 'player' in the 'content' layer\n--\nlocal player = newImageRect( layers.content, centerX, centerY,  images/smiley.png  )", 
            "title": "Using A Layer System"
        }, 
        {
            "location": "/libraries/display_layers/#purging-a-layer", 
            "text": "-- Create 100 cirlces in 'overlay' layer.\n--\nfor i = 1, 100 do\n   newRect( layers.overlay, centerX + math.radom( -200, 200), centerY + math.radom( -200, 200), \n            { fill = ssk.colors.randomColor() }   )\nend\n\n-- Wait 2 seconds, then purge the 'overlay' layer thus destroying all those circles.\n--\ntimer.performWithDelay( 2000, function() layers:purge(  overlay  ) end )     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Purging A Layer"
        }, 
        {
            "location": "/libraries/display_samples/", 
            "text": "Here are some samples to help you get your head wrapped around the concepts outlined in the previous docs pages.\n\n\nTip:\n To simplify typing, I typically localize SSK functions I will use a lot. \n\n\n\n-- Localize factories\nlocal newCircle    = ssk.display.newCircle\nlocal newRect      = ssk.display.newRect\nlocal newImageRect = ssk.display.newImageRect\n\n\n\n\n\n\n\nCircles - \nnewCircle\n\n\n\n\nnewCircle( group, 45, top + 50 )    \n\nnewCircle( group, 95, top + 50, { fill = _R_ } )\n\nnewCircle( group, 145, top + 50, { radius = 10, fill = _B_, stroke = _W_, strokeWidth = 2 } )\n\nnewCircle( group, 195, top + 50, { size = 20, fill = _O_ } )\n\nnewCircle( group, 245, top + 50, { radius = 20, scale = 0.5, fill = _Y_ } )\n\nnewCircle( group, 295, top + 50, { xScale = 0.75, fill = _C_ } )\n\nnewCircle( group, 345, top + 50, { yScale = 0.75, rotation = 15, fill = _PURPLE_ } )\n\nnewCircle( group, 395, top + 50, { fill = { type = \nimage\n, \n                                            baseDir = system.ResourceDirectory, \n                                            filename = \nimages/water.png\n} } )\n\nnewCircle( group, 445, top + 50, { \n        fill = { type = \ngradient\n, color1 = { 1, 0, 0.4 }, \n                 color2 = { 1, 0, 0, 0.2 }, direction = \ndown\n }, strokeWidth = 4, \n        stroke = { type = \ngradient\n, color1 = { 0, 1, 0.4 }, \n                   color2 = { 0, 0, 1, 0.2 }, direction = \nup\n } } )\n\n\n\n\n\n\n\nRectangles - \nnewRect\n\n\n\n\n\nnewRect( group, 45, top + 100 )  \n\nnewRect( group, 95, top + 100, { fill = _R_ } )\n\nnewRect( group, 145, top + 100, { radius = 10, fill = _B_,  stroke = _W_, strokeWidth = 2 } )\n\nnewRect( group, 195, top + 100, { size = 20, fill = _O_ } )\n\nnewRect( group, 245, top + 100, { radius = 20, scale = 0.5, fill = _Y_ } )\n\nnewRect( group, 295, top + 100, { xScale = 0.75, fill = _C_ } )\n\nnewRect( group, 345, top + 100, { yScale = 0.75, rotation = 15, fill = _PURPLE_ } )\n\nnewRect( group, 395, top + 100, { fill = { type = \nimage\n, \n                                           baseDir = system.ResourceDirectory, \n                                           filename = \nimages/water.png\n} } )\n\nnewRect( group, 445, top + 100, { \n        fill = { type = \ngradient\n, color1 = { 1, 0, 0.4 }, \n                 color2 = { 1, 0, 0, 0.2 }, direction = \ndown\n }, strokeWidth = 4, \n        stroke = { type = \ngradient\n, color1 = { 0, 1, 0.4 }, \n                   color2 = { 0, 0, 1, 0.2 }, direction = \nup\n } } )\n\n\n\n\n\n\n\nImage Rectanges - \nnewImageRect\n\n\n\n\n\nnewImageRect( group, 45, top + 150, \nimages/smiley.png\n )    \n\nnewImageRect( group, 95, top + 150, \nimages/smiley.png\n, { fill = _R_ } )\n\nnewImageRect( group, 145, top + 150, \nimages/smiley.png\n, { radius = 10, fill = _B_, \n                                                            stroke = _W_, strokeWidth = 2 } )\n\nnewImageRect( group, 195, top + 150, \nimages/smiley.png\n, { size = 20, fill = _O_ } )\n\nnewImageRect( group, 245, top + 150, \nimages/smiley.png\n, { radius = 20, scale = 0.5, fill = _Y_ } )\n\nnewImageRect( group, 295, top + 150, \nimages/smiley.png\n, { xScale = 0.75, fill = _C_ } )\n\nnewImageRect( group, 345, top + 150, \nimages/smiley.png\n, { yScale = 0.75, rotation = 15, fill = _PURPLE_ } )\n\nnewImageRect( group, 395, top + 150, \nimages/smiley.png\n, { fill = { type = \nimage\n, \n                                                                     baseDir = system.ResourceDirectory, \n                                                                     filename = \nimages/water.png\n} } )\n\nnewImageRect( group, 445, top + 150, \nimages/smiley.png\n, { \n        fill = { type = \ngradient\n, color1 = { 1, 0, 0.4 }, \n                 color2 = { 1, 0, 0, 0.2 }, direction = \ndown\n }, strokeWidth = 4, \n        stroke = { type = \ngradient\n, color1 = { 0, 1, 0.4 }, \n                   color2 = { 0, 0, 1, 0.2 }, direction = \nup\n } } )\n\n\n\n\n\n\n\nBouncing Block - Simple Physics\n\n\n\nlocal physics = require \nphysics\n\n\nphysics.setGravity( 0, 10 )\n\nphysics.start()\n--physics.setDrawMode( \nhybrid\n )\n\nlocal ball = display.newImageRect( group, \nimages/kenney/physicsAssets/yellow_round.png\n, 40, 40 )\n\nball.x = left + 50\n\nball.y = centerY - 100\n\nphysics.addBody( ball, { radius = 20, bounce = 1, radius = 20  } )\n\nball.gravityScale = 0.2\n\n\nlocal block = display.newImageRect( group, \nimages/kenney/physicsAssets/stone/square2.png\n, 40, 40 )\n\nblock.x = left + 50\n\nblock.y = centerY + 50\n\nphysics.addBody( block, \nstatic\n )\n\n\n\n\n\n\n\n'Color Switch'-like Shape with Arcs\n\n\n\n\n\nlocal spinGroup = display.newGroup()\n\ngroup:insert(spinGroup)\n\nspinGroup.x = centerX - 200\n\nspinGroup.y = centerY \n\nssk.display.arc( spinGroup, 0, 0 , \n                  { w = 100, h = 100, s = 0, e = 90, \n                    strokeColor = _R_, strokeWidth = 6 })\n\nssk.display.arc( spinGroup, 0, 0 , \n                  { w = 100, h = 100, s = 90, e = 180, \n                    strokeColor = _G_, strokeWidth = 6 })\n\n    ssk.display.arc( spinGroup, 0, 0 , \n                  { w = 100, h = 100, s = 180, e = 270, \n                    strokeColor = _B_, strokeWidth = 6 })\n\nssk.display.arc( spinGroup, 0, 0 , \n                  { w = 100, h = 100, s = 270, e = 360, \n                    strokeColor = _Y_, strokeWidth = 6 })\n\n\nfunction spinGroup.enterFrame( self )\n\n   self.rotation = self.rotation + 5 \n\nend; listen(\nenterFrame\n, spinGroup)\n\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.display.* Samples"
        }, 
        {
            "location": "/libraries/display_samples/#circles-newcircle", 
            "text": "newCircle( group, 45, top + 50 )    \n\nnewCircle( group, 95, top + 50, { fill = _R_ } )\n\nnewCircle( group, 145, top + 50, { radius = 10, fill = _B_, stroke = _W_, strokeWidth = 2 } )\n\nnewCircle( group, 195, top + 50, { size = 20, fill = _O_ } )\n\nnewCircle( group, 245, top + 50, { radius = 20, scale = 0.5, fill = _Y_ } )\n\nnewCircle( group, 295, top + 50, { xScale = 0.75, fill = _C_ } )\n\nnewCircle( group, 345, top + 50, { yScale = 0.75, rotation = 15, fill = _PURPLE_ } )\n\nnewCircle( group, 395, top + 50, { fill = { type =  image , \n                                            baseDir = system.ResourceDirectory, \n                                            filename =  images/water.png } } )\n\nnewCircle( group, 445, top + 50, { \n        fill = { type =  gradient , color1 = { 1, 0, 0.4 }, \n                 color2 = { 1, 0, 0, 0.2 }, direction =  down  }, strokeWidth = 4, \n        stroke = { type =  gradient , color1 = { 0, 1, 0.4 }, \n                   color2 = { 0, 0, 1, 0.2 }, direction =  up  } } )", 
            "title": "Circles - newCircle"
        }, 
        {
            "location": "/libraries/display_samples/#rectangles-newrect", 
            "text": "newRect( group, 45, top + 100 )  \n\nnewRect( group, 95, top + 100, { fill = _R_ } )\n\nnewRect( group, 145, top + 100, { radius = 10, fill = _B_,  stroke = _W_, strokeWidth = 2 } )\n\nnewRect( group, 195, top + 100, { size = 20, fill = _O_ } )\n\nnewRect( group, 245, top + 100, { radius = 20, scale = 0.5, fill = _Y_ } )\n\nnewRect( group, 295, top + 100, { xScale = 0.75, fill = _C_ } )\n\nnewRect( group, 345, top + 100, { yScale = 0.75, rotation = 15, fill = _PURPLE_ } )\n\nnewRect( group, 395, top + 100, { fill = { type =  image , \n                                           baseDir = system.ResourceDirectory, \n                                           filename =  images/water.png } } )\n\nnewRect( group, 445, top + 100, { \n        fill = { type =  gradient , color1 = { 1, 0, 0.4 }, \n                 color2 = { 1, 0, 0, 0.2 }, direction =  down  }, strokeWidth = 4, \n        stroke = { type =  gradient , color1 = { 0, 1, 0.4 }, \n                   color2 = { 0, 0, 1, 0.2 }, direction =  up  } } )", 
            "title": "Rectangles - newRect"
        }, 
        {
            "location": "/libraries/display_samples/#image-rectanges-newimagerect", 
            "text": "newImageRect( group, 45, top + 150,  images/smiley.png  )    \n\nnewImageRect( group, 95, top + 150,  images/smiley.png , { fill = _R_ } )\n\nnewImageRect( group, 145, top + 150,  images/smiley.png , { radius = 10, fill = _B_, \n                                                            stroke = _W_, strokeWidth = 2 } )\n\nnewImageRect( group, 195, top + 150,  images/smiley.png , { size = 20, fill = _O_ } )\n\nnewImageRect( group, 245, top + 150,  images/smiley.png , { radius = 20, scale = 0.5, fill = _Y_ } )\n\nnewImageRect( group, 295, top + 150,  images/smiley.png , { xScale = 0.75, fill = _C_ } )\n\nnewImageRect( group, 345, top + 150,  images/smiley.png , { yScale = 0.75, rotation = 15, fill = _PURPLE_ } )\n\nnewImageRect( group, 395, top + 150,  images/smiley.png , { fill = { type =  image , \n                                                                     baseDir = system.ResourceDirectory, \n                                                                     filename =  images/water.png } } )\n\nnewImageRect( group, 445, top + 150,  images/smiley.png , { \n        fill = { type =  gradient , color1 = { 1, 0, 0.4 }, \n                 color2 = { 1, 0, 0, 0.2 }, direction =  down  }, strokeWidth = 4, \n        stroke = { type =  gradient , color1 = { 0, 1, 0.4 }, \n                   color2 = { 0, 0, 1, 0.2 }, direction =  up  } } )", 
            "title": "Image Rectanges - newImageRect"
        }, 
        {
            "location": "/libraries/display_samples/#bouncing-block-simple-physics", 
            "text": "local physics = require  physics \n\nphysics.setGravity( 0, 10 )\n\nphysics.start()\n--physics.setDrawMode(  hybrid  )\n\nlocal ball = display.newImageRect( group,  images/kenney/physicsAssets/yellow_round.png , 40, 40 )\n\nball.x = left + 50\n\nball.y = centerY - 100\n\nphysics.addBody( ball, { radius = 20, bounce = 1, radius = 20  } )\n\nball.gravityScale = 0.2\n\n\nlocal block = display.newImageRect( group,  images/kenney/physicsAssets/stone/square2.png , 40, 40 )\n\nblock.x = left + 50\n\nblock.y = centerY + 50\n\nphysics.addBody( block,  static  )", 
            "title": "Bouncing Block - Simple Physics"
        }, 
        {
            "location": "/libraries/display_samples/#color-switch-like-shape-with-arcs", 
            "text": "local spinGroup = display.newGroup()\n\ngroup:insert(spinGroup)\n\nspinGroup.x = centerX - 200\n\nspinGroup.y = centerY \n\nssk.display.arc( spinGroup, 0, 0 , \n                  { w = 100, h = 100, s = 0, e = 90, \n                    strokeColor = _R_, strokeWidth = 6 })\n\nssk.display.arc( spinGroup, 0, 0 , \n                  { w = 100, h = 100, s = 90, e = 180, \n                    strokeColor = _G_, strokeWidth = 6 })\n\n    ssk.display.arc( spinGroup, 0, 0 , \n                  { w = 100, h = 100, s = 180, e = 270, \n                    strokeColor = _B_, strokeWidth = 6 })\n\nssk.display.arc( spinGroup, 0, 0 , \n                  { w = 100, h = 100, s = 270, e = 360, \n                    strokeColor = _Y_, strokeWidth = 6 })\n\n\nfunction spinGroup.enterFrame( self )\n\n   self.rotation = self.rotation + 5 \n\nend; listen( enterFrame , spinGroup)     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "'Color Switch'-like Shape with Arcs"
        }, 
        {
            "location": "/libraries/easy_interfaces_motivation/", 
            "text": "Who needs another interface library?\n\n\neasyIFC.*\n was born out of my need to quickly and easily create buttons (push, toggle, and radio) for games.  I found that while I could use \nwidget.*\n for this it took more coding effort than I was willing to endure. \n\n\nSo... I dug in and wrote my own library (\neasyIFC.*\n) that supports all the buttons I need and has these additional features:\n\n\n\n\nOne Line Creation\n - Make buttons, labels, etc. with a single call.\n\n\nPreset Library\n  - Optionally pre-define the look and feel of common buttons and re-use that information to make new buttons.  \n\n\nOverrides\n - Optionally override any preset-parameter while creating a button to account for those \none-off\n cases.\n\n\n\n\n\n\nHyper-Flexible Construction\n - You can use an arbitrary combination of images, rectangles, frames, etc. to build great looking buttons.\n\n\n... more\n\n\n\n\n\n\nNote:\n I am not ripping on \nwidget.*\n.  I simply wanted something different, so I made it.\n\n\n\n\nCode Comparison\n\n\nPush Button with \neasyIFC.*\n\n\n\n-- Forward declaration to reduce typing and speed up future calls\nlocal easyIFC = ssk.easyIFC\n\nlocal group = display.newGroup()\n\nlocal function onRelease( event )\n    print(\nPressed Button\n)\nend\n\n-- Create the easyIFC push button\neasyIFC:presetPush( group, \ndefault\n, 100, 100, 50, 40, \nHello\n, onRelease, { labelSize = 72 } )\n\n\n\n\n\nPush Button with \nwidget.*\n\n\n\nlocal widget = require( \nwidget\n )\n\nlocal group = display.newGroup()\n\nlocal function onRelease( event )\n    print(\nPressed Button\n)\nend\n\n-- Create the widget push button\nwidget.newButton(\n    {\n        parent       = group,\n        x            = 100,\n        y            = 100,\n        width        = 50,\n        height       = 40,\n        defaultFile  = \nfillW.png\n,\n        fillColor    = { default={ 0.25, 0.25, 0.25, 1 }, over={ 0.5, 0.5, 0.5, 1 } },\n        label        = \nHello\n,\n        fontSize     = 72,\n        labelColor   = { default={ 1, 1, 1, 1 }, over={ 1, 1, 1, 1 } },\n        onRelease    = onRelease,\n    }\n)\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.easyIFC.* (Motivation)"
        }, 
        {
            "location": "/libraries/easy_interfaces_motivation/#who-needs-another-interface-library", 
            "text": "easyIFC.*  was born out of my need to quickly and easily create buttons (push, toggle, and radio) for games.  I found that while I could use  widget.*  for this it took more coding effort than I was willing to endure.   So... I dug in and wrote my own library ( easyIFC.* ) that supports all the buttons I need and has these additional features:   One Line Creation  - Make buttons, labels, etc. with a single call.  Preset Library   - Optionally pre-define the look and feel of common buttons and re-use that information to make new buttons.    Overrides  - Optionally override any preset-parameter while creating a button to account for those  one-off  cases.    Hyper-Flexible Construction  - You can use an arbitrary combination of images, rectangles, frames, etc. to build great looking buttons.  ... more    Note:  I am not ripping on  widget.* .  I simply wanted something different, so I made it.", 
            "title": "Who needs another interface library?"
        }, 
        {
            "location": "/libraries/easy_interfaces_motivation/#code-comparison", 
            "text": "", 
            "title": "Code Comparison"
        }, 
        {
            "location": "/libraries/easy_interfaces_motivation/#push-button-with-easyifc", 
            "text": "-- Forward declaration to reduce typing and speed up future calls\nlocal easyIFC = ssk.easyIFC\n\nlocal group = display.newGroup()\n\nlocal function onRelease( event )\n    print( Pressed Button )\nend\n\n-- Create the easyIFC push button\neasyIFC:presetPush( group,  default , 100, 100, 50, 40,  Hello , onRelease, { labelSize = 72 } )", 
            "title": "Push Button with easyIFC.*"
        }, 
        {
            "location": "/libraries/easy_interfaces_motivation/#push-button-with-widget", 
            "text": "local widget = require(  widget  )\n\nlocal group = display.newGroup()\n\nlocal function onRelease( event )\n    print( Pressed Button )\nend\n\n-- Create the widget push button\nwidget.newButton(\n    {\n        parent       = group,\n        x            = 100,\n        y            = 100,\n        width        = 50,\n        height       = 40,\n        defaultFile  =  fillW.png ,\n        fillColor    = { default={ 0.25, 0.25, 0.25, 1 }, over={ 0.5, 0.5, 0.5, 1 } },\n        label        =  Hello ,\n        fontSize     = 72,\n        labelColor   = { default={ 1, 1, 1, 1 }, over={ 1, 1, 1, 1 } },\n        onRelease    = onRelease,\n    }\n)     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Push Button with widget.*"
        }, 
        {
            "location": "/libraries/easy_interfaces_buttons/", 
            "text": "Easy Interface Buttons (ssk.easyIFC)\n\n\n\n\neasyIFC:newButton( group, params )\n - Generic button builder, called by following:\n\n\neasyIFC:presetPush( group, presetName, x, y, w, h, labelText, onRelease, overrideParams)\n\n\neasyIFC:presetToggle( group, presetName, x,y,w,h, labelText, onEvent, overrideParams)\n\n\neasyIFC:presetRadio( group, presetName, x, y , w, h, labelText, onRelease, overrideParams)\n\n\n\n\nbuttonInstance\n\n\nEach of the above factories returns a \nbuttonInstance\n (a display group with special fields and functions attached, that contains all of the button 'parts'.)\n\n\nButton Factory Parameters\n\n\nThe factories share a fairly consistent set of parameters:\n\n\n\n\ngroup\n - Display group to place button/slider into.\n\n\npresetName\n - String identifying preset to use to configure button/slider.\n\n\nx\n, \ny\n - x- and y- position of button/slider center.\n\n\nw\n, \nh\n - Width and height of button.\n\n\nlabelText\n - (Optional) text to put on button.  May be \"\" for no text.\n\n\nonPress\n - Listener called only on 'began' phase of button touch.\n\n\nonRelease\n - Listener called only on 'ended' phase of button touch, and then only if the \nfinger\n is still 'over' the button when lifted.\n\n\nonEvent\n - A generic listener that gets all phases of the touch.\n\n\noverrideParams\n - (Optional) table that lets you override any property in the preset and set any property you wish.  See '\noverrideParams\n' below for the extensive listof properties.\n\n\n\n\nComponents Of A Button\n\n\nBefore we look at \noverrideParams\n (next in the docs), it would be helpful to understand some basic principles behind how a button is created.\n\n\neasyIFC.*\n button factories build two-state buttons.  That is they are either un-selected (OFF), or selected (ON).  \n\n\nTo achieve this, \neasyIFC.*\n button factories use \nminimum\n of four display ojects:\n\n\n\n\nDisplay Group\n - This contains all the button parts and is the object that is returned by the factories.\n\n\nSelected Rectangle or Image\n \n\n\nUn-Selected Rectangle or Image\n \n\n\nText Label\n \n\n\n\n\nAs a rule of thumb, you only want to use rectangles or images for the selected and unselected representation, but you may have them all in any combination.  Just be aware that the stacking order will be:\n\n\n\n\nRectangles\n \n\n\nImages\n\n\nSlices\n \n\n\n\n\nWhat Are Slices?\n\n\nSlices are a feature I added recently that allows you to create buttons from a set of sliced up images.  This is similar to what the \nwidget.*\n library does.  Unlike \nwidget.*\n however I use discrete images and not a sprite sheet. This is slightly less efficient, but much easier to create for new developers.\n\n\nThe Other Parts\n\n\n\n\nStrokes\n - You may of course set strokes for the two button representations..\n\n\nFills\n - Each part of the button can have a fill color to shade it.\n\n\nNote:\n I chose not to support the other paint styles because I didn't see much value in them when I could just as easily create the button I needed in Photoshop.\n\n\n\n\n\n\nOverlays\n - You can have both a rectangle and image overlay if you want.  Each of these lays over the other parts of the button to act like a frame of sorts.\n\n\n\n\noverrideParams\n\n\n\n\nGeneral\n\n\nbuttonType\n - EFM\n\n\nanchorX\n - EFM\n\n\nanchorY\n - EFM\n\n\nplaceRelative\n - EFM\n\n\n\n\n\n\nLabel Parameters\n\n\nlabelText\n - EFM\n\n\nlabelSize\n - EFM\n\n\nlabelColor\n - EFM\n\n\nselLabelColor\n - EFM\n\n\nlabelFont\n - EFM\n\n\nlabelOffset\n - EFM\n\n\nlabelHorizAlign\n - EFM\n\n\nemboss\n - EFM\n\n\nlabelHorizAlign\n - EFM\n\n\n\n\n\n\nRectangle Parameters\n\n\nunselRectFillColor\n - EFM\n\n\nselRectFillColor\n - EFM\n\n\ncornerRadius\n - EFM\n\n\n\n\n\n\nImage Parameters\n\n\nunselImgSrc\n - EFM\n\n\nselImgSrc\n - EFM\n\n\nunselImgFillColor\n - EFM\n\n\nselImgFillColor\n - EFM\n\n\n\n\n\n\nSlice Parameters\n\n\nunselSliceSrc\n - EFM\n\n\nselSliceSrc\n - EFM\n\n\nunselSliceFillColor\n - EFM\n\n\nselSliceFillColor\n - EFM \n\n\n\n\n\n\nTouch Masking Parameters\n\n\ntouchMask\n - EFM\n\n\ntouchMaskW\n, \ntouchMaskH\n - EFM\n\n\n\n\n\n\nStroke Parameters\n\n\nunselStrokeColor\n - EFM\n\n\nselStrokeColor\n - EFM\n\n\nstrokeWidth\n - EFM\n\n\nstrokeColor\n - EFM\n\n\n\n\n\n\nOverlay Parameters    \n\n\nbuttonOverlayRectColor\n - EFM\n\n\nbuttonOverlayImgSrc\n - EFM\n\n\nbuttonOverlayFillColor\n - EFM\n\n\n\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.easyIFC.* (Button Factories)"
        }, 
        {
            "location": "/libraries/easy_interfaces_buttons/#easy-interface-buttons-sskeasyifc", 
            "text": "easyIFC:newButton( group, params )  - Generic button builder, called by following:  easyIFC:presetPush( group, presetName, x, y, w, h, labelText, onRelease, overrideParams)  easyIFC:presetToggle( group, presetName, x,y,w,h, labelText, onEvent, overrideParams)  easyIFC:presetRadio( group, presetName, x, y , w, h, labelText, onRelease, overrideParams)", 
            "title": "Easy Interface Buttons (ssk.easyIFC)"
        }, 
        {
            "location": "/libraries/easy_interfaces_buttons/#buttoninstance", 
            "text": "Each of the above factories returns a  buttonInstance  (a display group with special fields and functions attached, that contains all of the button 'parts'.)", 
            "title": "buttonInstance"
        }, 
        {
            "location": "/libraries/easy_interfaces_buttons/#button-factory-parameters", 
            "text": "The factories share a fairly consistent set of parameters:   group  - Display group to place button/slider into.  presetName  - String identifying preset to use to configure button/slider.  x ,  y  - x- and y- position of button/slider center.  w ,  h  - Width and height of button.  labelText  - (Optional) text to put on button.  May be \"\" for no text.  onPress  - Listener called only on 'began' phase of button touch.  onRelease  - Listener called only on 'ended' phase of button touch, and then only if the  finger  is still 'over' the button when lifted.  onEvent  - A generic listener that gets all phases of the touch.  overrideParams  - (Optional) table that lets you override any property in the preset and set any property you wish.  See ' overrideParams ' below for the extensive listof properties.", 
            "title": "Button Factory Parameters"
        }, 
        {
            "location": "/libraries/easy_interfaces_buttons/#components-of-a-button", 
            "text": "Before we look at  overrideParams  (next in the docs), it would be helpful to understand some basic principles behind how a button is created.  easyIFC.*  button factories build two-state buttons.  That is they are either un-selected (OFF), or selected (ON).    To achieve this,  easyIFC.*  button factories use  minimum  of four display ojects:   Display Group  - This contains all the button parts and is the object that is returned by the factories.  Selected Rectangle or Image    Un-Selected Rectangle or Image    Text Label     As a rule of thumb, you only want to use rectangles or images for the selected and unselected representation, but you may have them all in any combination.  Just be aware that the stacking order will be:   Rectangles    Images  Slices", 
            "title": "Components Of A Button"
        }, 
        {
            "location": "/libraries/easy_interfaces_buttons/#what-are-slices", 
            "text": "Slices are a feature I added recently that allows you to create buttons from a set of sliced up images.  This is similar to what the  widget.*  library does.  Unlike  widget.*  however I use discrete images and not a sprite sheet. This is slightly less efficient, but much easier to create for new developers.", 
            "title": "What Are Slices?"
        }, 
        {
            "location": "/libraries/easy_interfaces_buttons/#the-other-parts", 
            "text": "Strokes  - You may of course set strokes for the two button representations..  Fills  - Each part of the button can have a fill color to shade it.  Note:  I chose not to support the other paint styles because I didn't see much value in them when I could just as easily create the button I needed in Photoshop.    Overlays  - You can have both a rectangle and image overlay if you want.  Each of these lays over the other parts of the button to act like a frame of sorts.", 
            "title": "The Other Parts"
        }, 
        {
            "location": "/libraries/easy_interfaces_buttons/#overrideparams", 
            "text": "General  buttonType  - EFM  anchorX  - EFM  anchorY  - EFM  placeRelative  - EFM    Label Parameters  labelText  - EFM  labelSize  - EFM  labelColor  - EFM  selLabelColor  - EFM  labelFont  - EFM  labelOffset  - EFM  labelHorizAlign  - EFM  emboss  - EFM  labelHorizAlign  - EFM    Rectangle Parameters  unselRectFillColor  - EFM  selRectFillColor  - EFM  cornerRadius  - EFM    Image Parameters  unselImgSrc  - EFM  selImgSrc  - EFM  unselImgFillColor  - EFM  selImgFillColor  - EFM    Slice Parameters  unselSliceSrc  - EFM  selSliceSrc  - EFM  unselSliceFillColor  - EFM  selSliceFillColor  - EFM     Touch Masking Parameters  touchMask  - EFM  touchMaskW ,  touchMaskH  - EFM    Stroke Parameters  unselStrokeColor  - EFM  selStrokeColor  - EFM  strokeWidth  - EFM  strokeColor  - EFM    Overlay Parameters      buttonOverlayRectColor  - EFM  buttonOverlayImgSrc  - EFM  buttonOverlayFillColor  - EFM        Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "overrideParams"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/", 
            "text": "Easy Interface Factories (ssk.easyIFC.*)\n\n\nButtons - Standard Factories\n\n\n\n\nbuttons:newButton( group, params )\n - Generic button builder, called by following:\n\n\nbuttons:presetPush( group, presetName, x, y, w, h, labelText, onRelease, overrideParams)\n\n\nbuttons:presetToggle( group, presetName, x,y,w,h, labelText, onEvent, overrideParams)\n\n\nbuttons:presetRadio( group, presetName, x, y , w, h, labelText, onRelease, overrideParams)\n\n\n\n\nbuttonInstance\n\n\nEach of the above factories returns a \nbuttonInstance\n (a display group with special fields and functions attached, that contains all of the button 'parts'.)\n\n\nButton Factory Parameters\n\n\nThe factories share a fairly consistent set of parameters:\n\n\n\n\ngroup\n - Display group to place button/slider into.\n\n\npresetName\n - String identifying preset to use to configure button/slider.\n\n\nx\n, \ny\n - x- and y- position of button/slider center.\n\n\nw\n, \nh\n - Width and height of button.\n\n\nlabelText\n - (Optional) text to put on button.  May be \"\" for no text.\n\n\nonPress\n - Listener called only on 'began' phase of button touch.\n\n\nonRelease\n - Listener called only on 'ended' phase of button touch, and then only if the \nfinger\n is still 'over' the button when lifted.\n\n\nonEvent\n - A generic listener that gets all phases of the touch.\n\n\noverrideParams\n - (Optional) table that lets you override any property in the preset and set any property you wish.  See '\noverrideParams\n' below for the extensive listof properties.\n\n\n\n\nButton Utilities\n\n\nssk.easyIfC.*\n provides two button related utility functions:\n\n\n\n\nbuttons:addButtonPreset( presetName, params )\n - Method to add preset definitions to known presets library.\n\n\nbuttons.getCurrentRadio( group )\n - Returns the currently toggled radio button in a group.\n\n\n\n\nbuttonInstance\n - Properties\n\n\n\n\nisPressed\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\n\n\nbuttonInstance\n - Methods\n\n\n\n\nbuttonInstance:pressed( )\n - EFM\n\n\nbuttonInstance:toggle( noDispatch )\n - EFM\n\n\nbuttonInstance:disable( )\n - EFM\n\n\nbuttonInstance:enable( )\n - EFM\n\n\nbuttonInstance:isEnabled()\n - EFM\n\n\nbuttonInstance:getText( )\n - EFM\n\n\nbuttonInstance:setText( newText )\n - EFM\n\n\nbuttonInstance:getTextColor()\n - EFM\n\n\nbuttonInstance:setFillColor( color )\n - EFM\n\n\nbuttonInstance:adjustLabelOffset( offset )\n - EFM\n\n\nbuttonInstance:setHighlight( vis )\n - EFM\n\n\nbuttonInstance:setSize( width, height )\n - EFM\n\n\n\n\nComponents Of A Button\n\n\nBefore we look at \noverrideParams\n (next in the docs), it would be helpful to understand some basic principles behind how a button is created.\n\n\neasyIFC.*\n button factories build two-state buttons.  That is they are either un-selected (OFF), or selected (ON).  \n\n\nTo achieve this, \neasyIFC.*\n button factories use \nminimum\n of four display ojects:\n\n\n\n\nDisplay Group\n - This contains all the button parts and is the object that is returned by the factories.\n\n\nSelected Rectangle or Image\n \n\n\nUn-Selected Rectangle or Image\n \n\n\nText Label\n \n\n\n\n\nAs a rule of thumb, you only want to use rectangles or images for the selected and unselected representation, but you may have them all in any combination.  Just be aware that the stacking order will be:\n\n\n\n\nRectangles\n \n\n\nImages\n\n\nSlices\n \n\n\n\n\nWhat Are Slices?\n\n\nSlices are a feature I added recently that allows you to create buttons from a set of sliced up images.  This is similar to what the \nwidget.*\n library does.  Unlike \nwidget.*\n however I use discrete images and not a sprite sheet. This is slightly less efficient, but much easier to create for new developers.\n\n\nThe Other Parts\n\n\n\n\nStrokes\n - You may of course set strokes for the two button representations..\n\n\nFills\n - Each part of the button can have a fill color to shade it.\n\n\nNote:\n I chose not to support the other paint styles because I didn't see much value in them when I could just as easily create the button I needed in Photoshop.\n\n\n\n\n\n\nOverlays\n - You can have both a rectangle and image overlay if you want.  Each of these lays over the other parts of the button to act like a frame of sorts.\n\n\n\n\noverrideParams\n\n\n\n\nGeneral\n\n\nbuttonType\n - EFM\n\n\nanchorX\n - EFM\n\n\nanchorY\n - EFM\n\n\nplaceRelative\n - EFM\n\n\n\n\n\n\nLabel Parameters\n\n\nlabelText\n - EFM\n\n\nlabelSize\n - EFM\n\n\nlabelColor\n - EFM\n\n\nselLabelColor\n - EFM\n\n\nlabelFont\n - EFM\n\n\nlabelOffset\n - EFM\n\n\nlabelHorizAlign\n - EFM\n\n\nemboss\n - EFM\n\n\nlabelHorizAlign\n - EFM\n\n\n\n\n\n\nRectangle Parameters\n\n\nunselRectFillColor\n - EFM\n\n\nselRectFillColor\n - EFM\n\n\ncornerRadius\n - EFM\n\n\n\n\n\n\nImage Parameters\n\n\nunselImgSrc\n - EFM\n\n\nselImgSrc\n - EFM\n\n\nunselImgFillColor\n - EFM\n\n\nselImgFillColor\n - EFM\n\n\n\n\n\n\nSlice Parameters\n\n\nunselSliceSrc\n - EFM\n\n\nselSliceSrc\n - EFM\n\n\nunselSliceFillColor\n - EFM\n\n\nselSliceFillColor\n - EFM \n\n\n\n\n\n\nTouch Masking Parameters\n\n\ntouchMask\n - EFM\n\n\ntouchMaskW\n, \ntouchMaskH\n - EFM\n\n\n\n\n\n\nStroke Parameters\n\n\nunselStrokeColor\n - EFM\n\n\nselStrokeColor\n - EFM\n\n\nstrokeWidth\n - EFM\n\n\nstrokeColor\n - EFM\n\n\n\n\n\n\nOverlay Parameters    \n\n\nbuttonOverlayRectColor\n - EFM\n\n\nbuttonOverlayImgSrc\n - EFM\n\n\nbuttonOverlayFillColor\n - EFM\n\n\n\n\n\n\n\n\nComponents Of A Slider\n\n\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\n\n\n\n\nLabels\n\n\nSSK also comes with a text object factories library that incorporates the idea of presets.\n\n\n\n\nlabels:addLabelPreset( presetName, params )\n - Add a label preset definition to the labels preset library.\n\n\nlabels:newLabel( params, screenGroup )\n - Generic label builder, used by \nlabels:presetLabel()\n.\n\n\nlabels:presetLabel( group, presetName, text, x, y, params  )\n\n\n\n\nQuick Labels\n\n\nAs great as preset labels are, I often tend to use the following functions instead.  They are simple improvments on the standard \ndisplay.newText()\n and \ndisplay.newEmbossedText()\n factories.\n\n\n\n\nlabels:quickLabel( group, text, x, y, font, fontSize, textColor, anchorX, anchorY )\n \n\n\nlabels:quickEmbossedLabel( group, text, x, y, font, fontSize, embossTextColor, embossHighlightColor, embossShadowColor )\n\n\n\n\n\n\nEffects\n\n\nThe button library comes with a set of functions that let you do useful visual calculations and to apply cool visual effects to button (and other display objects if you choose).\n\n\nVisual Calculations\n\n\n\n\nisInBounds( obj, obj2 )\n - EFM\n\n\nisInBounds_alt( obj, obj2 )\n - EFM\n\n\nEFM\n - EFM\n\n\n\n\nFly Ins\n\n\n\n\neasyFlyIn( obj, params )\n - EFM\n\n\n\n\nSqueeze \n Inflate\n\n\n\n\neasySqueeze( obj, xScale1, yScale1, xScale2, yScale2, delay, time1, time2, time3, myEasing, myEasing2, myEasing3 )\n\n\neasyInflate( obj, xScale1, yScale1, xScale2, yScale2, xScale3, yScale3, delay, time1, time2, time3, myEasing, myEasing2, myEasing3 )\n\n\n\n\nShrink \n Grow\n\n\n\n\ndoShrink( obj, to )\n\n\ndoGrow( obj, to )\n\n\n\n\nFlipping\n\n\n\n\neasyFlip( obj, params )\n\n\n\n\nPulsing\n\n\n\n\npulse( obj, params )\n\n\n\n\nEasy Pinch-Zoom-Drag\n\n\n\n\npinchZoomDragTouch( self, event )\n - Just use this as the touch listener on an object to get full pinch-zoom-drag functionality.\n\n\nsetMinDragDist( dist )\n - Adjust the minimum distance SSK thinks is drag.  Default is 3 pixels.\n\n\n\n\nButton Callbacks\n\n\nEFM EFM EFM\nEFM EFM EFM\nEFM EFM EFM\n\n\nWho needs another interface library?\n\n\n(\nNote:\n Let me say I am not ripping on \nwidget.*\n. It is a fine library that was designed to replicate the common interfaces of iOS and Android.  It splits the game/business usage down the middle. It is perfect as a general library for Corona SDK developers.)\n\n\neasyIFC.*\n was born out of my need to quickly and easily create buttons (push, toggle, and radio) and sliders for games.  I found that while I could use \nwidget.*\n for this it took more coding effort than I was willing to endure. \n\n\nSo... I dug in and wrote my own library (\neasyIFC.*\n) that supports all the buttons and sliders I needed and has these additional features:\n\n\n\n\nOne Line Creation\n - Make buttons and sliders with a single call.\n\n\nPreset Library\n  - Optionally pre-define the look and feel of common buttons and re-use that information to make new buttons.  \n\n\nOverrides\n - Optionally override any preset-parameter while creating a button to account for those \none-off\n cases.\n\n\n\n\n\n\nHyper-Flexible Construction\n - You can use an arbitrary combination of images, rectangles, frames, etc. to build sexy/great looking buttons.\n\n\n... more\n\n\n\n\nCode Comparison: \neasyIFC.*\n versus using \nwidget.*\n\n\nPush Button with \neasyIFC.*\n\n\n\n-- Forward declaration to reduce typing and speed up future calls\nlocal easyIFC = ssk.easyIFC\n\nlocal group = display.newGroup()\n\nlocal function onRelease( event )\n    print(\nPressed Button\n)\nend\n\n-- Create the easyIFC push button\neasyIFC:presetPush( group, \ndefault\n, 100, 100, 50, 40, \nHello\n, onRelease, { labelSize = 72 } )\n\n\n\n\n\nPush Button with \nwidget.*\n\n\n```lua\n\n\nlocal widget = require( \"widget\" )\n\n\nlocal group = display.newGroup()\n\n\nlocal function onRelease( event )\n    print(\"Pressed Button\")\nend\n\n\n-- Create the widget push button\nwidget.newButton(\n    {\n        parent       = group,\n        x            = 100,\n        y            = 100,\n        width        = 50,\n        height       = \"40\",\n        defaultFile  = \"fillW.png\",\n        fillColor    = { default={ 0.25, 0.25, 0.25, 1 }, over={ 0.5, 0.5, 0.5, 1 } },\n        label        = \"Hello\",\n        fontSize     = 72,\n        labelColor   = { default={ 1, 1, 1, 1 }, over={ 1, 1, 1, 1 } },\n        onRelease    = onRelease,\n    }\n)\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.easyIFC.* (Button Presets)"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#easy-interface-factories-sskeasyifc", 
            "text": "", 
            "title": "Easy Interface Factories (ssk.easyIFC.*)"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#buttons-standard-factories", 
            "text": "buttons:newButton( group, params )  - Generic button builder, called by following:  buttons:presetPush( group, presetName, x, y, w, h, labelText, onRelease, overrideParams)  buttons:presetToggle( group, presetName, x,y,w,h, labelText, onEvent, overrideParams)  buttons:presetRadio( group, presetName, x, y , w, h, labelText, onRelease, overrideParams)", 
            "title": "Buttons - Standard Factories"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#buttoninstance", 
            "text": "Each of the above factories returns a  buttonInstance  (a display group with special fields and functions attached, that contains all of the button 'parts'.)", 
            "title": "buttonInstance"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#button-factory-parameters", 
            "text": "The factories share a fairly consistent set of parameters:   group  - Display group to place button/slider into.  presetName  - String identifying preset to use to configure button/slider.  x ,  y  - x- and y- position of button/slider center.  w ,  h  - Width and height of button.  labelText  - (Optional) text to put on button.  May be \"\" for no text.  onPress  - Listener called only on 'began' phase of button touch.  onRelease  - Listener called only on 'ended' phase of button touch, and then only if the  finger  is still 'over' the button when lifted.  onEvent  - A generic listener that gets all phases of the touch.  overrideParams  - (Optional) table that lets you override any property in the preset and set any property you wish.  See ' overrideParams ' below for the extensive listof properties.", 
            "title": "Button Factory Parameters"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#button-utilities", 
            "text": "ssk.easyIfC.*  provides two button related utility functions:   buttons:addButtonPreset( presetName, params )  - Method to add preset definitions to known presets library.  buttons.getCurrentRadio( group )  - Returns the currently toggled radio button in a group.", 
            "title": "Button Utilities"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#buttoninstance-properties", 
            "text": "isPressed  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM", 
            "title": "buttonInstance - Properties"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#buttoninstance-methods", 
            "text": "buttonInstance:pressed( )  - EFM  buttonInstance:toggle( noDispatch )  - EFM  buttonInstance:disable( )  - EFM  buttonInstance:enable( )  - EFM  buttonInstance:isEnabled()  - EFM  buttonInstance:getText( )  - EFM  buttonInstance:setText( newText )  - EFM  buttonInstance:getTextColor()  - EFM  buttonInstance:setFillColor( color )  - EFM  buttonInstance:adjustLabelOffset( offset )  - EFM  buttonInstance:setHighlight( vis )  - EFM  buttonInstance:setSize( width, height )  - EFM", 
            "title": "buttonInstance - Methods"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#components-of-a-button", 
            "text": "Before we look at  overrideParams  (next in the docs), it would be helpful to understand some basic principles behind how a button is created.  easyIFC.*  button factories build two-state buttons.  That is they are either un-selected (OFF), or selected (ON).    To achieve this,  easyIFC.*  button factories use  minimum  of four display ojects:   Display Group  - This contains all the button parts and is the object that is returned by the factories.  Selected Rectangle or Image    Un-Selected Rectangle or Image    Text Label     As a rule of thumb, you only want to use rectangles or images for the selected and unselected representation, but you may have them all in any combination.  Just be aware that the stacking order will be:   Rectangles    Images  Slices", 
            "title": "Components Of A Button"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#what-are-slices", 
            "text": "Slices are a feature I added recently that allows you to create buttons from a set of sliced up images.  This is similar to what the  widget.*  library does.  Unlike  widget.*  however I use discrete images and not a sprite sheet. This is slightly less efficient, but much easier to create for new developers.", 
            "title": "What Are Slices?"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#the-other-parts", 
            "text": "Strokes  - You may of course set strokes for the two button representations..  Fills  - Each part of the button can have a fill color to shade it.  Note:  I chose not to support the other paint styles because I didn't see much value in them when I could just as easily create the button I needed in Photoshop.    Overlays  - You can have both a rectangle and image overlay if you want.  Each of these lays over the other parts of the button to act like a frame of sorts.", 
            "title": "The Other Parts"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#overrideparams", 
            "text": "General  buttonType  - EFM  anchorX  - EFM  anchorY  - EFM  placeRelative  - EFM    Label Parameters  labelText  - EFM  labelSize  - EFM  labelColor  - EFM  selLabelColor  - EFM  labelFont  - EFM  labelOffset  - EFM  labelHorizAlign  - EFM  emboss  - EFM  labelHorizAlign  - EFM    Rectangle Parameters  unselRectFillColor  - EFM  selRectFillColor  - EFM  cornerRadius  - EFM    Image Parameters  unselImgSrc  - EFM  selImgSrc  - EFM  unselImgFillColor  - EFM  selImgFillColor  - EFM    Slice Parameters  unselSliceSrc  - EFM  selSliceSrc  - EFM  unselSliceFillColor  - EFM  selSliceFillColor  - EFM     Touch Masking Parameters  touchMask  - EFM  touchMaskW ,  touchMaskH  - EFM    Stroke Parameters  unselStrokeColor  - EFM  selStrokeColor  - EFM  strokeWidth  - EFM  strokeColor  - EFM    Overlay Parameters      buttonOverlayRectColor  - EFM  buttonOverlayImgSrc  - EFM  buttonOverlayFillColor  - EFM", 
            "title": "overrideParams"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#components-of-a-slider", 
            "text": "EFM  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM", 
            "title": "Components Of A Slider"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#labels", 
            "text": "SSK also comes with a text object factories library that incorporates the idea of presets.   labels:addLabelPreset( presetName, params )  - Add a label preset definition to the labels preset library.  labels:newLabel( params, screenGroup )  - Generic label builder, used by  labels:presetLabel() .  labels:presetLabel( group, presetName, text, x, y, params  )", 
            "title": "Labels"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#quick-labels", 
            "text": "As great as preset labels are, I often tend to use the following functions instead.  They are simple improvments on the standard  display.newText()  and  display.newEmbossedText()  factories.   labels:quickLabel( group, text, x, y, font, fontSize, textColor, anchorX, anchorY )    labels:quickEmbossedLabel( group, text, x, y, font, fontSize, embossTextColor, embossHighlightColor, embossShadowColor )", 
            "title": "Quick Labels"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#effects", 
            "text": "The button library comes with a set of functions that let you do useful visual calculations and to apply cool visual effects to button (and other display objects if you choose).", 
            "title": "Effects"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#visual-calculations", 
            "text": "isInBounds( obj, obj2 )  - EFM  isInBounds_alt( obj, obj2 )  - EFM  EFM  - EFM", 
            "title": "Visual Calculations"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#fly-ins", 
            "text": "easyFlyIn( obj, params )  - EFM", 
            "title": "Fly Ins"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#squeeze-inflate", 
            "text": "easySqueeze( obj, xScale1, yScale1, xScale2, yScale2, delay, time1, time2, time3, myEasing, myEasing2, myEasing3 )  easyInflate( obj, xScale1, yScale1, xScale2, yScale2, xScale3, yScale3, delay, time1, time2, time3, myEasing, myEasing2, myEasing3 )", 
            "title": "Squeeze &amp; Inflate"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#shrink-grow", 
            "text": "doShrink( obj, to )  doGrow( obj, to )", 
            "title": "Shrink &amp; Grow"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#flipping", 
            "text": "easyFlip( obj, params )", 
            "title": "Flipping"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#pulsing", 
            "text": "pulse( obj, params )", 
            "title": "Pulsing"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#easy-pinch-zoom-drag", 
            "text": "pinchZoomDragTouch( self, event )  - Just use this as the touch listener on an object to get full pinch-zoom-drag functionality.  setMinDragDist( dist )  - Adjust the minimum distance SSK thinks is drag.  Default is 3 pixels.", 
            "title": "Easy Pinch-Zoom-Drag"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#button-callbacks", 
            "text": "EFM EFM EFM\nEFM EFM EFM\nEFM EFM EFM", 
            "title": "Button Callbacks"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#who-needs-another-interface-library", 
            "text": "( Note:  Let me say I am not ripping on  widget.* . It is a fine library that was designed to replicate the common interfaces of iOS and Android.  It splits the game/business usage down the middle. It is perfect as a general library for Corona SDK developers.)  easyIFC.*  was born out of my need to quickly and easily create buttons (push, toggle, and radio) and sliders for games.  I found that while I could use  widget.*  for this it took more coding effort than I was willing to endure.   So... I dug in and wrote my own library ( easyIFC.* ) that supports all the buttons and sliders I needed and has these additional features:   One Line Creation  - Make buttons and sliders with a single call.  Preset Library   - Optionally pre-define the look and feel of common buttons and re-use that information to make new buttons.    Overrides  - Optionally override any preset-parameter while creating a button to account for those  one-off  cases.    Hyper-Flexible Construction  - You can use an arbitrary combination of images, rectangles, frames, etc. to build sexy/great looking buttons.  ... more", 
            "title": "Who needs another interface library?"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#code-comparison-easyifc-versus-using-widget", 
            "text": "", 
            "title": "Code Comparison: easyIFC.* versus using widget.*"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#push-button-with-easyifc", 
            "text": "-- Forward declaration to reduce typing and speed up future calls\nlocal easyIFC = ssk.easyIFC\n\nlocal group = display.newGroup()\n\nlocal function onRelease( event )\n    print( Pressed Button )\nend\n\n-- Create the easyIFC push button\neasyIFC:presetPush( group,  default , 100, 100, 50, 40,  Hello , onRelease, { labelSize = 72 } )", 
            "title": "Push Button with easyIFC.*"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_presets/#push-button-with-widget", 
            "text": "```lua  local widget = require( \"widget\" )  local group = display.newGroup()  local function onRelease( event )\n    print(\"Pressed Button\")\nend  -- Create the widget push button\nwidget.newButton(\n    {\n        parent       = group,\n        x            = 100,\n        y            = 100,\n        width        = 50,\n        height       = \"40\",\n        defaultFile  = \"fillW.png\",\n        fillColor    = { default={ 0.25, 0.25, 0.25, 1 }, over={ 0.5, 0.5, 0.5, 1 } },\n        label        = \"Hello\",\n        fontSize     = 72,\n        labelColor   = { default={ 1, 1, 1, 1 }, over={ 1, 1, 1, 1 } },\n        onRelease    = onRelease,\n    }\n)     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Push Button with widget.*"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_instance/", 
            "text": "Easy Interface Buttons (ssk.easyIFC.*)\n\n\n\n\nbuttons:newButton( group, params )\n - Generic button builder, called by following:\n\n\nbuttons:presetPush( group, presetName, x, y, w, h, labelText, onRelease, overrideParams)\n\n\nbuttons:presetToggle( group, presetName, x,y,w,h, labelText, onEvent, overrideParams)\n\n\nbuttons:presetRadio( group, presetName, x, y , w, h, labelText, onRelease, overrideParams)\n\n\n\n\nbuttonInstance\n\n\nEach of the above factories returns a \nbuttonInstance\n (a display group with special fields and functions attached, that contains all of the button 'parts'.)\n\n\nButton Factory Parameters\n\n\nThe factories share a fairly consistent set of parameters:\n\n\n\n\ngroup\n - Display group to place button/slider into.\n\n\npresetName\n - String identifying preset to use to configure button/slider.\n\n\nx\n, \ny\n - x- and y- position of button/slider center.\n\n\nw\n, \nh\n - Width and height of button.\n\n\nlabelText\n - (Optional) text to put on button.  May be \"\" for no text.\n\n\nonPress\n - Listener called only on 'began' phase of button touch.\n\n\nonRelease\n - Listener called only on 'ended' phase of button touch, and then only if the \nfinger\n is still 'over' the button when lifted.\n\n\nonEvent\n - A generic listener that gets all phases of the touch.\n\n\noverrideParams\n - (Optional) table that lets you override any property in the preset and set any property you wish.  See '\noverrideParams\n' below for the extensive listof properties.\n\n\n\n\nButton Utilities\n\n\nssk.easyIfC.*\n provides two button related utility functions:\n\n\n\n\nbuttons:addButtonPreset( presetName, params )\n - Method to add preset definitions to known presets library.\n\n\nbuttons.getCurrentRadio( group )\n - Returns the currently toggled radio button in a group.\n\n\n\n\nbuttonInstance\n - Properties\n\n\n\n\nisPressed\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\n\n\nbuttonInstance\n - Methods\n\n\n\n\nbuttonInstance:pressed( )\n - EFM\n\n\nbuttonInstance:toggle( noDispatch )\n - EFM\n\n\nbuttonInstance:disable( )\n - EFM\n\n\nbuttonInstance:enable( )\n - EFM\n\n\nbuttonInstance:isEnabled()\n - EFM\n\n\nbuttonInstance:getText( )\n - EFM\n\n\nbuttonInstance:setText( newText )\n - EFM\n\n\nbuttonInstance:getTextColor()\n - EFM\n\n\nbuttonInstance:setFillColor( color )\n - EFM\n\n\nbuttonInstance:adjustLabelOffset( offset )\n - EFM\n\n\nbuttonInstance:setHighlight( vis )\n - EFM\n\n\nbuttonInstance:setSize( width, height )\n - EFM\n\n\n\n\nComponents Of A Button\n\n\nBefore we look at \noverrideParams\n (next in the docs), it would be helpful to understand some basic principles behind how a button is created.\n\n\neasyIFC.*\n button factories build two-state buttons.  That is they are either un-selected (OFF), or selected (ON).  \n\n\nTo achieve this, \neasyIFC.*\n button factories use \nminimum\n of four display ojects:\n\n\n\n\nDisplay Group\n - This contains all the button parts and is the object that is returned by the factories.\n\n\nSelected Rectangle or Image\n \n\n\nUn-Selected Rectangle or Image\n \n\n\nText Label\n \n\n\n\n\nAs a rule of thumb, you only want to use rectangles or images for the selected and unselected representation, but you may have them all in any combination.  Just be aware that the stacking order will be:\n\n\n\n\nRectangles\n \n\n\nImages\n\n\nSlices\n \n\n\n\n\nWhat Are Slices?\n\n\nSlices are a feature I added recently that allows you to create buttons from a set of sliced up images.  This is similar to what the \nwidget.*\n library does.  Unlike \nwidget.*\n however I use discrete images and not a sprite sheet. This is slightly less efficient, but much easier to create for new developers.\n\n\nThe Other Parts\n\n\n\n\nStrokes\n - You may of course set strokes for the two button representations..\n\n\nFills\n - Each part of the button can have a fill color to shade it.\n\n\nNote:\n I chose not to support the other paint styles because I didn't see much value in them when I could just as easily create the button I needed in Photoshop.\n\n\n\n\n\n\nOverlays\n - You can have both a rectangle and image overlay if you want.  Each of these lays over the other parts of the button to act like a frame of sorts.\n\n\n\n\noverrideParams\n\n\n\n\nGeneral\n\n\nbuttonType\n - EFM\n\n\nanchorX\n - EFM\n\n\nanchorY\n - EFM\n\n\nplaceRelative\n - EFM\n\n\n\n\n\n\nLabel Parameters\n\n\nlabelText\n - EFM\n\n\nlabelSize\n - EFM\n\n\nlabelColor\n - EFM\n\n\nselLabelColor\n - EFM\n\n\nlabelFont\n - EFM\n\n\nlabelOffset\n - EFM\n\n\nlabelHorizAlign\n - EFM\n\n\nemboss\n - EFM\n\n\nlabelHorizAlign\n - EFM\n\n\n\n\n\n\nRectangle Parameters\n\n\nunselRectFillColor\n - EFM\n\n\nselRectFillColor\n - EFM\n\n\ncornerRadius\n - EFM\n\n\n\n\n\n\nImage Parameters\n\n\nunselImgSrc\n - EFM\n\n\nselImgSrc\n - EFM\n\n\nunselImgFillColor\n - EFM\n\n\nselImgFillColor\n - EFM\n\n\n\n\n\n\nSlice Parameters\n\n\nunselSliceSrc\n - EFM\n\n\nselSliceSrc\n - EFM\n\n\nunselSliceFillColor\n - EFM\n\n\nselSliceFillColor\n - EFM \n\n\n\n\n\n\nTouch Masking Parameters\n\n\ntouchMask\n - EFM\n\n\ntouchMaskW\n, \ntouchMaskH\n - EFM\n\n\n\n\n\n\nStroke Parameters\n\n\nunselStrokeColor\n - EFM\n\n\nselStrokeColor\n - EFM\n\n\nstrokeWidth\n - EFM\n\n\nstrokeColor\n - EFM\n\n\n\n\n\n\nOverlay Parameters    \n\n\nbuttonOverlayRectColor\n - EFM\n\n\nbuttonOverlayImgSrc\n - EFM\n\n\nbuttonOverlayFillColor\n - EFM\n\n\n\n\n\n\n\n\nWho needs another interface library?\n\n\n(\nNote:\n Let me say I am not ripping on \nwidget.*\n. It is a fine library that was designed to replicate the common interfaces of iOS and Android.  It splits the game/business usage down the middle. It is perfect as a general library for Corona SDK developers.)\n\n\neasyIFC.*\n was born out of my need to quickly and easily create buttons (push, toggle, and radio) and sliders for games.  I found that while I could use \nwidget.*\n for this it took more coding effort than I was willing to endure. \n\n\nSo... I dug in and wrote my own library (\neasyIFC.*\n) that supports all the buttons and sliders I needed and has these additional features:\n\n\n\n\nOne Line Creation\n - Make buttons and sliders with a single call.\n\n\nPreset Library\n  - Optionally pre-define the look and feel of common buttons and re-use that information to make new buttons.  \n\n\nOverrides\n - Optionally override any preset-parameter while creating a button to account for those \none-off\n cases.\n\n\n\n\n\n\nHyper-Flexible Construction\n - You can use an arbitrary combination of images, rectangles, frames, etc. to build sexy/great looking buttons.\n\n\n... more\n\n\n\n\nCode Comparison: \neasyIFC.*\n versus using \nwidget.*\n\n\nPush Button with \neasyIFC.*\n\n\n\n-- Forward declaration to reduce typing and speed up future calls\nlocal easyIFC = ssk.easyIFC\n\nlocal group = display.newGroup()\n\nlocal function onRelease( event )\n    print(\nPressed Button\n)\nend\n\n-- Create the easyIFC push button\neasyIFC:presetPush( group, \ndefault\n, 100, 100, 50, 40, \nHello\n, onRelease, { labelSize = 72 } )\n\n\n\n\n\nPush Button with \nwidget.*\n\n\n```lua\n\n\nlocal widget = require( \"widget\" )\n\n\nlocal group = display.newGroup()\n\n\nlocal function onRelease( event )\n    print(\"Pressed Button\")\nend\n\n\n-- Create the widget push button\nwidget.newButton(\n    {\n        parent       = group,\n        x            = 100,\n        y            = 100,\n        width        = 50,\n        height       = \"40\",\n        defaultFile  = \"fillW.png\",\n        fillColor    = { default={ 0.25, 0.25, 0.25, 1 }, over={ 0.5, 0.5, 0.5, 1 } },\n        label        = \"Hello\",\n        fontSize     = 72,\n        labelColor   = { default={ 1, 1, 1, 1 }, over={ 1, 1, 1, 1 } },\n        onRelease    = onRelease,\n    }\n)\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.easyIFC.* (Button Instance)"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_instance/#easy-interface-buttons-sskeasyifc", 
            "text": "buttons:newButton( group, params )  - Generic button builder, called by following:  buttons:presetPush( group, presetName, x, y, w, h, labelText, onRelease, overrideParams)  buttons:presetToggle( group, presetName, x,y,w,h, labelText, onEvent, overrideParams)  buttons:presetRadio( group, presetName, x, y , w, h, labelText, onRelease, overrideParams)", 
            "title": "Easy Interface Buttons (ssk.easyIFC.*)"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_instance/#buttoninstance", 
            "text": "Each of the above factories returns a  buttonInstance  (a display group with special fields and functions attached, that contains all of the button 'parts'.)", 
            "title": "buttonInstance"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_instance/#button-factory-parameters", 
            "text": "The factories share a fairly consistent set of parameters:   group  - Display group to place button/slider into.  presetName  - String identifying preset to use to configure button/slider.  x ,  y  - x- and y- position of button/slider center.  w ,  h  - Width and height of button.  labelText  - (Optional) text to put on button.  May be \"\" for no text.  onPress  - Listener called only on 'began' phase of button touch.  onRelease  - Listener called only on 'ended' phase of button touch, and then only if the  finger  is still 'over' the button when lifted.  onEvent  - A generic listener that gets all phases of the touch.  overrideParams  - (Optional) table that lets you override any property in the preset and set any property you wish.  See ' overrideParams ' below for the extensive listof properties.", 
            "title": "Button Factory Parameters"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_instance/#button-utilities", 
            "text": "ssk.easyIfC.*  provides two button related utility functions:   buttons:addButtonPreset( presetName, params )  - Method to add preset definitions to known presets library.  buttons.getCurrentRadio( group )  - Returns the currently toggled radio button in a group.", 
            "title": "Button Utilities"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_instance/#buttoninstance-properties", 
            "text": "isPressed  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM", 
            "title": "buttonInstance - Properties"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_instance/#buttoninstance-methods", 
            "text": "buttonInstance:pressed( )  - EFM  buttonInstance:toggle( noDispatch )  - EFM  buttonInstance:disable( )  - EFM  buttonInstance:enable( )  - EFM  buttonInstance:isEnabled()  - EFM  buttonInstance:getText( )  - EFM  buttonInstance:setText( newText )  - EFM  buttonInstance:getTextColor()  - EFM  buttonInstance:setFillColor( color )  - EFM  buttonInstance:adjustLabelOffset( offset )  - EFM  buttonInstance:setHighlight( vis )  - EFM  buttonInstance:setSize( width, height )  - EFM", 
            "title": "buttonInstance - Methods"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_instance/#components-of-a-button", 
            "text": "Before we look at  overrideParams  (next in the docs), it would be helpful to understand some basic principles behind how a button is created.  easyIFC.*  button factories build two-state buttons.  That is they are either un-selected (OFF), or selected (ON).    To achieve this,  easyIFC.*  button factories use  minimum  of four display ojects:   Display Group  - This contains all the button parts and is the object that is returned by the factories.  Selected Rectangle or Image    Un-Selected Rectangle or Image    Text Label     As a rule of thumb, you only want to use rectangles or images for the selected and unselected representation, but you may have them all in any combination.  Just be aware that the stacking order will be:   Rectangles    Images  Slices", 
            "title": "Components Of A Button"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_instance/#what-are-slices", 
            "text": "Slices are a feature I added recently that allows you to create buttons from a set of sliced up images.  This is similar to what the  widget.*  library does.  Unlike  widget.*  however I use discrete images and not a sprite sheet. This is slightly less efficient, but much easier to create for new developers.", 
            "title": "What Are Slices?"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_instance/#the-other-parts", 
            "text": "Strokes  - You may of course set strokes for the two button representations..  Fills  - Each part of the button can have a fill color to shade it.  Note:  I chose not to support the other paint styles because I didn't see much value in them when I could just as easily create the button I needed in Photoshop.    Overlays  - You can have both a rectangle and image overlay if you want.  Each of these lays over the other parts of the button to act like a frame of sorts.", 
            "title": "The Other Parts"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_instance/#overrideparams", 
            "text": "General  buttonType  - EFM  anchorX  - EFM  anchorY  - EFM  placeRelative  - EFM    Label Parameters  labelText  - EFM  labelSize  - EFM  labelColor  - EFM  selLabelColor  - EFM  labelFont  - EFM  labelOffset  - EFM  labelHorizAlign  - EFM  emboss  - EFM  labelHorizAlign  - EFM    Rectangle Parameters  unselRectFillColor  - EFM  selRectFillColor  - EFM  cornerRadius  - EFM    Image Parameters  unselImgSrc  - EFM  selImgSrc  - EFM  unselImgFillColor  - EFM  selImgFillColor  - EFM    Slice Parameters  unselSliceSrc  - EFM  selSliceSrc  - EFM  unselSliceFillColor  - EFM  selSliceFillColor  - EFM     Touch Masking Parameters  touchMask  - EFM  touchMaskW ,  touchMaskH  - EFM    Stroke Parameters  unselStrokeColor  - EFM  selStrokeColor  - EFM  strokeWidth  - EFM  strokeColor  - EFM    Overlay Parameters      buttonOverlayRectColor  - EFM  buttonOverlayImgSrc  - EFM  buttonOverlayFillColor  - EFM", 
            "title": "overrideParams"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_instance/#who-needs-another-interface-library", 
            "text": "( Note:  Let me say I am not ripping on  widget.* . It is a fine library that was designed to replicate the common interfaces of iOS and Android.  It splits the game/business usage down the middle. It is perfect as a general library for Corona SDK developers.)  easyIFC.*  was born out of my need to quickly and easily create buttons (push, toggle, and radio) and sliders for games.  I found that while I could use  widget.*  for this it took more coding effort than I was willing to endure.   So... I dug in and wrote my own library ( easyIFC.* ) that supports all the buttons and sliders I needed and has these additional features:   One Line Creation  - Make buttons and sliders with a single call.  Preset Library   - Optionally pre-define the look and feel of common buttons and re-use that information to make new buttons.    Overrides  - Optionally override any preset-parameter while creating a button to account for those  one-off  cases.    Hyper-Flexible Construction  - You can use an arbitrary combination of images, rectangles, frames, etc. to build sexy/great looking buttons.  ... more", 
            "title": "Who needs another interface library?"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_instance/#code-comparison-easyifc-versus-using-widget", 
            "text": "", 
            "title": "Code Comparison: easyIFC.* versus using widget.*"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_instance/#push-button-with-easyifc", 
            "text": "-- Forward declaration to reduce typing and speed up future calls\nlocal easyIFC = ssk.easyIFC\n\nlocal group = display.newGroup()\n\nlocal function onRelease( event )\n    print( Pressed Button )\nend\n\n-- Create the easyIFC push button\neasyIFC:presetPush( group,  default , 100, 100, 50, 40,  Hello , onRelease, { labelSize = 72 } )", 
            "title": "Push Button with easyIFC.*"
        }, 
        {
            "location": "/libraries/easy_interfaces_button_instance/#push-button-with-widget", 
            "text": "```lua  local widget = require( \"widget\" )  local group = display.newGroup()  local function onRelease( event )\n    print(\"Pressed Button\")\nend  -- Create the widget push button\nwidget.newButton(\n    {\n        parent       = group,\n        x            = 100,\n        y            = 100,\n        width        = 50,\n        height       = \"40\",\n        defaultFile  = \"fillW.png\",\n        fillColor    = { default={ 0.25, 0.25, 0.25, 1 }, over={ 0.5, 0.5, 0.5, 1 } },\n        label        = \"Hello\",\n        fontSize     = 72,\n        labelColor   = { default={ 1, 1, 1, 1 }, over={ 1, 1, 1, 1 } },\n        onRelease    = onRelease,\n    }\n)     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Push Button with widget.*"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/", 
            "text": "Easy Interface Factories (ssk.easyIFC.*)\n\n\nButtons - Standard Factories\n\n\n\n\nbuttons:newButton( group, params )\n - Generic button builder, called by following:\n\n\nbuttons:presetPush( group, presetName, x, y, w, h, labelText, onRelease, overrideParams)\n\n\nbuttons:presetToggle( group, presetName, x,y,w,h, labelText, onEvent, overrideParams)\n\n\nbuttons:presetRadio( group, presetName, x, y , w, h, labelText, onRelease, overrideParams)\n\n\n\n\nbuttonInstance\n\n\nEach of the above factories returns a \nbuttonInstance\n (a display group with special fields and functions attached, that contains all of the button 'parts'.)\n\n\nButton Factory Parameters\n\n\nThe factories share a fairly consistent set of parameters:\n\n\n\n\ngroup\n - Display group to place button/slider into.\n\n\npresetName\n - String identifying preset to use to configure button/slider.\n\n\nx\n, \ny\n - x- and y- position of button/slider center.\n\n\nw\n, \nh\n - Width and height of button.\n\n\nlabelText\n - (Optional) text to put on button.  May be \"\" for no text.\n\n\nonPress\n - Listener called only on 'began' phase of button touch.\n\n\nonRelease\n - Listener called only on 'ended' phase of button touch, and then only if the \nfinger\n is still 'over' the button when lifted.\n\n\nonEvent\n - A generic listener that gets all phases of the touch.\n\n\noverrideParams\n - (Optional) table that lets you override any property in the preset and set any property you wish.  See '\noverrideParams\n' below for the extensive listof properties.\n\n\n\n\nButton Utilities\n\n\nssk.easyIfC.*\n provides two button related utility functions:\n\n\n\n\nbuttons:addButtonPreset( presetName, params )\n - Method to add preset definitions to known presets library.\n\n\nbuttons.getCurrentRadio( group )\n - Returns the currently toggled radio button in a group.\n\n\n\n\nbuttonInstance\n - Properties\n\n\n\n\nisPressed\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\n\n\nbuttonInstance\n - Methods\n\n\n\n\nbuttonInstance:pressed( )\n - EFM\n\n\nbuttonInstance:toggle( noDispatch )\n - EFM\n\n\nbuttonInstance:disable( )\n - EFM\n\n\nbuttonInstance:enable( )\n - EFM\n\n\nbuttonInstance:isEnabled()\n - EFM\n\n\nbuttonInstance:getText( )\n - EFM\n\n\nbuttonInstance:setText( newText )\n - EFM\n\n\nbuttonInstance:getTextColor()\n - EFM\n\n\nbuttonInstance:setFillColor( color )\n - EFM\n\n\nbuttonInstance:adjustLabelOffset( offset )\n - EFM\n\n\nbuttonInstance:setHighlight( vis )\n - EFM\n\n\nbuttonInstance:setSize( width, height )\n - EFM\n\n\n\n\nComponents Of A Button\n\n\nBefore we look at \noverrideParams\n (next in the docs), it would be helpful to understand some basic principles behind how a button is created.\n\n\neasyIFC.*\n button factories build two-state buttons.  That is they are either un-selected (OFF), or selected (ON).  \n\n\nTo achieve this, \neasyIFC.*\n button factories use \nminimum\n of four display ojects:\n\n\n\n\nDisplay Group\n - This contains all the button parts and is the object that is returned by the factories.\n\n\nSelected Rectangle or Image\n \n\n\nUn-Selected Rectangle or Image\n \n\n\nText Label\n \n\n\n\n\nAs a rule of thumb, you only want to use rectangles or images for the selected and unselected representation, but you may have them all in any combination.  Just be aware that the stacking order will be:\n\n\n\n\nRectangles\n \n\n\nImages\n\n\nSlices\n \n\n\n\n\nWhat Are Slices?\n\n\nSlices are a feature I added recently that allows you to create buttons from a set of sliced up images.  This is similar to what the \nwidget.*\n library does.  Unlike \nwidget.*\n however I use discrete images and not a sprite sheet. This is slightly less efficient, but much easier to create for new developers.\n\n\nThe Other Parts\n\n\n\n\nStrokes\n - You may of course set strokes for the two button representations..\n\n\nFills\n - Each part of the button can have a fill color to shade it.\n\n\nNote:\n I chose not to support the other paint styles because I didn't see much value in them when I could just as easily create the button I needed in Photoshop.\n\n\n\n\n\n\nOverlays\n - You can have both a rectangle and image overlay if you want.  Each of these lays over the other parts of the button to act like a frame of sorts.\n\n\n\n\noverrideParams\n\n\n\n\nGeneral\n\n\nbuttonType\n - EFM\n\n\nanchorX\n - EFM\n\n\nanchorY\n - EFM\n\n\nplaceRelative\n - EFM\n\n\n\n\n\n\nLabel Parameters\n\n\nlabelText\n - EFM\n\n\nlabelSize\n - EFM\n\n\nlabelColor\n - EFM\n\n\nselLabelColor\n - EFM\n\n\nlabelFont\n - EFM\n\n\nlabelOffset\n - EFM\n\n\nlabelHorizAlign\n - EFM\n\n\nemboss\n - EFM\n\n\nlabelHorizAlign\n - EFM\n\n\n\n\n\n\nRectangle Parameters\n\n\nunselRectFillColor\n - EFM\n\n\nselRectFillColor\n - EFM\n\n\ncornerRadius\n - EFM\n\n\n\n\n\n\nImage Parameters\n\n\nunselImgSrc\n - EFM\n\n\nselImgSrc\n - EFM\n\n\nunselImgFillColor\n - EFM\n\n\nselImgFillColor\n - EFM\n\n\n\n\n\n\nSlice Parameters\n\n\nunselSliceSrc\n - EFM\n\n\nselSliceSrc\n - EFM\n\n\nunselSliceFillColor\n - EFM\n\n\nselSliceFillColor\n - EFM \n\n\n\n\n\n\nTouch Masking Parameters\n\n\ntouchMask\n - EFM\n\n\ntouchMaskW\n, \ntouchMaskH\n - EFM\n\n\n\n\n\n\nStroke Parameters\n\n\nunselStrokeColor\n - EFM\n\n\nselStrokeColor\n - EFM\n\n\nstrokeWidth\n - EFM\n\n\nstrokeColor\n - EFM\n\n\n\n\n\n\nOverlay Parameters    \n\n\nbuttonOverlayRectColor\n - EFM\n\n\nbuttonOverlayImgSrc\n - EFM\n\n\nbuttonOverlayFillColor\n - EFM\n\n\n\n\n\n\n\n\nComponents Of A Slider\n\n\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\n\n\n\n\nLabels\n\n\nSSK also comes with a text object factories library that incorporates the idea of presets.\n\n\n\n\nlabels:addLabelPreset( presetName, params )\n - Add a label preset definition to the labels preset library.\n\n\nlabels:newLabel( params, screenGroup )\n - Generic label builder, used by \nlabels:presetLabel()\n.\n\n\nlabels:presetLabel( group, presetName, text, x, y, params  )\n\n\n\n\nQuick Labels\n\n\nAs great as preset labels are, I often tend to use the following functions instead.  They are simple improvments on the standard \ndisplay.newText()\n and \ndisplay.newEmbossedText()\n factories.\n\n\n\n\nlabels:quickLabel( group, text, x, y, font, fontSize, textColor, anchorX, anchorY )\n \n\n\nlabels:quickEmbossedLabel( group, text, x, y, font, fontSize, embossTextColor, embossHighlightColor, embossShadowColor )\n\n\n\n\n\n\nEffects\n\n\nThe button library comes with a set of functions that let you do useful visual calculations and to apply cool visual effects to button (and other display objects if you choose).\n\n\nVisual Calculations\n\n\n\n\nisInBounds( obj, obj2 )\n - EFM\n\n\nisInBounds_alt( obj, obj2 )\n - EFM\n\n\nEFM\n - EFM\n\n\n\n\nFly Ins\n\n\n\n\neasyFlyIn( obj, params )\n - EFM\n\n\n\n\nSqueeze \n Inflate\n\n\n\n\neasySqueeze( obj, xScale1, yScale1, xScale2, yScale2, delay, time1, time2, time3, myEasing, myEasing2, myEasing3 )\n\n\neasyInflate( obj, xScale1, yScale1, xScale2, yScale2, xScale3, yScale3, delay, time1, time2, time3, myEasing, myEasing2, myEasing3 )\n\n\n\n\nShrink \n Grow\n\n\n\n\ndoShrink( obj, to )\n\n\ndoGrow( obj, to )\n\n\n\n\nFlipping\n\n\n\n\neasyFlip( obj, params )\n\n\n\n\nPulsing\n\n\n\n\npulse( obj, params )\n\n\n\n\nEasy Pinch-Zoom-Drag\n\n\n\n\npinchZoomDragTouch( self, event )\n - Just use this as the touch listener on an object to get full pinch-zoom-drag functionality.\n\n\nsetMinDragDist( dist )\n - Adjust the minimum distance SSK thinks is drag.  Default is 3 pixels.\n\n\n\n\nButton Callbacks\n\n\nEFM EFM EFM\nEFM EFM EFM\nEFM EFM EFM\n\n\nWho needs another interface library?\n\n\n(\nNote:\n Let me say I am not ripping on \nwidget.*\n. It is a fine library that was designed to replicate the common interfaces of iOS and Android.  It splits the game/business usage down the middle. It is perfect as a general library for Corona SDK developers.)\n\n\neasyIFC.*\n was born out of my need to quickly and easily create buttons (push, toggle, and radio) and sliders for games.  I found that while I could use \nwidget.*\n for this it took more coding effort than I was willing to endure. \n\n\nSo... I dug in and wrote my own library (\neasyIFC.*\n) that supports all the buttons and sliders I needed and has these additional features:\n\n\n\n\nOne Line Creation\n - Make buttons and sliders with a single call.\n\n\nPreset Library\n  - Optionally pre-define the look and feel of common buttons and re-use that information to make new buttons.  \n\n\nOverrides\n - Optionally override any preset-parameter while creating a button to account for those \none-off\n cases.\n\n\n\n\n\n\nHyper-Flexible Construction\n - You can use an arbitrary combination of images, rectangles, frames, etc. to build sexy/great looking buttons.\n\n\n... more\n\n\n\n\nCode Comparison: \neasyIFC.*\n versus using \nwidget.*\n\n\nPush Button with \neasyIFC.*\n\n\n\n-- Forward declaration to reduce typing and speed up future calls\nlocal easyIFC = ssk.easyIFC\n\nlocal group = display.newGroup()\n\nlocal function onRelease( event )\n    print(\nPressed Button\n)\nend\n\n-- Create the easyIFC push button\neasyIFC:presetPush( group, \ndefault\n, 100, 100, 50, 40, \nHello\n, onRelease, { labelSize = 72 } )\n\n\n\n\n\nPush Button with \nwidget.*\n\n\n```lua\n\n\nlocal widget = require( \"widget\" )\n\n\nlocal group = display.newGroup()\n\n\nlocal function onRelease( event )\n    print(\"Pressed Button\")\nend\n\n\n-- Create the widget push button\nwidget.newButton(\n    {\n        parent       = group,\n        x            = 100,\n        y            = 100,\n        width        = 50,\n        height       = \"40\",\n        defaultFile  = \"fillW.png\",\n        fillColor    = { default={ 0.25, 0.25, 0.25, 1 }, over={ 0.5, 0.5, 0.5, 1 } },\n        label        = \"Hello\",\n        fontSize     = 72,\n        labelColor   = { default={ 1, 1, 1, 1 }, over={ 1, 1, 1, 1 } },\n        onRelease    = onRelease,\n    }\n)\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.easyIFC.* (Label Factories)"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#easy-interface-factories-sskeasyifc", 
            "text": "", 
            "title": "Easy Interface Factories (ssk.easyIFC.*)"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#buttons-standard-factories", 
            "text": "buttons:newButton( group, params )  - Generic button builder, called by following:  buttons:presetPush( group, presetName, x, y, w, h, labelText, onRelease, overrideParams)  buttons:presetToggle( group, presetName, x,y,w,h, labelText, onEvent, overrideParams)  buttons:presetRadio( group, presetName, x, y , w, h, labelText, onRelease, overrideParams)", 
            "title": "Buttons - Standard Factories"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#buttoninstance", 
            "text": "Each of the above factories returns a  buttonInstance  (a display group with special fields and functions attached, that contains all of the button 'parts'.)", 
            "title": "buttonInstance"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#button-factory-parameters", 
            "text": "The factories share a fairly consistent set of parameters:   group  - Display group to place button/slider into.  presetName  - String identifying preset to use to configure button/slider.  x ,  y  - x- and y- position of button/slider center.  w ,  h  - Width and height of button.  labelText  - (Optional) text to put on button.  May be \"\" for no text.  onPress  - Listener called only on 'began' phase of button touch.  onRelease  - Listener called only on 'ended' phase of button touch, and then only if the  finger  is still 'over' the button when lifted.  onEvent  - A generic listener that gets all phases of the touch.  overrideParams  - (Optional) table that lets you override any property in the preset and set any property you wish.  See ' overrideParams ' below for the extensive listof properties.", 
            "title": "Button Factory Parameters"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#button-utilities", 
            "text": "ssk.easyIfC.*  provides two button related utility functions:   buttons:addButtonPreset( presetName, params )  - Method to add preset definitions to known presets library.  buttons.getCurrentRadio( group )  - Returns the currently toggled radio button in a group.", 
            "title": "Button Utilities"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#buttoninstance-properties", 
            "text": "isPressed  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM", 
            "title": "buttonInstance - Properties"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#buttoninstance-methods", 
            "text": "buttonInstance:pressed( )  - EFM  buttonInstance:toggle( noDispatch )  - EFM  buttonInstance:disable( )  - EFM  buttonInstance:enable( )  - EFM  buttonInstance:isEnabled()  - EFM  buttonInstance:getText( )  - EFM  buttonInstance:setText( newText )  - EFM  buttonInstance:getTextColor()  - EFM  buttonInstance:setFillColor( color )  - EFM  buttonInstance:adjustLabelOffset( offset )  - EFM  buttonInstance:setHighlight( vis )  - EFM  buttonInstance:setSize( width, height )  - EFM", 
            "title": "buttonInstance - Methods"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#components-of-a-button", 
            "text": "Before we look at  overrideParams  (next in the docs), it would be helpful to understand some basic principles behind how a button is created.  easyIFC.*  button factories build two-state buttons.  That is they are either un-selected (OFF), or selected (ON).    To achieve this,  easyIFC.*  button factories use  minimum  of four display ojects:   Display Group  - This contains all the button parts and is the object that is returned by the factories.  Selected Rectangle or Image    Un-Selected Rectangle or Image    Text Label     As a rule of thumb, you only want to use rectangles or images for the selected and unselected representation, but you may have them all in any combination.  Just be aware that the stacking order will be:   Rectangles    Images  Slices", 
            "title": "Components Of A Button"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#what-are-slices", 
            "text": "Slices are a feature I added recently that allows you to create buttons from a set of sliced up images.  This is similar to what the  widget.*  library does.  Unlike  widget.*  however I use discrete images and not a sprite sheet. This is slightly less efficient, but much easier to create for new developers.", 
            "title": "What Are Slices?"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#the-other-parts", 
            "text": "Strokes  - You may of course set strokes for the two button representations..  Fills  - Each part of the button can have a fill color to shade it.  Note:  I chose not to support the other paint styles because I didn't see much value in them when I could just as easily create the button I needed in Photoshop.    Overlays  - You can have both a rectangle and image overlay if you want.  Each of these lays over the other parts of the button to act like a frame of sorts.", 
            "title": "The Other Parts"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#overrideparams", 
            "text": "General  buttonType  - EFM  anchorX  - EFM  anchorY  - EFM  placeRelative  - EFM    Label Parameters  labelText  - EFM  labelSize  - EFM  labelColor  - EFM  selLabelColor  - EFM  labelFont  - EFM  labelOffset  - EFM  labelHorizAlign  - EFM  emboss  - EFM  labelHorizAlign  - EFM    Rectangle Parameters  unselRectFillColor  - EFM  selRectFillColor  - EFM  cornerRadius  - EFM    Image Parameters  unselImgSrc  - EFM  selImgSrc  - EFM  unselImgFillColor  - EFM  selImgFillColor  - EFM    Slice Parameters  unselSliceSrc  - EFM  selSliceSrc  - EFM  unselSliceFillColor  - EFM  selSliceFillColor  - EFM     Touch Masking Parameters  touchMask  - EFM  touchMaskW ,  touchMaskH  - EFM    Stroke Parameters  unselStrokeColor  - EFM  selStrokeColor  - EFM  strokeWidth  - EFM  strokeColor  - EFM    Overlay Parameters      buttonOverlayRectColor  - EFM  buttonOverlayImgSrc  - EFM  buttonOverlayFillColor  - EFM", 
            "title": "overrideParams"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#components-of-a-slider", 
            "text": "EFM  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM", 
            "title": "Components Of A Slider"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#labels", 
            "text": "SSK also comes with a text object factories library that incorporates the idea of presets.   labels:addLabelPreset( presetName, params )  - Add a label preset definition to the labels preset library.  labels:newLabel( params, screenGroup )  - Generic label builder, used by  labels:presetLabel() .  labels:presetLabel( group, presetName, text, x, y, params  )", 
            "title": "Labels"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#quick-labels", 
            "text": "As great as preset labels are, I often tend to use the following functions instead.  They are simple improvments on the standard  display.newText()  and  display.newEmbossedText()  factories.   labels:quickLabel( group, text, x, y, font, fontSize, textColor, anchorX, anchorY )    labels:quickEmbossedLabel( group, text, x, y, font, fontSize, embossTextColor, embossHighlightColor, embossShadowColor )", 
            "title": "Quick Labels"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#effects", 
            "text": "The button library comes with a set of functions that let you do useful visual calculations and to apply cool visual effects to button (and other display objects if you choose).", 
            "title": "Effects"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#visual-calculations", 
            "text": "isInBounds( obj, obj2 )  - EFM  isInBounds_alt( obj, obj2 )  - EFM  EFM  - EFM", 
            "title": "Visual Calculations"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#fly-ins", 
            "text": "easyFlyIn( obj, params )  - EFM", 
            "title": "Fly Ins"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#squeeze-inflate", 
            "text": "easySqueeze( obj, xScale1, yScale1, xScale2, yScale2, delay, time1, time2, time3, myEasing, myEasing2, myEasing3 )  easyInflate( obj, xScale1, yScale1, xScale2, yScale2, xScale3, yScale3, delay, time1, time2, time3, myEasing, myEasing2, myEasing3 )", 
            "title": "Squeeze &amp; Inflate"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#shrink-grow", 
            "text": "doShrink( obj, to )  doGrow( obj, to )", 
            "title": "Shrink &amp; Grow"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#flipping", 
            "text": "easyFlip( obj, params )", 
            "title": "Flipping"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#pulsing", 
            "text": "pulse( obj, params )", 
            "title": "Pulsing"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#easy-pinch-zoom-drag", 
            "text": "pinchZoomDragTouch( self, event )  - Just use this as the touch listener on an object to get full pinch-zoom-drag functionality.  setMinDragDist( dist )  - Adjust the minimum distance SSK thinks is drag.  Default is 3 pixels.", 
            "title": "Easy Pinch-Zoom-Drag"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#button-callbacks", 
            "text": "EFM EFM EFM\nEFM EFM EFM\nEFM EFM EFM", 
            "title": "Button Callbacks"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#who-needs-another-interface-library", 
            "text": "( Note:  Let me say I am not ripping on  widget.* . It is a fine library that was designed to replicate the common interfaces of iOS and Android.  It splits the game/business usage down the middle. It is perfect as a general library for Corona SDK developers.)  easyIFC.*  was born out of my need to quickly and easily create buttons (push, toggle, and radio) and sliders for games.  I found that while I could use  widget.*  for this it took more coding effort than I was willing to endure.   So... I dug in and wrote my own library ( easyIFC.* ) that supports all the buttons and sliders I needed and has these additional features:   One Line Creation  - Make buttons and sliders with a single call.  Preset Library   - Optionally pre-define the look and feel of common buttons and re-use that information to make new buttons.    Overrides  - Optionally override any preset-parameter while creating a button to account for those  one-off  cases.    Hyper-Flexible Construction  - You can use an arbitrary combination of images, rectangles, frames, etc. to build sexy/great looking buttons.  ... more", 
            "title": "Who needs another interface library?"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#code-comparison-easyifc-versus-using-widget", 
            "text": "", 
            "title": "Code Comparison: easyIFC.* versus using widget.*"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#push-button-with-easyifc", 
            "text": "-- Forward declaration to reduce typing and speed up future calls\nlocal easyIFC = ssk.easyIFC\n\nlocal group = display.newGroup()\n\nlocal function onRelease( event )\n    print( Pressed Button )\nend\n\n-- Create the easyIFC push button\neasyIFC:presetPush( group,  default , 100, 100, 50, 40,  Hello , onRelease, { labelSize = 72 } )", 
            "title": "Push Button with easyIFC.*"
        }, 
        {
            "location": "/libraries/easy_interfaces_labels/#push-button-with-widget", 
            "text": "```lua  local widget = require( \"widget\" )  local group = display.newGroup()  local function onRelease( event )\n    print(\"Pressed Button\")\nend  -- Create the widget push button\nwidget.newButton(\n    {\n        parent       = group,\n        x            = 100,\n        y            = 100,\n        width        = 50,\n        height       = \"40\",\n        defaultFile  = \"fillW.png\",\n        fillColor    = { default={ 0.25, 0.25, 0.25, 1 }, over={ 0.5, 0.5, 0.5, 1 } },\n        label        = \"Hello\",\n        fontSize     = 72,\n        labelColor   = { default={ 1, 1, 1, 1 }, over={ 1, 1, 1, 1 } },\n        onRelease    = onRelease,\n    }\n)     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Push Button with widget.*"
        }, 
        {
            "location": "/libraries/system/", 
            "text": "ssk.system.*\n\n\nEnvironment Flags\n\n\n\n\n\n\n\n\nSyntax\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\nonSimulator\n\n\ntrue\n if running on Corona SDK simulator.\n\n\n\n\n\n\noniOS\n\n\ntrue\n if running on iPhone or iPad.\n\n\n\n\n\n\nonAndroid\n\n\ntrue\n if running on any Android device.\n\n\n\n\n\n\nonAmazon\n\n\ntrue\n if running on Amazon device.\n\n\n\n\n\n\nonNook\n\n\ntrue\n if running on NOOK device.\n\n\n\n\n\n\nonWinPhone\n\n\ntrue\n if running on Windows phone.\n\n\n\n\n\n\nonAppleTV\n\n\ntrue\n if running on Apple TV device.\n\n\n\n\n\n\nonAndroidTV\n\n\ntrue\n if running on Android TV device. \nNot 100% reliable.\n\n\n\n\n\n\nonOSX\n\n\ntrue\n if running on machine using OS X operating system.\n\n\n\n\n\n\nonWin\n\n\ntrue\n if running on machine using Windows (7/8/10/..) operating system.\n\n\n\n\n\n\nonDesktop\n\n\ntrue\n if onSimulator is \nfalse\n \nAND\n onOSX or onWin is \ntrue\n.\n\n\n\n\n\n\nonDevice\n\n\ntrue\n if running on a device( i.e. NOT simulator).\n\n\n\n\n\n\n\n\nDevice Flags\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\noniPhone\n\n\n\n\n\n\n\n\n\n\n\n\noniPhone4\n\n\noniPhone5\n\n\noniPhone5c\n\n\noniPhone5s\n\n\n\n\n\n\noniPhone6\n\n\noniPhone6Plus\n\n\noniPhone6s\n\n\noniPhone6sPlus\n\n\n\n\n\n\noniPad\n\n\noniPadPro\n\n\n\n\n\n\n\n\n\n\nonAndroidTablet\n\n\nNot 100% reliable.\n\n\n\n\n\n\n\n\n\n\nonTablet\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHow To Export ssk.system.*\n\n\nBy default, SSK 2 \nDOES NOT\n export the ssk.system.* variables as globals.  \n\n\nHowever, I find them extremely useful and so you will typically see me exporting them in my examples by setting \nexportSystem\n to \ntrue\n when initializing SSK.\n\n\n_G.ssk.init( { exportSystem = true } )\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.system.*"
        }, 
        {
            "location": "/libraries/system/#ssksystem", 
            "text": "", 
            "title": "ssk.system.*"
        }, 
        {
            "location": "/libraries/system/#environment-flags", 
            "text": "Syntax  Summary      onSimulator  true  if running on Corona SDK simulator.    oniOS  true  if running on iPhone or iPad.    onAndroid  true  if running on any Android device.    onAmazon  true  if running on Amazon device.    onNook  true  if running on NOOK device.    onWinPhone  true  if running on Windows phone.    onAppleTV  true  if running on Apple TV device.    onAndroidTV  true  if running on Android TV device.  Not 100% reliable.    onOSX  true  if running on machine using OS X operating system.    onWin  true  if running on machine using Windows (7/8/10/..) operating system.    onDesktop  true  if onSimulator is  false   AND  onOSX or onWin is  true .    onDevice  true  if running on a device( i.e. NOT simulator).", 
            "title": "Environment Flags"
        }, 
        {
            "location": "/libraries/system/#device-flags", 
            "text": "oniPhone       oniPhone4  oniPhone5  oniPhone5c  oniPhone5s    oniPhone6  oniPhone6Plus  oniPhone6s  oniPhone6sPlus    oniPad  oniPadPro      onAndroidTablet  Not 100% reliable.      onTablet", 
            "title": "Device Flags"
        }, 
        {
            "location": "/libraries/system/#how-to-export-ssksystem", 
            "text": "By default, SSK 2  DOES NOT  export the ssk.system.* variables as globals.    However, I find them extremely useful and so you will typically see me exporting them in my examples by setting  exportSystem  to  true  when initializing SSK.  _G.ssk.init( { exportSystem = true } )     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "How To Export ssk.system.*"
        }, 
        {
            "location": "/libraries/", 
            "text": "SSK2 Quick Reference\n\n\nAn dummy page\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Alphabetic Index"
        }, 
        {
            "location": "/libraries/#ssk2-quick-reference", 
            "text": "An dummy page     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "SSK2 Quick Reference"
        }, 
        {
            "location": "/libraries/actions/", 
            "text": "Actions Library (ssk.actions.*)\n\n\nThe actions library is a collection of helper modules and functions to do the heavy lifting associated with smooth facing, movement, screen-wrapping, and target acquisition.  \n\n\n\n\nThis library is especially suited to action and arcade style game mechanics.\n\n\n\n\n\n\n\n\nFacing\n\n\nNon-Physics Movement\n\n\n\n\n\n\n\n\n\n\n\n\nface\n\n\nmove.at\n\n\nmove.forward\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPhysics Movement\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmovep.dampDown\n\n\nmovep.dampHoriz\n\n\nmovep.dampNormal\n\n\n\n\n\n\nmovep.dampVert\n\n\nmovep.forward\n\n\nmovep.impulseForward\n\n\n\n\n\n\nmovep.limitV\n\n\nmovep.limitAV\n\n\nmovep.thrustForward\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nScene\n\n\n\n\n\n\n\n\n\n\n\n\nscene.circWrap\n  \nscene.rectWrap\n\n\ntarget.acquireRandom\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTarget Acquisition\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntarget.drawDebugAngleDistanceLabel\n\n\ntarget.drawDebugDistanceLabel\n\n\ntarget.drawDebugLine\n\n\n\n\n\n\ntarget.get\n\n\ntarget.loseAtMaxDistance\n\n\ntarget.loseAtMinAlpha\n\n\n\n\n\n\ntarget.loseNotVisible\n\n\ntarget.loseOnDestroyed\n\n\ntarget.set\n\n\n\n\n\n\n\n\nFacing  (face)\n\n\nface\n\n\nCauses \nobj\n to rotate towards a specific angle or target.  The rate of rotation can be immediate or at a specified number of degrees-per-second (\ndps\n).\n\n\nThis function is typically called in an enterFrame listener and once used must be called every frame.  \n\n\nssk.actions.face( obj, params )\n\n\n\n\n\n\nobj\n - The object to be turned.\n\n\nparams\n - A table of key-value pairs controling the facing algorithm.\n\n\ntarget\n - A display object or table with \nx\n and \ny\n fields.\n\n\nangle\n - A desired rotation angle to face towards.\n\n\nrate\n - A number specifying the degrees-per-second to turn \nobj\n by.  \n\n\nIf set to \nnil\n or not specified, facing is immediate.\n\n\n\n\n\n\npause\n - Do not do any facing calculations during this call.  Simply update the turn timer and exit.\n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    -- Rotate to face the object `enemy` at a rate of 180 degrees-per-second\n    ssk.actions.face( self, { target = enemy, rate = 180 } )\n\nend\n\n\n\n\nTip #1:\n While you must continue to call this function every frame after you first call it, you can pause the facing to temorarily suspend calculations.  This is useful if you want \nobj\n to stop turning, of if you no longer have an angle/target to face.\n\n\nTip #2:\n If used in Combination with \nTarget Acquisition\n functions, you don't need to provide a target.  This will be handled for you.\n\n\n\n\nNon-Physics Movement (move.*)\n\n\nThe actions \nmove\n module provides functions to move object using 'calculated' movement in pixels-per-second.  \n\n\nmove.forward\n\n\nMove at a fixed rate, measured in pixels-per-second (\npps\n), in the direction the object is facing.\n\n\nssk.actions.move.forward( obj, params )\n\n\n\n\n\n\nobj\n - The object to be moved.\n\n\nparams\n - A table of key-value pairs controling the movement algorithm.\n\n\nrate\n (\n100\n) - A number specifying the movement speed in pixels-per-second.\n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    -- Move forward at 300 pixels-per-second\n    ssk.actions.move.forward( self, { rate = 300 } )\n\nend\n\n\n\n\nmove.at\n\n\nMove at a fixed rate, measured in pps, in an arbitrary \n x, y \n direction.\n\n\nssk.actions.move.at( obj, params )\n\n\n\n\n\n\nobj\n - The object to be moved.\n\n\nparams\n - A table of key-value pairs controling the movement algorithm.\n\n\nx\n (\n0\n) - A number specifiying the number of pixels-per-second by which to move in the x-axis.\n\n\ny\n (\n0\n) - A number specifiying the number of pixels-per-second by which to move in the y-axis.\n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    -- Move 'right' at 300 pixels-per-second\n    ssk.actions.move.at( self, { x = 300 } )\n\nend\n\n\n\n\n\n\nPhysics Movement  (movep.*)\n\n\nThe actions \nmovep\n module provides functions to move, limit, and dampen movement using 'calculatoins' and physics methods.  \n\n\nAll objects moved with the \nmovep\n module must have physics bodies.\n\n\nmovep.forward\n\n\nMove \nobj\n foward at a fixed rate, measured in pixels-per-second, using frame-by-frame calculations and \nobj:setLinearVelocity()\n.\n\n\nssk.actions.movep.forward( obj, params )\n\n\n\n\n\n\nobj\n - The object to be moved.\n\n\nparams\n - A table of key-value pairs controling the movement algorithm.\n\n\nrate\n (\n100\n) - A number specifying the movement speed in pixels-per-second.\n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    -- Move forward using physics at a rate of 300 pixels-per-second\n    ssk.actions.movep.forward( self, { rate = 300 } )\n\nend\n\n\n\n\nmovep.thrustForward\n\n\nMove \nobj\n forward by applying a force using calculations and \nobj:applyForce()\n.\n\n\nssk.actions.movep.thrustForward( obj, params )\n\n\n\n\n\n\nobj\n - The object to be moved.\n\n\nparams\n - A table of key-value pairs controling the movement algorithm.\n\n\nrate\n (\n100\n) - A number specifying the magnitude of the force to apply to \nobj\n.        \n\n\nignoreMass\n (\nfalse\n) - By default, \nrate\n is automatically multiplied by the object's mass.  Setting this field to \ntrue\n bypasses that part of the calculation.\n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    -- Move this object forward by applying a 100 units of force.\n    ssk.actions.movep.thrustForward( self, { rate = 100 } )\n\nend\n\n\n\n\nmovep.impulseForward\n\n\nMove \nobj\n forward by applying a impulses (kicks) using calculations and \nobj:applyLinearImpulse()\n.  \n\n\nThis is suitable for use in timed or intermittent movements and can produce some very intersting responses.\n\n\nssk.actions.movep.impulseForward( obj, params )\n\n\n\n\n\n\nobj\n - The object to be moved.\n\n\nparams\n - A table of key-value pairs controling the movement algorithm.\n\n\nrate\n (\n100\n) - A number specifying the magnitude of the impulse force to apply to \nobj\n.        \n\n\nignoreMass\n (\nfalse\n) - By default, \nrate\n is automatically multiplied by the object's mass.  Setting this field to \ntrue\n bypasses that part of the calculation.\n\n\n\n\n\n\n\n\nExample:\n\n\n-- Apply 15 impulses (kicks) to player, one every 250 milliseconds\nfunction player.timer( self )\n    ssk.actions.movep.impulseForward( self, { rate = 25 } )\nend\n\ntimer.performWithDelay( 250, player, 15 )\n\n\n\n\nmovep.limitV\n\n\nLimits an object's linear velocity to a maximum rate in pixels-per-second.\n\n\nThis is often used to place a cap on the maximum rate that can be produced using  \nmovep.thrustForward\n.\n\n\nssk.actions.movep.limitV( obj, params )\n\n\n\n\n\n\nobj\n - The object whose rate is to be limited.\n\n\nparams\n - A table of key-value pairs controling the movement algorithm.\n\n\nrate\n (\n100\n) - Maximum rate object may move at in pixels-per-second.    \n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    -- Accelerate this quickly using 500 units of force, but\n    -- limit the maximum velocity to 750 pixels-per-second\n    ssk.actions.movep.thrustForward( self, { rate = 500 } ) \n    ssk.actions.movep.limitV( self, { rate = 750 } )\n\nend\n\n\n\n\nmovep.limitAV\n\n\nLimits an object's angular velocity to a maximum rate in degrees-per-second.\n\n\nThis is great for things like wheels and circles that turn due to frictional contact with other objects.\n\n\nssk.actions.movep.limitAV( obj, params )\n\n\n\n\n\n\nobj\n - The object whose angular rate is to be limited.\n\n\nparams\n - A table of key-value pairs controling the movement algorithm.\n\n\nrate\n (\n100\n) - Maximum angular rate object may turn at in degrees-per-second.   \n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    ssk.actions.face( self, { target = target, rate = 180 } )\n\nend\n\n\n\n\nmovep.dampVert\n\n\nThis allows you to dampen linear velocity for just the vertical component of an object's movement.\n\n\nssk.actions.movep.dampVert( obj, params )\n\n\n\n\n\n\nobj\n - The object whose angular rate is to be limited.\n\n\nparams\n - A table of key-value pairs controling the damping algorithm.\n\n\ndamping\n (\n1\n) - Damping factor for vertical component of movement.\n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    ssk.actions.movep.dampVert( self, { damping = 1.5 } )\n\nend\n\n\n\n\nmovep.dampHoriz\n\n\nThis allows you to dampen linear velocity for just the horizontal component of an object's movement.\n\n\nssk.actions.movep.dampHoriz( obj, params )\n\n\n\n\n\n\nobj\n - The object whose angular rate is to be limited.\n\n\nparams\n - A table of key-value pairs controling the damping algorithm.\n\n\ndamping\n (\n1\n) - Damping factor for horizontal component of movement.\n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    ssk.actions.movep.dampHoriz( self, { damping = 1.5 } )\n\nend\n\n\n\n\nmovep.dampDown\n\n\nThis allows you to dampen linear velocity for just the downward (\n+y\n) component of an object's movement.\n\n\nssk.actions.movep.dampDown( obj, params )\n\n\n\n\n\n\nobj\n - The object whose angular rate is to be limited.\n\n\nparams\n - A table of key-value pairs controling the damping algorithm.\n\n\ndamping\n (\n1\n) - Damping factor for postive vertical component of movement.\n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    ssk.actions.movep.dampDown( self, { damping = 1.5 } )\n\nend\n\n\n\n\nmovep.dampNormal\n\n\nThis is a very specialized kind of damping that dampens motion that is 90-degrees away from forward motion.\n\n\nThe easiest way to think of this is damping like a tire.  Tires slow movement that is at cross angles to the tire's forward vector.\n\n\nNote:\n Not available yet.\n\n\nssk.actions.movep.dampNormal( obj, params )\n\n\n\n\n\n\nobj\n - The object whose angular rate is to be limited.\n\n\nparams\n - A table of key-value pairs controling the damping algorithm.\n\n\ndamping\n (\n1\n) - Damping factor for motion in the directions of either normal from the forward vector.\n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    ssk.actions.movep.dampNormal( self, { damping = 1.5 } )\n\nend\n\n\n\n\n\n\nScene Wrapping (scene.*)\n\n\nSome action games use a single-screen world that wraps.  That is, if a player or enemy leaves one side of the screen, they re-enter from the other side.\n\n\nThe helper functions in this action module help you achieve this.\n\n\nscene.rectWrap\n\n\nThis helper will wrap one object about the bounds of a rectangle (any display object).\n\n\nThis seem strange at first, but by using a display object as the proxy for wrapping calculations, we have an easy way to define the wrapping space and well as an easy way to debug this.\n\n\nssk.actions.scene.rectWrap( objectToWrap, wrapRectangle )\n\n\n\n\n\n\nobjectToWrap\n - The object that should wrap about a 'wrapping space'.\n\n\nwrapRectangle\n - A display object to act as a proxy and define the 'wrapping space'.\n\n\n\n\nExample:\n\n\n-- Create a rectangle to act as our 'wrapping bounds'\nlocal wrapProxy = display.newRect( display.contentCenterX, display.contentCenterY, 300, 300 )\n\n-- Show it a little so we can see where the wrap should happen\nwrapProxy.alpha = 0.1 \n\n-- Place a player in the center of the wrapProxy and give it a random velocity\nlocal player = display.newCirle( wrapProxy.x, wrapProxy.y, 20 )\n\nphysics:addBody( player )\n\nplayer:setLinearVelocity( math.random( -100, 100), math.random( -100, 100) )\n\n-- Start an enter frame listener and test for wrapping each frame\nfunction player.enterFrame( self )\n    ssk.actions.scene.rectWrap( self, wrapProxy )\nend\n\nRuntime:addEventListener( \nenterFrame\n, player )\n\n\n\n\nscene.circWrap\n\n\nThis helper is similar to \nrectWrap\n, but the wrapping is about a circular space and no proxy is required.\n\n\nssk.actions.scene.circWrap( objectToWrap, point, radius )\n\n\n\n\n\n\nobjectToWrap\n - The object that should wrap about a 'wrapping space'.\n\n\npoint\n - \nx,y\n position of the 'wrapping circle'.\n\n\nradius\n - Radius of the 'wrapping circle'.\n\n\n\n\nExample:\n\n\n\nlocal cx = display.contentCenterX\nlocal cy = display.contentCenterY\n\n-- Place a player in the center of the screen and give it a random velocity\nlocal player = display.newCirle( cx, cy, 20 )\n\nphysics:addBody( player )\n\nplayer:setLinearVelocity( math.random( -100, 100), math.random( -100, 100) )\n\n-- Start an enter frame listener and test for wrapping each frame\nfunction player.enterFrame( self )\n    ssk.actions.scene.circWrap( self, { x = cx, y = cy }, 100 )\nend\n\nRuntime:addEventListener( \nenterFrame\n, player )\n\n\n\n\n\n\nTarget Acquisition (target.*)\n\n\nIn action and arcade games, there is often the need for missiles, gun turrets, enemies, etc. to acquire a target and then chase it down.\n\n\nThe functions in this actions module handle the first half of that work (target acquisition), and you can code up the second half using the \nface\n function in combination with \nmove\n or \nmovep\n functions.\n\n\ntarget.set\n\n\nThis function allows you to manually assign a target to an object.\n\n\nssk.actions.target.set( obj, newTarget )\n\n\n\n\n\n\nobj\n - The object that will be seeking or tracking the target.\n\n\nnewTarget\n - The new target for this object, or \nnil\n to clear the target.\n\n\n\n\nExample:\n\n\n-- Have the player start targeting enemy\nssk.actions.target.set( player, enemy )\n\n\n\n\ntarget.get\n\n\nThis function allows you to manually get an object's current target.  \n\n\nReturns nil if the object has no current target.\n\n\nssk.actions.target.get( obj )\n\n\n\n\n\n\nobj\n - The object that may be tracking a target.\n\n\n\n\nExample:\n\n\n-- Get the player's current target\nlocal curTarget = ssk.actions.target.get( player )\n\n\n\n\ntarget.acquireRandom\n\n\nThis chooses a random target from a target pool and assigns it to \nobj\n.  \n\n\nReturns \ntrue\n if a target was assigned, \nfalse\n otherwise.\n\n\nssk.actions.target.acquireRandom( obj, params )\n\n\n\n\n\n\nobj\n - The object to assign a target to.\n\n\nparams\n - A table of key-value pairs controling the targeting algorithm.\n\n\ntargets\n - A table of targets.\n\n\n\n\n\n\n\n\nExample:\n\n\nssk.actions.target.acquireRandom( self, { targets = targets } )\n\n\n\n\ntarget.acquireNearest\n\n\nThis chooses the nearest target from a target pool and assigns it to \nobj\n.  \n\n\nReturns \ntrue\n if a target was assigned, \nfalse\n otherwise.\n\n\nssk.actions.target.acquireRandom( obj, params )\n\n\n\n\n\n\nobj\n - The object to assign a target to.\n\n\nparams\n - A table of key-value pairs controling the targeting algorithm.\n\n\nmaxDist\n (\nmath.huge\n) - The maximum distance at which a target is considered valid.\n\n\ntargets\n - A table of targets.\n\n\n\n\n\n\n\n\nExample:\n\n\nssk.actions.target.acquireRandom( self, { targets = targets } )\n\n\n\n\ntarget.loseOnDestroyed\n\n\nTell \nobj\n to wipe its current target if that target has been destroyed and is no longer a valid display object.\n\n\nReturns \ntrue\n if \nobj\n no longer has a valid target.\n\n\nssk.actions.target.loseOnDestroyed( obj )\n\n\n\n\n\n\nobj\n - The object whose target we want to check.\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    -- Acquire a new random target if our last one was destroyed, or\n    -- if we don't have one yet.\n    if( ssk.actions.target.loseOnDestroyed( self ) ) then\n        ssk.actions.target.acquireRandom( self, { targets = targets } )\n    end\nend\n\n\n\n\ntarget.loseAtMaxDistance\n\n\nTell \nobj\n to wipe its current target if that target has moved beyond \nmaxDist\n.\n\n\nReturns \ntrue\n if \nobj\n no longer has a valid target.\n\n\nssk.actions.target.loseAtMaxDistance( obj )\n\n\n\n\n\n\nobj\n - The object whose target we want to check.\n\n\nparams\n - A table of key-value pairs controling the targeting algorithm.\n\n\nmaxDist\n (\nmath.huge\n) - The maximum distance at which a target is considered valid.\n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    -- Acquire a new random target if our last one was destroyed, or\n    -- if we don't have one yet.\n    if( ssk.actions.target.loseAtMaxDistance( self, { maxDist = 200 } ) ) then\n        ssk.actions.target.acquireRandom( self, { targets = targets } )\n    end\nend\n\n\n\n\ntarget.loseAtMinAlpha\n\n\nTell \nobj\n to wipe its current target if that target's alpha is below \nalpha\n.\n\n\nReturns \ntrue\n if \nobj\n no longer has a valid target.\n\n\nssk.actions.target.loseAtMinAlpha( obj )\n\n\n\n\n\n\nobj\n - The object whose target we want to check.\n\n\nparams\n - A table of key-value pairs controling the targeting algorithm.\n\n\nalpha\n (\n0.5\n) - The maximum alpha at which a target is considered valid.\n\n\n\n\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    -- Acquire a new random target if our last one was destroyed, or\n    -- if we don't have one yet.\n    if( ssk.actions.target.loseAtMinAlpha( self, { alpha = 0.1 } ) ) then\n        ssk.actions.target.acquireRandom( self, { targets = targets } )\n    end\nend\n\n\n\n\ntarget.loseNotVisible\n\n\nTell \nobj\n to wipe its current target if that target is not visible.\n\n\nReturns \ntrue\n if \nobj\n no longer has a valid target.\n\n\nssk.actions.target.loseNotVisible( obj )\n\n\n\n\n\n\nobj\n - The object whose target we want to check.\n\n\n\n\nExample:\n\n\nfunction player.enterFrame( self )\n\n    -- Acquire a new random target if our last one was destroyed, or\n    -- if we don't have one yet.\n    if( ssk.actions.target.loseNotVisible( self ) ) then\n        ssk.actions.target.acquireRandom( self, { targets = targets } )\n    end\nend\n\n\n\n\ntarget.drawDebugLine\n\n\nThis is a debug feature that draws a line between \nobj\n and its target.\n\n\nssk.actions.target.drawDebugLine( obj, params )\n\n\n\n\n\n\nobj\n - The object that acts as the anchor for the line.\n\n\nparams\n - A table of key-value pairs controling the targeting algorithm.\n\n\nparent\n - By default, the line is added to \ndisplay.currentStage\n group, but you can specify a another group with this argument.\n\n\n\n\n\n\n\n\nExample:\n\n\nssk.actions.target.drawDebugLine( self )\n\n\n\n\ntarget.drawDebugDistanceLabel\n\n\nThis is a debug feature that draws a label showing the distance from \nobj\n to its target in pixels.\n\n\nssk.actions.target.drawDebugDistanceLabel( obj, params )\n\n\n\n\n\n\nobj\n - The object that acts as the anchor for the line.\n\n\nparams\n - A table of key-value pairs controling the targeting algorithm.\n\n\nparent\n - By default, the line is added to \ndisplay.currentStage\n group, but you can specify a another group with this argument.\n\n\nxOffset\n (\n0\n) - The label's x-position is \nobj.x + xOffset\n.\n\n\nyOffset\n (\n0\n) - The label's y-position is \nobj.y + yOffset\n.\n\n\n\n\n\n\n\n\nExample:\n\n\nssk.actions.target.drawDebugDistanceLabel( self, { yOffset = 40 } )\n\n\n\n\ntarget.drawDebugAngleDistanceLabel\n\n\nThis is a debug feature that draws a label showing the distance from \nobj\n to its target in pixels, as well as the angle between \nobj\n forward and the target.\n\n\nssk.actions.target.drawDebugAngleDistanceLabel( obj, params )\n\n\n\n\n\n\nobj\n - The object that acts as the anchor for the line.\n\n\nparams\n - A table of key-value pairs controling the targeting algorithm.\n\n\nparent\n - By default, the line is added to \ndisplay.currentStage\n group, but you can specify a another group with this argument.\n\n\nxOffset\n (\n0\n) - The label's x-position is \nobj.x + xOffset\n.\n\n\nyOffset\n (\n0\n) - The label's y-position is \nobj.y + yOffset\n.\n\n\n\n\n\n\n\n\nExample:\n\n\nssk.actions.target.drawDebugAngleDistanceLabel( self, { yOffset = 40 } )\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.actions.*"
        }, 
        {
            "location": "/libraries/actions/#actions-library-sskactions", 
            "text": "The actions library is a collection of helper modules and functions to do the heavy lifting associated with smooth facing, movement, screen-wrapping, and target acquisition.     This library is especially suited to action and arcade style game mechanics.     Facing  Non-Physics Movement       face  move.at  move.forward        Physics Movement        movep.dampDown  movep.dampHoriz  movep.dampNormal    movep.dampVert  movep.forward  movep.impulseForward    movep.limitV  movep.limitAV  movep.thrustForward        Scene       scene.circWrap    scene.rectWrap  target.acquireRandom        Target Acquisition        target.drawDebugAngleDistanceLabel  target.drawDebugDistanceLabel  target.drawDebugLine    target.get  target.loseAtMaxDistance  target.loseAtMinAlpha    target.loseNotVisible  target.loseOnDestroyed  target.set", 
            "title": "Actions Library (ssk.actions.*)"
        }, 
        {
            "location": "/libraries/actions/#facing-face", 
            "text": "", 
            "title": "Facing  (face)"
        }, 
        {
            "location": "/libraries/actions/#face", 
            "text": "Causes  obj  to rotate towards a specific angle or target.  The rate of rotation can be immediate or at a specified number of degrees-per-second ( dps ).  This function is typically called in an enterFrame listener and once used must be called every frame.    ssk.actions.face( obj, params )   obj  - The object to be turned.  params  - A table of key-value pairs controling the facing algorithm.  target  - A display object or table with  x  and  y  fields.  angle  - A desired rotation angle to face towards.  rate  - A number specifying the degrees-per-second to turn  obj  by.    If set to  nil  or not specified, facing is immediate.    pause  - Do not do any facing calculations during this call.  Simply update the turn timer and exit.     Example:  function player.enterFrame( self )\n\n    -- Rotate to face the object `enemy` at a rate of 180 degrees-per-second\n    ssk.actions.face( self, { target = enemy, rate = 180 } )\n\nend  Tip #1:  While you must continue to call this function every frame after you first call it, you can pause the facing to temorarily suspend calculations.  This is useful if you want  obj  to stop turning, of if you no longer have an angle/target to face.  Tip #2:  If used in Combination with  Target Acquisition  functions, you don't need to provide a target.  This will be handled for you.", 
            "title": "face"
        }, 
        {
            "location": "/libraries/actions/#non-physics-movement-move", 
            "text": "The actions  move  module provides functions to move object using 'calculated' movement in pixels-per-second.", 
            "title": "Non-Physics Movement (move.*)"
        }, 
        {
            "location": "/libraries/actions/#moveforward", 
            "text": "Move at a fixed rate, measured in pixels-per-second ( pps ), in the direction the object is facing.  ssk.actions.move.forward( obj, params )   obj  - The object to be moved.  params  - A table of key-value pairs controling the movement algorithm.  rate  ( 100 ) - A number specifying the movement speed in pixels-per-second.     Example:  function player.enterFrame( self )\n\n    -- Move forward at 300 pixels-per-second\n    ssk.actions.move.forward( self, { rate = 300 } )\n\nend", 
            "title": "move.forward"
        }, 
        {
            "location": "/libraries/actions/#moveat", 
            "text": "Move at a fixed rate, measured in pps, in an arbitrary   x, y   direction.  ssk.actions.move.at( obj, params )   obj  - The object to be moved.  params  - A table of key-value pairs controling the movement algorithm.  x  ( 0 ) - A number specifiying the number of pixels-per-second by which to move in the x-axis.  y  ( 0 ) - A number specifiying the number of pixels-per-second by which to move in the y-axis.     Example:  function player.enterFrame( self )\n\n    -- Move 'right' at 300 pixels-per-second\n    ssk.actions.move.at( self, { x = 300 } )\n\nend", 
            "title": "move.at"
        }, 
        {
            "location": "/libraries/actions/#physics-movement-movep", 
            "text": "The actions  movep  module provides functions to move, limit, and dampen movement using 'calculatoins' and physics methods.    All objects moved with the  movep  module must have physics bodies.", 
            "title": "Physics Movement  (movep.*)"
        }, 
        {
            "location": "/libraries/actions/#movepforward", 
            "text": "Move  obj  foward at a fixed rate, measured in pixels-per-second, using frame-by-frame calculations and  obj:setLinearVelocity() .  ssk.actions.movep.forward( obj, params )   obj  - The object to be moved.  params  - A table of key-value pairs controling the movement algorithm.  rate  ( 100 ) - A number specifying the movement speed in pixels-per-second.     Example:  function player.enterFrame( self )\n\n    -- Move forward using physics at a rate of 300 pixels-per-second\n    ssk.actions.movep.forward( self, { rate = 300 } )\n\nend", 
            "title": "movep.forward"
        }, 
        {
            "location": "/libraries/actions/#movepthrustforward", 
            "text": "Move  obj  forward by applying a force using calculations and  obj:applyForce() .  ssk.actions.movep.thrustForward( obj, params )   obj  - The object to be moved.  params  - A table of key-value pairs controling the movement algorithm.  rate  ( 100 ) - A number specifying the magnitude of the force to apply to  obj .          ignoreMass  ( false ) - By default,  rate  is automatically multiplied by the object's mass.  Setting this field to  true  bypasses that part of the calculation.     Example:  function player.enterFrame( self )\n\n    -- Move this object forward by applying a 100 units of force.\n    ssk.actions.movep.thrustForward( self, { rate = 100 } )\n\nend", 
            "title": "movep.thrustForward"
        }, 
        {
            "location": "/libraries/actions/#movepimpulseforward", 
            "text": "Move  obj  forward by applying a impulses (kicks) using calculations and  obj:applyLinearImpulse() .    This is suitable for use in timed or intermittent movements and can produce some very intersting responses.  ssk.actions.movep.impulseForward( obj, params )   obj  - The object to be moved.  params  - A table of key-value pairs controling the movement algorithm.  rate  ( 100 ) - A number specifying the magnitude of the impulse force to apply to  obj .          ignoreMass  ( false ) - By default,  rate  is automatically multiplied by the object's mass.  Setting this field to  true  bypasses that part of the calculation.     Example:  -- Apply 15 impulses (kicks) to player, one every 250 milliseconds\nfunction player.timer( self )\n    ssk.actions.movep.impulseForward( self, { rate = 25 } )\nend\n\ntimer.performWithDelay( 250, player, 15 )", 
            "title": "movep.impulseForward"
        }, 
        {
            "location": "/libraries/actions/#moveplimitv", 
            "text": "Limits an object's linear velocity to a maximum rate in pixels-per-second.  This is often used to place a cap on the maximum rate that can be produced using   movep.thrustForward .  ssk.actions.movep.limitV( obj, params )   obj  - The object whose rate is to be limited.  params  - A table of key-value pairs controling the movement algorithm.  rate  ( 100 ) - Maximum rate object may move at in pixels-per-second.         Example:  function player.enterFrame( self )\n\n    -- Accelerate this quickly using 500 units of force, but\n    -- limit the maximum velocity to 750 pixels-per-second\n    ssk.actions.movep.thrustForward( self, { rate = 500 } ) \n    ssk.actions.movep.limitV( self, { rate = 750 } )\n\nend", 
            "title": "movep.limitV"
        }, 
        {
            "location": "/libraries/actions/#moveplimitav", 
            "text": "Limits an object's angular velocity to a maximum rate in degrees-per-second.  This is great for things like wheels and circles that turn due to frictional contact with other objects.  ssk.actions.movep.limitAV( obj, params )   obj  - The object whose angular rate is to be limited.  params  - A table of key-value pairs controling the movement algorithm.  rate  ( 100 ) - Maximum angular rate object may turn at in degrees-per-second.        Example:  function player.enterFrame( self )\n\n    ssk.actions.face( self, { target = target, rate = 180 } )\n\nend", 
            "title": "movep.limitAV"
        }, 
        {
            "location": "/libraries/actions/#movepdampvert", 
            "text": "This allows you to dampen linear velocity for just the vertical component of an object's movement.  ssk.actions.movep.dampVert( obj, params )   obj  - The object whose angular rate is to be limited.  params  - A table of key-value pairs controling the damping algorithm.  damping  ( 1 ) - Damping factor for vertical component of movement.     Example:  function player.enterFrame( self )\n\n    ssk.actions.movep.dampVert( self, { damping = 1.5 } )\n\nend", 
            "title": "movep.dampVert"
        }, 
        {
            "location": "/libraries/actions/#movepdamphoriz", 
            "text": "This allows you to dampen linear velocity for just the horizontal component of an object's movement.  ssk.actions.movep.dampHoriz( obj, params )   obj  - The object whose angular rate is to be limited.  params  - A table of key-value pairs controling the damping algorithm.  damping  ( 1 ) - Damping factor for horizontal component of movement.     Example:  function player.enterFrame( self )\n\n    ssk.actions.movep.dampHoriz( self, { damping = 1.5 } )\n\nend", 
            "title": "movep.dampHoriz"
        }, 
        {
            "location": "/libraries/actions/#movepdampdown", 
            "text": "This allows you to dampen linear velocity for just the downward ( +y ) component of an object's movement.  ssk.actions.movep.dampDown( obj, params )   obj  - The object whose angular rate is to be limited.  params  - A table of key-value pairs controling the damping algorithm.  damping  ( 1 ) - Damping factor for postive vertical component of movement.     Example:  function player.enterFrame( self )\n\n    ssk.actions.movep.dampDown( self, { damping = 1.5 } )\n\nend", 
            "title": "movep.dampDown"
        }, 
        {
            "location": "/libraries/actions/#movepdampnormal", 
            "text": "This is a very specialized kind of damping that dampens motion that is 90-degrees away from forward motion.  The easiest way to think of this is damping like a tire.  Tires slow movement that is at cross angles to the tire's forward vector.  Note:  Not available yet.  ssk.actions.movep.dampNormal( obj, params )   obj  - The object whose angular rate is to be limited.  params  - A table of key-value pairs controling the damping algorithm.  damping  ( 1 ) - Damping factor for motion in the directions of either normal from the forward vector.     Example:  function player.enterFrame( self )\n\n    ssk.actions.movep.dampNormal( self, { damping = 1.5 } )\n\nend", 
            "title": "movep.dampNormal"
        }, 
        {
            "location": "/libraries/actions/#scene-wrapping-scene", 
            "text": "Some action games use a single-screen world that wraps.  That is, if a player or enemy leaves one side of the screen, they re-enter from the other side.  The helper functions in this action module help you achieve this.", 
            "title": "Scene Wrapping (scene.*)"
        }, 
        {
            "location": "/libraries/actions/#scenerectwrap", 
            "text": "This helper will wrap one object about the bounds of a rectangle (any display object).  This seem strange at first, but by using a display object as the proxy for wrapping calculations, we have an easy way to define the wrapping space and well as an easy way to debug this.  ssk.actions.scene.rectWrap( objectToWrap, wrapRectangle )   objectToWrap  - The object that should wrap about a 'wrapping space'.  wrapRectangle  - A display object to act as a proxy and define the 'wrapping space'.   Example:  -- Create a rectangle to act as our 'wrapping bounds'\nlocal wrapProxy = display.newRect( display.contentCenterX, display.contentCenterY, 300, 300 )\n\n-- Show it a little so we can see where the wrap should happen\nwrapProxy.alpha = 0.1 \n\n-- Place a player in the center of the wrapProxy and give it a random velocity\nlocal player = display.newCirle( wrapProxy.x, wrapProxy.y, 20 )\n\nphysics:addBody( player )\n\nplayer:setLinearVelocity( math.random( -100, 100), math.random( -100, 100) )\n\n-- Start an enter frame listener and test for wrapping each frame\nfunction player.enterFrame( self )\n    ssk.actions.scene.rectWrap( self, wrapProxy )\nend\n\nRuntime:addEventListener(  enterFrame , player )", 
            "title": "scene.rectWrap"
        }, 
        {
            "location": "/libraries/actions/#scenecircwrap", 
            "text": "This helper is similar to  rectWrap , but the wrapping is about a circular space and no proxy is required.  ssk.actions.scene.circWrap( objectToWrap, point, radius )   objectToWrap  - The object that should wrap about a 'wrapping space'.  point  -  x,y  position of the 'wrapping circle'.  radius  - Radius of the 'wrapping circle'.   Example:  \nlocal cx = display.contentCenterX\nlocal cy = display.contentCenterY\n\n-- Place a player in the center of the screen and give it a random velocity\nlocal player = display.newCirle( cx, cy, 20 )\n\nphysics:addBody( player )\n\nplayer:setLinearVelocity( math.random( -100, 100), math.random( -100, 100) )\n\n-- Start an enter frame listener and test for wrapping each frame\nfunction player.enterFrame( self )\n    ssk.actions.scene.circWrap( self, { x = cx, y = cy }, 100 )\nend\n\nRuntime:addEventListener(  enterFrame , player )", 
            "title": "scene.circWrap"
        }, 
        {
            "location": "/libraries/actions/#target-acquisition-target", 
            "text": "In action and arcade games, there is often the need for missiles, gun turrets, enemies, etc. to acquire a target and then chase it down.  The functions in this actions module handle the first half of that work (target acquisition), and you can code up the second half using the  face  function in combination with  move  or  movep  functions.", 
            "title": "Target Acquisition (target.*)"
        }, 
        {
            "location": "/libraries/actions/#targetset", 
            "text": "This function allows you to manually assign a target to an object.  ssk.actions.target.set( obj, newTarget )   obj  - The object that will be seeking or tracking the target.  newTarget  - The new target for this object, or  nil  to clear the target.   Example:  -- Have the player start targeting enemy\nssk.actions.target.set( player, enemy )", 
            "title": "target.set"
        }, 
        {
            "location": "/libraries/actions/#targetget", 
            "text": "This function allows you to manually get an object's current target.    Returns nil if the object has no current target.  ssk.actions.target.get( obj )   obj  - The object that may be tracking a target.   Example:  -- Get the player's current target\nlocal curTarget = ssk.actions.target.get( player )", 
            "title": "target.get"
        }, 
        {
            "location": "/libraries/actions/#targetacquirerandom", 
            "text": "This chooses a random target from a target pool and assigns it to  obj .    Returns  true  if a target was assigned,  false  otherwise.  ssk.actions.target.acquireRandom( obj, params )   obj  - The object to assign a target to.  params  - A table of key-value pairs controling the targeting algorithm.  targets  - A table of targets.     Example:  ssk.actions.target.acquireRandom( self, { targets = targets } )", 
            "title": "target.acquireRandom"
        }, 
        {
            "location": "/libraries/actions/#targetacquirenearest", 
            "text": "This chooses the nearest target from a target pool and assigns it to  obj .    Returns  true  if a target was assigned,  false  otherwise.  ssk.actions.target.acquireRandom( obj, params )   obj  - The object to assign a target to.  params  - A table of key-value pairs controling the targeting algorithm.  maxDist  ( math.huge ) - The maximum distance at which a target is considered valid.  targets  - A table of targets.     Example:  ssk.actions.target.acquireRandom( self, { targets = targets } )", 
            "title": "target.acquireNearest"
        }, 
        {
            "location": "/libraries/actions/#targetloseondestroyed", 
            "text": "Tell  obj  to wipe its current target if that target has been destroyed and is no longer a valid display object.  Returns  true  if  obj  no longer has a valid target.  ssk.actions.target.loseOnDestroyed( obj )   obj  - The object whose target we want to check.   Example:  function player.enterFrame( self )\n\n    -- Acquire a new random target if our last one was destroyed, or\n    -- if we don't have one yet.\n    if( ssk.actions.target.loseOnDestroyed( self ) ) then\n        ssk.actions.target.acquireRandom( self, { targets = targets } )\n    end\nend", 
            "title": "target.loseOnDestroyed"
        }, 
        {
            "location": "/libraries/actions/#targetloseatmaxdistance", 
            "text": "Tell  obj  to wipe its current target if that target has moved beyond  maxDist .  Returns  true  if  obj  no longer has a valid target.  ssk.actions.target.loseAtMaxDistance( obj )   obj  - The object whose target we want to check.  params  - A table of key-value pairs controling the targeting algorithm.  maxDist  ( math.huge ) - The maximum distance at which a target is considered valid.     Example:  function player.enterFrame( self )\n\n    -- Acquire a new random target if our last one was destroyed, or\n    -- if we don't have one yet.\n    if( ssk.actions.target.loseAtMaxDistance( self, { maxDist = 200 } ) ) then\n        ssk.actions.target.acquireRandom( self, { targets = targets } )\n    end\nend", 
            "title": "target.loseAtMaxDistance"
        }, 
        {
            "location": "/libraries/actions/#targetloseatminalpha", 
            "text": "Tell  obj  to wipe its current target if that target's alpha is below  alpha .  Returns  true  if  obj  no longer has a valid target.  ssk.actions.target.loseAtMinAlpha( obj )   obj  - The object whose target we want to check.  params  - A table of key-value pairs controling the targeting algorithm.  alpha  ( 0.5 ) - The maximum alpha at which a target is considered valid.     Example:  function player.enterFrame( self )\n\n    -- Acquire a new random target if our last one was destroyed, or\n    -- if we don't have one yet.\n    if( ssk.actions.target.loseAtMinAlpha( self, { alpha = 0.1 } ) ) then\n        ssk.actions.target.acquireRandom( self, { targets = targets } )\n    end\nend", 
            "title": "target.loseAtMinAlpha"
        }, 
        {
            "location": "/libraries/actions/#targetlosenotvisible", 
            "text": "Tell  obj  to wipe its current target if that target is not visible.  Returns  true  if  obj  no longer has a valid target.  ssk.actions.target.loseNotVisible( obj )   obj  - The object whose target we want to check.   Example:  function player.enterFrame( self )\n\n    -- Acquire a new random target if our last one was destroyed, or\n    -- if we don't have one yet.\n    if( ssk.actions.target.loseNotVisible( self ) ) then\n        ssk.actions.target.acquireRandom( self, { targets = targets } )\n    end\nend", 
            "title": "target.loseNotVisible"
        }, 
        {
            "location": "/libraries/actions/#targetdrawdebugline", 
            "text": "This is a debug feature that draws a line between  obj  and its target.  ssk.actions.target.drawDebugLine( obj, params )   obj  - The object that acts as the anchor for the line.  params  - A table of key-value pairs controling the targeting algorithm.  parent  - By default, the line is added to  display.currentStage  group, but you can specify a another group with this argument.     Example:  ssk.actions.target.drawDebugLine( self )", 
            "title": "target.drawDebugLine"
        }, 
        {
            "location": "/libraries/actions/#targetdrawdebugdistancelabel", 
            "text": "This is a debug feature that draws a label showing the distance from  obj  to its target in pixels.  ssk.actions.target.drawDebugDistanceLabel( obj, params )   obj  - The object that acts as the anchor for the line.  params  - A table of key-value pairs controling the targeting algorithm.  parent  - By default, the line is added to  display.currentStage  group, but you can specify a another group with this argument.  xOffset  ( 0 ) - The label's x-position is  obj.x + xOffset .  yOffset  ( 0 ) - The label's y-position is  obj.y + yOffset .     Example:  ssk.actions.target.drawDebugDistanceLabel( self, { yOffset = 40 } )", 
            "title": "target.drawDebugDistanceLabel"
        }, 
        {
            "location": "/libraries/actions/#targetdrawdebugangledistancelabel", 
            "text": "This is a debug feature that draws a label showing the distance from  obj  to its target in pixels, as well as the angle between  obj  forward and the target.  ssk.actions.target.drawDebugAngleDistanceLabel( obj, params )   obj  - The object that acts as the anchor for the line.  params  - A table of key-value pairs controling the targeting algorithm.  parent  - By default, the line is added to  display.currentStage  group, but you can specify a another group with this argument.  xOffset  ( 0 ) - The label's x-position is  obj.x + xOffset .  yOffset  ( 0 ) - The label's y-position is  obj.y + yOffset .     Example:  ssk.actions.target.drawDebugAngleDistanceLabel( self, { yOffset = 40 } )     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "target.drawDebugAngleDistanceLabel"
        }, 
        {
            "location": "/libraries/android/", 
            "text": "ssk.android.*\n\n\nThis library contains a few helper functions to handle common Android issues/tasks.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncaptureBackButton\n\n\ncaptureVolumeButtons\n\n\neasyAndroidUIVisibility\n\n\n\n\n\n\n\n\ncaptureBackButton\n\n\nCapture the back button on Android devices and prompt the user to be sure they really want to leave the app.\n\n\nWhen user presses back button they are prompted with a pop-up dialog:\n\n\n\n\nssk.android.captureBackButton( [ noCB, [ yesCB ] ] )\n\n\n\n\n\n\nnoCB\n - Optional function to execute if the user selects \"NO\".\n\n\nyesCB\n - Optional function to execute if the user selects \"YES\".\n\n\n\n\n\nlocal onNo()\n   print(\nPressed No\n)   \nend\n\nlocal onYes()\n   print(\nPressed Yes\n)\nend\n\nssk.android.captureBackButton( onNo, onYes )\n\n\n\n\n\ncaptureVolumeButtons\n\n\nCapture the volume buttons on Android and do something when they are pressed.\n\n\nssk.android.captureVolumeButtons( [ block, [ volUp, [ volDown ] ] ] )\n\n\n\n\n\n\nblock\n ( \ntrue\n ) - If \ntrue\n block the volume change action.\n\n\nvolUp\n - Optional function to execute if the user selects \"volUp\".\n\n\nvolDown\n - Optional function to execute if the user selects \"volDown\".\n\n\n\n\n\nlocal upUp()\n   print(\nUse tried to increase volume\n)   \nend\n\nlocal onDown()\n   print(\nUse tried to decrease volume\n)   \nend\n\nssk.android.captureBackButton( true, onUp, onDown )\n\n\n\n\n\neasyAndroidUIVisibility\n\n\nEasily hide Android virtual buttons (back, home, ... ).\n\n\nssk.android.easyAndroidUIVisibility( [ profile ] ] )\n\n\n\n\n\n\nprofile\n ( \n\"immersiveSticky\"\n ) - Style of visibility selection:\n\n\n\"immersiveSticky\"\n - Cause the status and navigation bars to disappear. \n\n\nIf the user swipes from the top or bottom, they \nwill reappear and then disappear again.\n\n\nOnly on Android KitKat (Api 19) or above.\n\n\n\n\n\n\n\"immersive\"\n -  Cause the status and navigation bars to disappear. \n\n\nIf the user swipes from the top or bottom, they will reappear and stay.\n\n\nWARNING:\n A resize event will be triggered and the objects on the screen will need to be manually re-rendered. This is because the content scaling for the device changes and the objects will not have the correct aspect ratio unless they are re-rendered (removed and restored).\n\n\n\n\n\n\nOnly on Android KitKat (Api 19) or above. \n\n\n\n\n\n\n\"lowProfile\"\n - Dims the navigation bar icons.\n\n\nOnly on Android Ice Cream Sandwich (Api 14) or above.\n\n\n\n\n\n\n\"default\"\n - Resets the value.\n\n\n\n\n\n\n\n\n\n-- Automatically use 'immersiveSticky' if available.\nssk.android.easyAndroidUIVisibility( nil )\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.android.*"
        }, 
        {
            "location": "/libraries/android/#sskandroid", 
            "text": "This library contains a few helper functions to handle common Android issues/tasks.            captureBackButton  captureVolumeButtons  easyAndroidUIVisibility", 
            "title": "ssk.android.*"
        }, 
        {
            "location": "/libraries/android/#capturebackbutton", 
            "text": "Capture the back button on Android devices and prompt the user to be sure they really want to leave the app.  When user presses back button they are prompted with a pop-up dialog:   ssk.android.captureBackButton( [ noCB, [ yesCB ] ] )   noCB  - Optional function to execute if the user selects \"NO\".  yesCB  - Optional function to execute if the user selects \"YES\".   \nlocal onNo()\n   print( Pressed No )   \nend\n\nlocal onYes()\n   print( Pressed Yes )\nend\n\nssk.android.captureBackButton( onNo, onYes )", 
            "title": "captureBackButton"
        }, 
        {
            "location": "/libraries/android/#capturevolumebuttons", 
            "text": "Capture the volume buttons on Android and do something when they are pressed.  ssk.android.captureVolumeButtons( [ block, [ volUp, [ volDown ] ] ] )   block  (  true  ) - If  true  block the volume change action.  volUp  - Optional function to execute if the user selects \"volUp\".  volDown  - Optional function to execute if the user selects \"volDown\".   \nlocal upUp()\n   print( Use tried to increase volume )   \nend\n\nlocal onDown()\n   print( Use tried to decrease volume )   \nend\n\nssk.android.captureBackButton( true, onUp, onDown )", 
            "title": "captureVolumeButtons"
        }, 
        {
            "location": "/libraries/android/#easyandroiduivisibility", 
            "text": "Easily hide Android virtual buttons (back, home, ... ).  ssk.android.easyAndroidUIVisibility( [ profile ] ] )   profile  (  \"immersiveSticky\"  ) - Style of visibility selection:  \"immersiveSticky\"  - Cause the status and navigation bars to disappear.   If the user swipes from the top or bottom, they \nwill reappear and then disappear again.  Only on Android KitKat (Api 19) or above.    \"immersive\"  -  Cause the status and navigation bars to disappear.   If the user swipes from the top or bottom, they will reappear and stay.  WARNING:  A resize event will be triggered and the objects on the screen will need to be manually re-rendered. This is because the content scaling for the device changes and the objects will not have the correct aspect ratio unless they are re-rendered (removed and restored).    Only on Android KitKat (Api 19) or above.     \"lowProfile\"  - Dims the navigation bar icons.  Only on Android Ice Cream Sandwich (Api 14) or above.    \"default\"  - Resets the value.     \n-- Automatically use 'immersiveSticky' if available.\nssk.android.easyAndroidUIVisibility( nil )     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "easyAndroidUIVisibility"
        }, 
        {
            "location": "/libraries/camera/", 
            "text": "Camera Library (ssk.camera.*)\n\n\nA number of basic cameras you can use out-of-the-box, or that you can copy and modify to meet your specific game requirements/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndelayedTracking\n\n\ntracking\n\n\n\n\n\n\ntrackingLooseCircle\n\n\ntrackingLooseRectangle\n\n\n\n\n\n\n\n\ntracking\n\n\nA camera that tracks the position of the \ntrackObj\n exactly, keeping it in the exact position it started in or has specified to be at.\n\n\nThis camera supports the ability to track in only one axis and/or to adjust the tracking offset. \n\n\nssk.camera.tracking( trackObj, world [ , params ]  )\n\n\n\n\n\n\ntrackObj\n - The object to track with the camera.\n\n\nworld\n - The group that contains all other groups and objects including \ntrackObj\n.\n\n\nparams\n - An optional table of named settings:\n\n\ncentered\n (\nfalse\n) - If \ntrue\n, forces camera tracking to center of screen.\n\n\nlockX\n (\nfalse\n) - If \ntrue\n, tracking ignores x-movement.\n\n\nlockY\n (\nfalse\n) - If \ntrue\n, tracking ignores y-movement.\n\n\nlx\n - If specified, this is the x-position to track at.  \n\n\nDefaults to starting x-position of \ntrackObj\n.\n\n\n\n\n\n\nly\n - If specified, this is the y-position to track at.\n\n\nDefaults to starting y-position of \ntrackObj\n.    \n\n\n\n\n\n\n\n\n\n\n\n\n\n-- Create some basic layers.\n--\nlocal layers = quickLayers( group, \n      \nunderlay\n,\n      \nworld\n,\n         { \ncircles\n, \nplayer\n },\n      \noverlay\n )\n\nlocal player = newImageRect( layers.player, centerX, centerY, \nimages/smiley.png\n )\n\nssk.camera.tracking( player, layers.world )\n\n\n\n\n\ndelayedTracking\n\n\nAn \nexperimental\n camera that waits a moment then moves to the new position of the \ntrackObj\n.\n\n\nNote:\n I don't use this one.  It is meant to be a starting place for delayed cameras.  If you need such a camera, examine this code and then write your own camera function.\n\n\nssk.camera.delayedTracking(  )\n\n\n\n\n\n\ntrackObj\n - The object to track with the camera.\n\n\nworld\n - The group that contains all other groups and objects including \ntrackObj\n.\n\n\nparams\n - An optional table of named settings:\n\n\ncentered\n (\nfalse\n) - If \ntrue\n, forces camera tracking to center of screen.\n\n\nlockX\n (\nfalse\n) - If \ntrue\n, tracking ignores x-movement.\n\n\nlockY\n (\nfalse\n) - If \ntrue\n, tracking ignores y-movement.\n\n\nlx\n - If specified, this is the x-position to track at.  \n\n\nDefaults to starting x-position of \ntrackObj\n.\n\n\n\n\n\n\nly\n - If specified, this is the y-position to track at.\n\n\nDefaults to starting y-position of \ntrackObj\n.\n\n\n\n\n\n\n\n\n\n\n\n\ntrackingLooseCircle\n\n\n\n\nA camera that tracks the \ntrackObj\n continuously, but only moves the \nworld\n once the  \ntrackObj\n moves beyond the radius of a dead zone.  After that, \nworld\n movement accelerates gradually to match that of \ntrackObj\n.  \n\n\nIncludes a debug feature to allow you to see the limits of the dead zone.\n\n\nssk.camera.trackingLooseCircle( trackObj, world [ , params ]  )\n\n\n\n\n\n\ntrackObj\n - The object to track with the camera.\n\n\nworld\n - The group that contains all other groups and objects including \ntrackObj\n.\n\n\nparams\n - An optional table of named settings:\n\n\ndebugEn\n (\nfalse\n) - Enable debug feedback (see summary above).\n\n\ndeadRadius\n (\n100\n) - Radius of dead zone.\n\n\nbufferSize\n (\n50\n) - Width of zone outside \ndeadRadius\n where camera starts to move.  \n\n\nCamera will be moving at same rate as \ntrackObj\n once that object is at \ndeadRadius\n + \nbufferSize\n distance from camera center.\n\n\n\n\n\n\n\n\n\n\n\n\ntrackingLooseRectangle\n\n\nA camera that tracks the \ntrackObj\n continuously, but only moves the \nworld\n once the \ntrackObj\n moves beyond the bounds of a rectangular dead zone.  After that, \nworld\n movement accelerates gradually to match that of \ntrackObj\n.  \n\n\nssk.camera.trackingLooseRectangle( trackObj, world [ , params ]  )\n\n\n\n\n\n\ntrackObj\n - The object to track with the camera.\n\n\nworld\n - The group that contains all other groups and objects including \ntrackObj\n.\n\n\nparams\n - An optional table of named settings:   \n\n\nboundarySize\n (\n100\n) - Pixel width of boudary. \n\n\nThe tracking rectangle is centered on the screen and has a width and height equal to the \nfullw - boundarySize\n and \nfullh - boundarySize\n respectively. \n\n\n\n\n\n\nminDelta\n (\n0.2\n) - Controls sensitivity of movement when boundary is encountered.\n\n\n\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.camera.*"
        }, 
        {
            "location": "/libraries/camera/#camera-library-sskcamera", 
            "text": "A number of basic cameras you can use out-of-the-box, or that you can copy and modify to meet your specific game requirements/            delayedTracking  tracking    trackingLooseCircle  trackingLooseRectangle", 
            "title": "Camera Library (ssk.camera.*)"
        }, 
        {
            "location": "/libraries/camera/#tracking", 
            "text": "A camera that tracks the position of the  trackObj  exactly, keeping it in the exact position it started in or has specified to be at.  This camera supports the ability to track in only one axis and/or to adjust the tracking offset.   ssk.camera.tracking( trackObj, world [ , params ]  )   trackObj  - The object to track with the camera.  world  - The group that contains all other groups and objects including  trackObj .  params  - An optional table of named settings:  centered  ( false ) - If  true , forces camera tracking to center of screen.  lockX  ( false ) - If  true , tracking ignores x-movement.  lockY  ( false ) - If  true , tracking ignores y-movement.  lx  - If specified, this is the x-position to track at.    Defaults to starting x-position of  trackObj .    ly  - If specified, this is the y-position to track at.  Defaults to starting y-position of  trackObj .           \n-- Create some basic layers.\n--\nlocal layers = quickLayers( group, \n       underlay ,\n       world ,\n         {  circles ,  player  },\n       overlay  )\n\nlocal player = newImageRect( layers.player, centerX, centerY,  images/smiley.png  )\n\nssk.camera.tracking( player, layers.world )", 
            "title": "tracking"
        }, 
        {
            "location": "/libraries/camera/#delayedtracking", 
            "text": "An  experimental  camera that waits a moment then moves to the new position of the  trackObj .  Note:  I don't use this one.  It is meant to be a starting place for delayed cameras.  If you need such a camera, examine this code and then write your own camera function.  ssk.camera.delayedTracking(  )   trackObj  - The object to track with the camera.  world  - The group that contains all other groups and objects including  trackObj .  params  - An optional table of named settings:  centered  ( false ) - If  true , forces camera tracking to center of screen.  lockX  ( false ) - If  true , tracking ignores x-movement.  lockY  ( false ) - If  true , tracking ignores y-movement.  lx  - If specified, this is the x-position to track at.    Defaults to starting x-position of  trackObj .    ly  - If specified, this is the y-position to track at.  Defaults to starting y-position of  trackObj .", 
            "title": "delayedTracking"
        }, 
        {
            "location": "/libraries/camera/#trackingloosecircle", 
            "text": "A camera that tracks the  trackObj  continuously, but only moves the  world  once the   trackObj  moves beyond the radius of a dead zone.  After that,  world  movement accelerates gradually to match that of  trackObj .    Includes a debug feature to allow you to see the limits of the dead zone.  ssk.camera.trackingLooseCircle( trackObj, world [ , params ]  )   trackObj  - The object to track with the camera.  world  - The group that contains all other groups and objects including  trackObj .  params  - An optional table of named settings:  debugEn  ( false ) - Enable debug feedback (see summary above).  deadRadius  ( 100 ) - Radius of dead zone.  bufferSize  ( 50 ) - Width of zone outside  deadRadius  where camera starts to move.    Camera will be moving at same rate as  trackObj  once that object is at  deadRadius  +  bufferSize  distance from camera center.", 
            "title": "trackingLooseCircle"
        }, 
        {
            "location": "/libraries/camera/#trackinglooserectangle", 
            "text": "A camera that tracks the  trackObj  continuously, but only moves the  world  once the  trackObj  moves beyond the bounds of a rectangular dead zone.  After that,  world  movement accelerates gradually to match that of  trackObj .    ssk.camera.trackingLooseRectangle( trackObj, world [ , params ]  )   trackObj  - The object to track with the camera.  world  - The group that contains all other groups and objects including  trackObj .  params  - An optional table of named settings:     boundarySize  ( 100 ) - Pixel width of boudary.   The tracking rectangle is centered on the screen and has a width and height equal to the  fullw - boundarySize  and  fullh - boundarySize  respectively.     minDelta  ( 0.2 ) - Controls sensitivity of movement when boundary is encountered.        Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "trackingLooseRectangle"
        }, 
        {
            "location": "/libraries/cc/", 
            "text": "Collision Calculator (ssk.cc.*)\n\n\nThe \nCollision Calculator\n allows you to quickly and easily configure single-body collisions rules using names instead of numbers.\n\n\nCreating a Calculator\n\n\nCreating a new myCC is as easy as:\n\n\nlocal myCC = ssk.cc.newCalculator()\n\n\n\n\nCalculator Methods (myCC:*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\naddName\n\n\naddNames\n\n\ncollidesWith\n\n\n\n\n\n\ngetCategoryBits\n\n\ngetMaskBits\n\n\ngetCollisionFilter\n\n\n\n\n\n\ndump\n\n\n\n\n\n\n\n\n\n\n\n\naddName\n\n\nAdd new 'named' collider type to known list of collider types, and automatically assign a number to this collider type (16 Max).\n\n\nmyCC.addName( colliderName )\n\n\n\n\n\n\ncolliderName\n - String containing name for new collider type.\n\n\n\n\n\nlocal myCC = ssk.cc.newCalculator()\n\nmyCC:addName( \nblock\n )\n\nmyCC:addName( \nredBall\n )\n\nmyCC:addName( \ngreenBall\n )\n\n\n\n\n\naddNames\n\n\nSame as \naddNames\n, but takes multiple strings in one call.\n\n\nmyCC.addNames( ... )\n\n\n\n\n\n\n...\n - One or more strings containing name for new collider type.\n\n\n\n\n\nlocal myCC = ssk.cc.newCalculator()\n\nmyCC:addNames( \nblock\n, \nredBall\n, \ngreenBall\n )\n\n\n\n\n\ncollidesWith\n\n\nAutomatically configure named collider A to collide with one or more other named colliders. \n\n\nReturns true if named type was successfully added to known colliders list, false otherwise.\n\n\nmyCC.collidesWith( colliderNameA, ... )\n\n\n\n\n\n\ncolliderNameA\n - A string containing the name of the collider that is being configured.\n\n\n...\n - One or more strings identifying previously added collider types that collide with colliderNameA.\n\n\n\n\n\nlocal myCC = ssk.cc.newCalculator()\n\n-- 'redBall' collides with 'block' and 'greenBall'\n myCC:collidesWith( \nredBall\n, { \nblock\n, \ngreenBall\n } )\n\n\n\n\n\ngetCollisionFilter\n\n\nGet collision filter for the named collider.\n\n\nmyCC.getCollisionFilter( colliderName )\n\n\n\n\n\n\ncolliderName\n - A string containing the name of the collider you want the CollisionFilter for.\n\n\n\n\n-- Create an Object with a Collision Body (Get Filter)\n\nlocal tmp = display.newCircle( 100, 100, 10 )\n\ntmp:setFillColor( 1, 0, 0 )\n\nphysics.addBody( tmp, \ndynamic\n, { radius = 10, filter = myCC:getCollisionFilter( \nredBall\n ) } )\n\n\n\n\n\n\ngetCategoryBits\n\n\nGet category bits for the named collider.\n\n\nNote:\n Rarely used.  Use the \ngetCollisionFilter()\n function instead.\n\n\nmyCC.getCategoryBits( colliderName )\n\n\n\n\n\n\ncolliderName\n - A string containing the name of the collider you want the CategoryBits for.\n\n\n\n\n\nlocal myCC = ssk.cc.newCalculator()\n\nmyCC:getCategoryBits()\n\n\n\n\n\ngetMaskBits\n\n\nGet mask bits for the named collider.\n\n\nNote:\n Rarely used.  Use the \ngetCollisionFilter()\n function instead.\n\n\nmyCC.getMaskBits( colliderName )\n\n\n\n\n\n\ncolliderName\n - A string containing the name of the collider you want the MaskBits for.\n\n\n\n\n\nlocal myCC = ssk.cc.newCalculator()\n\nmyCC:getMaskBits()\n\n\n\n\n\ndump\n\n\n(Debug Feature) Prints collider names, numbers, category bits, and masks.\n\n\n\nlocal myCC = ssk.cc.newCalculator()\n\nmyCC:addNames( \nblock\n, \nredBall\n, \ngreenBall\n )\n\nmyCC:collidesWith( \nredBall\n, { \nblock\n, \ngreenBall\n } )\n\nmyCC:dump()\n\n\n\n\n\nPrints: \n\n\n*********************************************\nDumping collision settings...\n          name | num | cat bits | col mask\n-------------- | --- | -------- | --------\nredBall        |  2  |  2       |  5\nblock          |  1  |  1       |  2\ngreenBall      |  3  |  4       |  2\n\n*********************************************\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.cc.*"
        }, 
        {
            "location": "/libraries/cc/#collision-calculator-sskcc", 
            "text": "The  Collision Calculator  allows you to quickly and easily configure single-body collisions rules using names instead of numbers.", 
            "title": "Collision Calculator (ssk.cc.*)"
        }, 
        {
            "location": "/libraries/cc/#creating-a-calculator", 
            "text": "Creating a new myCC is as easy as:  local myCC = ssk.cc.newCalculator()", 
            "title": "Creating a Calculator"
        }, 
        {
            "location": "/libraries/cc/#calculator-methods-mycc", 
            "text": "addName  addNames  collidesWith    getCategoryBits  getMaskBits  getCollisionFilter    dump", 
            "title": "Calculator Methods (myCC:*)"
        }, 
        {
            "location": "/libraries/cc/#addname", 
            "text": "Add new 'named' collider type to known list of collider types, and automatically assign a number to this collider type (16 Max).  myCC.addName( colliderName )   colliderName  - String containing name for new collider type.   \nlocal myCC = ssk.cc.newCalculator()\n\nmyCC:addName(  block  )\n\nmyCC:addName(  redBall  )\n\nmyCC:addName(  greenBall  )", 
            "title": "addName"
        }, 
        {
            "location": "/libraries/cc/#addnames", 
            "text": "Same as  addNames , but takes multiple strings in one call.  myCC.addNames( ... )   ...  - One or more strings containing name for new collider type.   \nlocal myCC = ssk.cc.newCalculator()\n\nmyCC:addNames(  block ,  redBall ,  greenBall  )", 
            "title": "addNames"
        }, 
        {
            "location": "/libraries/cc/#collideswith", 
            "text": "Automatically configure named collider A to collide with one or more other named colliders.   Returns true if named type was successfully added to known colliders list, false otherwise.  myCC.collidesWith( colliderNameA, ... )   colliderNameA  - A string containing the name of the collider that is being configured.  ...  - One or more strings identifying previously added collider types that collide with colliderNameA.   \nlocal myCC = ssk.cc.newCalculator()\n\n-- 'redBall' collides with 'block' and 'greenBall'\n myCC:collidesWith(  redBall , {  block ,  greenBall  } )", 
            "title": "collidesWith"
        }, 
        {
            "location": "/libraries/cc/#getcollisionfilter", 
            "text": "Get collision filter for the named collider.  myCC.getCollisionFilter( colliderName )   colliderName  - A string containing the name of the collider you want the CollisionFilter for.   -- Create an Object with a Collision Body (Get Filter)\n\nlocal tmp = display.newCircle( 100, 100, 10 )\n\ntmp:setFillColor( 1, 0, 0 )\n\nphysics.addBody( tmp,  dynamic , { radius = 10, filter = myCC:getCollisionFilter(  redBall  ) } )", 
            "title": "getCollisionFilter"
        }, 
        {
            "location": "/libraries/cc/#getcategorybits", 
            "text": "Get category bits for the named collider.  Note:  Rarely used.  Use the  getCollisionFilter()  function instead.  myCC.getCategoryBits( colliderName )   colliderName  - A string containing the name of the collider you want the CategoryBits for.   \nlocal myCC = ssk.cc.newCalculator()\n\nmyCC:getCategoryBits()", 
            "title": "getCategoryBits"
        }, 
        {
            "location": "/libraries/cc/#getmaskbits", 
            "text": "Get mask bits for the named collider.  Note:  Rarely used.  Use the  getCollisionFilter()  function instead.  myCC.getMaskBits( colliderName )   colliderName  - A string containing the name of the collider you want the MaskBits for.   \nlocal myCC = ssk.cc.newCalculator()\n\nmyCC:getMaskBits()", 
            "title": "getMaskBits"
        }, 
        {
            "location": "/libraries/cc/#dump", 
            "text": "(Debug Feature) Prints collider names, numbers, category bits, and masks.  \nlocal myCC = ssk.cc.newCalculator()\n\nmyCC:addNames(  block ,  redBall ,  greenBall  )\n\nmyCC:collidesWith(  redBall , {  block ,  greenBall  } )\n\nmyCC:dump()  Prints:   *********************************************\nDumping collision settings...\n          name | num | cat bits | col mask\n-------------- | --- | -------- | --------\nredBall        |  2  |  2       |  5\nblock          |  1  |  1       |  2\ngreenBall      |  3  |  4       |  2\n\n*********************************************     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "dump"
        }, 
        {
            "location": "/libraries/easy_inputs/", 
            "text": "Easy Inputs (ssk.easyInputs.*)\n\n\nThis library provides a number of \nfactories\n create easy input object \ninstances\n.  These objects dispatch Runtime events when touched.  To use these events you simply add \nlisteners\n to any part of your code that cares about the input.\n\n\n\n\n\n\n\n\nOne Touch\n\n\nTwo Touch\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOne Touch\n - The entire screen is a button.\n\n\nTwo Touch\n -  The screen is split down the middle and each half (left \n right) is treated as a button.\n\n\n\n\n\n\n\n\n\n\nOne Stick\n\n\nTwo Stick\n\n\nOne Stick + One Touch\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOne Stick\n - A single virtual joystick is created anywhere you touch the screen and tracks your finger till you lift it. \n\n\nTwo Stick\n - The screen is split in half horizontally, each side (left \n right) hosting a virtual joystick. \n\n\nOne Stick + One Touch\n -  One side of the screen is a button, one side hosts a virtual joystick. \n\n\n\n\nNote:\n Each of the three 'stick' factories uses the '\nJoystick Factory\n' to build the virtual joystick(s).\n\n\nEasy Input Factories\n\n\noneTouch\n\n\nThe entire screen is a button.\n\n\nssk.easyInputs.oneTouch.create( [ group [ , params ]] )\n\n\n\n\n\n\ngroup\n (\ndisplay.currentStage\n) - Display group to put input display object(s) into.\n\n\nparams\n - Parameters used to configure the input object(s).\n\n\ndebugEn\n (\nfalse\n) - Enable visual feedback to show input instance is working.\n\n\nfill\n (\n{1,0,0}\n) - Fill color to use for 'touch area'.\n\n\nalpha\n (\n0\n) - Alpha to use for touch area.  \n\n\nIf \ndebugEn\n is \ntrue\n this defaults to \n0.25\n.\n\n\n\n\n\n\neventName\n (\nonOneTouch\n) - Touching the 'touch area' \nposts\n (dispatches) a Runtime event with this name.\n\n\nSee '\nEasy Input Listeners\n' below to learn about writing listeners.\n\n\n\n\n\n\nkeyboardEn\n (\nfalse\n) - If this is \ntrue\n, you can use the keyboard while on the simulator to dispatch events.\n\n\nw\n and \nup\n (arrow) both \npost\n \neventName\n.\n\n\n\n\n\n\nappleTVEn\n (\nfalse\n) - This special setting lets you use the same input object on AppleTV.\n\n\nNote:\n Pressing \nbuttonZ\n on the Apple TV remote/controller \nposts\n \neventName\n.\n\n\n\n\n\n\n\n\n\n\n\n\n\nssk.easyInputs.oneTouch.create( group, { debugEn = true, keyboardEn = true } )\n\n\n\n\n\ntwoTouch\n\n\nThe screen is split down the middle and each half (left \n right) is treated as a button.\n\n\nssk.easyInputs.twoTouch.create( [ group [ , params ]] )\n\n\n\n\n\n\ngroup\n (\ndisplay.currentStage\n) - Display group to put input display object(s) into.\n\n\nparams\n - Parameters used to configure the input object(s).\n\n\ndebugEn\n (\nfalse\n) - Enable visual feedback to show input instance is working.\n\n\nleftFill\n (\n{0,0,1}\n) - Fill color to use for left 'touch area'.\n\n\nrightFill\n (\n{1,0,0}\n) - Fill color to use for right 'touch area'.\n\n\nalpha\n (\n0\n) - Alpha to use for left \n right touch area.  \n\n\nIf \ndebugEn\n is \ntrue\n this defaults to \n0.25\n.\n\n\n\n\n\n\nleftEventName\n (\nonTwoTouchLeft\n) - Touching the left 'touch area' \nposts\n (dispatches) a Runtime event with this name.\n\n\nrightEventName\n (\nonTwoTouchRight\n) - Touching the right 'touch area' \nposts\n (dispatches) a Runtime event with this name.\n\n\nSee '\nEasy Input Listeners\n' below to learn about writing listeners. \n\n\n\n\n\n\nkeyboardEn\n (\nfalse\n) - If this is \ntrue\n, you can use the keyboard while on the simulator to dispatch events.\n\n\na\n and \nleft\n (arrow) both \npost\n \nleftEventName\n.\n\n\nd\n and \nright\n (arrow) both \npost\n \nrightEventName\n.\n\n\n\n\n\n\n\n\n\n\n\n\n\nssk.easyInputs.twoTouch.create( group, { debugEn = true, keyboardEn = true } )\n\n\n\n\n\noneStick\n\n\nA single virtual joystick is created anywhere you touch the screen and tracks your finger till you lift it. \n\n\nssk.easyInputs.oneStick.create( [ group [ , params ]] )\n\n\n\n\n\n\ngroup\n (\ndisplay.currentStage\n) - Display group to put input display object(s) into.\n\n\nparams\n - Parameters used to configure the input object(s).\n\n\ngroup\n (\ndisplay.currentStage\n) - Display group to put input display object(s) into.\n\n\nparams\n - Parameters used to configure the input object(s).\n\n\ndebugEn\n (\nfalse\n) - Enable visual feedback to show input instance is working.\n\n\nfill\n (\n{1,0,0}\n) - Fill color to use for 'touch area'.\n\n\nalpha\n (\n0\n) - Alpha to use for touch area.  \n\n\nIf \ndebugEn\n is \ntrue\n this defaults to \n0.25\n.\n\n\n\n\n\n\neventName\n (\nonJoystick\n) - Touching the 'touch area' \nposts\n (dispatches) a Runtime event with this name.\n\n\nSee '\nEasy Input Listeners\n' below to learn about writing listeners.\n\n\n\n\n\n\njoyParams\n (\n{}\n) - A table that is passed to the joystick helper to build joystick.\n\n\nSee '\nJoystick Factory\n' below for more details on this table.\n\n\n\n\n\n\n\n\n\n\n\n\n\nssk.easyInputs.oneStick.create( group, { debugEn = true, joyParams = { doNorm = true } } )\n\n\n\n\n\ntwoStick\n\n\nThe screen is split in half horizontally, each side (left \n right) hosting a virtual joystick. \n\n\nssk.easyInputs.twoStick.create( [ group [ , params ]] )\n\n\n\n\n\n\ngroup\n (\ndisplay.currentStage\n) - Display group to put input display object(s) into.\n\n\nparams\n - Parameters used to configure the input object(s).\n\n\ndebugEn\n (\nfalse\n) - Enable visual feedback to show input instance is working.\n\n\nleftFill\n (\n{0,0,1}\n) - Fill color to use for left 'touch area'.\n\n\nrightFill\n (\n{1,0,0}\n) - Fill color to use for right 'touch area'.\n\n\nalpha\n (\n0\n) - Alpha to use for left \n right touch area.  \n\n\nIf \ndebugEn\n is \ntrue\n this defaults to \n0.25\n.\n\n\n\n\n\n\nleftEventName\n (\nonLeftJoystick\n) - Touching the left 'touch area' \nposts\n (dispatches) a Runtime event with this name.\n\n\nrightEventName\n (\nonRightJoystick\n) - Touching the right 'touch area' \nposts\n (dispatches) a Runtime event with this name.\n\n\nSee '\nEasy Input Listeners\n' below to learn about writing listeners. \n\n\n\n\n\n\nkeyboardEn\n (\nfalse\n) - If this is \ntrue\n, you can use the keyboard while on the simulator to dispatch events.\n\n\na\n and \nleft\n (arrow) both \npost\n \nleftEventName\n.\n\n\nd\n and \nright\n (arrow) both \npost\n \nrightEventName\n.\n\n\n\n\n\n\nleftJoyParams\n (\n{}\n) - A table that is passed to the joystick helper to build joystick.\n\n\nrightJoyParams\n (\n{}\n) - A table that is passed to the joystick helper to build joystick.\n\n\nSee '\nJoystick Factory\n' below for more details on the joystick parameter tables.\n\n\n\n\n\n\n\n\n\n\n\n\n\nssk.easyInputs.twoStick.create( group, { debugEn = true, joyParams = { doNorm = true } } )\n\n\n\n\n\noneStickOneTouch\n\n\nOne side of the screen is a button, one side hosts a virtual joystick.  \n\n\nBy default, the left-side is the joystick and the right is the button, but this can be swapped.\n\n\nssk.easyInputs.oneStickOneTouch.create( [ group [ , params ]] )\n\n\n\n\n\n\ngroup\n (\ndisplay.currentStage\n) - Display group to put input display object(s) into.\n\n\nparams\n - Parameters used to configure the input object(s).\n\n\ndebugEn\n (\nfalse\n) - Enable visual feedback to show input instance is working.\n\n\nleftFill\n (\n{0,0,1}\n) - Fill color to use for left 'touch area'.\n\n\nrightFill\n (\n{1,0,0}\n) - Fill color to use for right 'touch area'.\n\n\nalpha\n (\n0\n) - Alpha to use for left \n right touch area.  \n\n\nIf \ndebugEn\n is \ntrue\n this defaults to \n0.25\n.\n\n\n\n\n\n\nstickOnRight\n (\nfalse\n) - If \ntrue\n the virtual joystick will be on the right and the button on the left.\n\n\ntouchEventName\n (\nonOneTouch\n) - Touching the left 'touch area' \nposts\n (dispatches) a Runtime event with this name.\n\n\nstickEventName\n (\nonJoystick\n) - Touching the right 'touch area' \nposts\n (dispatches) a Runtime event with this name.\n\n\nSee '\nEasy Input Listeners\n' below to learn about writing listeners. \n\n\n\n\n\n\nkeyboardEn\n (\nfalse\n) - If this is \ntrue\n, you can use the keyboard while on the simulator to dispatch the button events.\n\n\nw\n and \nup\n (arrow) both \npost\n \ntouchEventName\n.\n\n\n\n\n\n\njoyParams\n (\n{}\n) - A table that is passed to the joystick helper to build joystick.\n\n\nSee '\nJoystick Factory\n' below for more details on this table.\n\n\n\n\n\n\n\n\n\n\n\n\n\nssk.easyInputs.oneStickOneTouch.create( group, { debugEn = true, joyParams = { doNorm = true } } )\n\n\n\n\n\nJoystick Factory\n\n\nThis is a helper factory (used by the stick factories) to create a virtual joystick.  Of course, you can call it directly if you want to.\n\n\nThis produces a 'virtual' fixed- or floating- joysticks.  The prior stays in place, while the latter moves to the beginning of the touch event that triggered it.\n\n\nVirtual joysticks dispatch a Runtime event that can be listened for anywhere and by any object(s).  See '\nEasy Input Listeners\n' below to learn more about this.\n\n\nssk.easyInputs.joystick.create( group, x, y, joyParams  )\n\n\n\n\n\n\ngroup\n (\ndisplay.currentStage\n) - Display group to put input display object(s) into.\n\n\nx\n, \ny\n - \n x, y \n position to initially place joystick at.\n\n\n\n\njoyParams\n (\n{}\n) - A table of parameters defining how this virtual joystick looks and behaves.\n\n\n\n\nouterRadius\n (\n60\n) - Radius of entire virtual joystick touch area.\n\n\nouterImg\n (\nnil\n) - Optional image to use for this part of the virtual joystick.\n\n\nouterFill\n (\n{1,1,1,0}\n) - Fill color.\n\n\nouterStrokeColor\n (\n{0.25,0.25,0.25,1}\n) - Stroke color.\n\n\nouterStrokeWidth\n (\n4\n) - Stroke width.\n\n\nouterAlpha\n (\n1\n) - Alpha.  \n\n\nparams.alpha\n - Can be used to set this too.\n\n\n\n\n\n\nstickRadius\n (\nouterRadius/2\n) - Radius of the stick/thumb part of the virtual joystick touch area.\n\n\nstickImg\n (\nnil\n) - Optional image to use for this part of the virtual joystick.\n\n\nstickFill\n (\n{1,1,1,0}\n) - Fill color.\n\n\nstickStrokeColor\n (\n{0.25,0.25,0.25,1}\n) - Stroke color.\n\n\nstickStrokeWidth\n (\n4\n) - Stroke width.\n\n\nstickAlpha\n (\n1\n) - Alpha.  \n\n\nparams.alpha\n - Can be used to set this too.\n\n\n\n\n\n\nouterRadius\n (\nouterRadius/2\n) - Radius of dead zone.\n\n    Touches within this space are registered, but given the event \nstate\n of `off.\n\n\ndeadZoneImg\n (\nnil\n) - Optional image to use for this part of the virtual joystick.\n\n\ndeadZoneFill\n (\n{1,1,1,0}\n) - Fill color.\n\n\ndeadZoneStrokeColor\n (\n{0.25,0.25,0.25,1}\n) - Stroke color.\n\n\ndeadZoneStrokeWidth\n (\n4\n) - Stroke width.\n\n\n\n\ndeadZoneAlpha\n (\n1\n) - Alpha.  \n\n\n\n\nparams.alpha\n - Can be used to set this too.\n\n\n\n\n\n\n\n\neventName\n (\nonJoystick\n) - The virtual joystick \nposts\n (dispatches) a Runtime event with this name when it is used.\n\n\n\n\ninputObj\n (\nnil\n) - Object to use as touch proxy for joystick.\n\n\nIf this object \nIS NOT PROVIDED\n, the joystick is stationary and acts as its own touch catching object.\n\n\nIf this object \nIS PROVIDED\n the virtual joystick \nfloats\n.  That is, it moves to wherever the touch 'begins', then stays in place till the touch ends.\n\n\n\n\n\n\ninUseAlpha\n (\n1\n) - The alpha property of the virtual joystick rises to this value when you activate it.\n\n\nnotInUseAlpha\n (\n0\n) - This is the alpha for the virtual joystick when it is not inuse.\n\n\nuseAlphaFadeTime\n (\n0\n) - This controls how long alpha in-use/not-in-use changes take to complete.\n\n\ndoNorm\n (\nfalse\n) - By default, the virtual joystick does not include the normalized vector representation of the joystick pointing vector.  However, if you need this, you can set this property to \ntrue\n.  \n\n\nIf this is \ntrue\n, the virtual joystick event will include two fields, \nnx\n and \nny\n which are the normalized versions of \nvx\n and \nvy\n respectively.\n\n\n\n\n\n\n\n\n\n\n\n\n\njoystick.create( nil, left + 30, bottom - 30 )\n\n\n\n\n\nEasy Input Instances\n\n\nOne Touch Instance\n\n\nThe 'One Touch Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime event.  This event can the be listed for for anywhere and by any object(s).\n\n\nAdditionally, this 'instance' has these methods:\n\n\n\n\ndestroy()\n - Destroys and cleans up the object listeners entirely.\n\n\nsleep()\n - Temorarily ignore inputs.\n\n\nwake()\n - Resume listenting for inputs.\n\n\ngetPressed()\n - Returns \ntrue\n if the instance is currently being 'touched'.\n\n\nfinalize()\n - The factory adds its own '\nfinalize\n' method, so don't add one yourself.\n\n\n\n\nTwo Touch Instance\n\n\nThe 'Two Touch Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime events.  These events can the be listed for for anywhere and by any object(s).\n\n\nAdditionally, this 'instance' has these methods:\n\n\n\n\ndestroy()\n - Destroys and cleans up the object listeners entirely.\n\n\nsleep()\n - Temorarily ignore inputs.\n\n\nwake()\n - Resume listenting for inputs.\n\n\nfinalize()\n - The factory adds its own '\nfinalize\n' method, so don't add one yourself.\n\n\n\n\nOne Stick Instance\n\n\nThe 'One Stick Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime event.  This event can the be listed for for anywhere and by any object(s).\n\n\nAdditionally, this 'instance' has this methods:\n\n\n\n\ndestroy()\n - Destroys and cleans up the object listeners entirely.\n\n\n\n\nTwo Stick Instance\n\n\nThe 'Two Stick Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime events.  These events can the be listed for for anywhere and by any object(s).\n\n\nAdditionally, this 'instance' has this methods:\n\n\n\n\ndestroy()\n - Destroys and cleans up the object listeners entirely.\n\n\n\n\nOne Stick + One Touch Instance\n\n\nThe 'One Stick + One Touch Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime events.  These events can the be listed for for anywhere and by any object(s).\n\n\nAdditionally, this 'instance' has these methods:\n\n\n\n\ndestroy()\n - Destroys and cleans up the object listeners entirely.\n\n\nsleep()\n - Temorarily ignore inputs.\n\n\nwake()\n - Resume listenting for inputs.\n\n\ngetPressed()\n - Returns \ntrue\n if the button side of the instance is currently being 'touched'.\n\n\nfinalize()\n - The factory adds its own '\nfinalize\n' method, so don't add one yourself.\n\n\n\n\nJoystick Instance\n\n\nThe 'Joystick Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime events.  These events can the be listed for for anywhere and by any object(s).\n\n\nIt has no special methods attached to it.\n\n\nEasy Input Listeners\n\n\nOne Touch Listeners\n\n\nOne Touch objects produce a custom Runtime event with all the same properties as the standard Corona SDK \ntouch event\n.\n\n\nException:\n The \nname\n field has been changed from \n\"touch\"\n to whatever custom event name the instance is using (Ex: \n\"onOneTouch\"\n).\n\n\n\n-- One Touch Function Listener\n\nssk.easyInputs.oneTouch.create( group )\n\nlocal function onOneTouch( event )\n\n   table.dump( event )\n\nend; listen( \nonOneTouch\n, onOneTouch )\n\n\n\n\n\n\n-- One Touch Table Listener\n\nssk.easyInputs.oneTouch.create( group )\n\nlocal player = newImagRect( group, centerX, centerY, \nimages/player.png\n)\n\nfunction player.onOneTouch( self, event )\n\n   table.dump( event )\n\nend; listen( \nonOneTouch\n, player )\n\n\n\n\n\nTwo Touch Listeners\n\n\nTwo Touch objects produce a custom Runtime event with all the same properties as the standard Corona SDK \ntouch event\n.\n\n\nException:\n The \nname\n field has been changed from \n\"touch\"\n to whatever custom event name the instance is using (Ex: \n\"onTwoTouchLeft\"\n or \n\"onTwoTouchRight\"\n ).\n\n\n\n-- Two Touch Function Listener\n\nssk.easyInputs.twoTouch.create( group )\n\nlocal function onTwoTouchLeft( event )\n\n   table.dump( event )\n\nend; listen( \nonTwoTouchLeft\n, onTwoTouchLeft )\n\nlocal function onTwoTouchRight( event )\n\n   table.dump( event )\n\nend; listen( \nonTwoTouchRight\n, onTwoTouchRight )\n\n\n\n\n\n\n\n-- Two Touch Table Listener\n\nssk.easyInputs.twoTouch.create( group )\n\nlocal player = newImagRect( group, centerX, centerY, \nimages/player.png\n)\n\nfunction player.onTwoTouchLeft( self, event )\n\n   table.dump( event )\n\nend; listen( \nonTwoTouchLeft\n, player )\n\nfunction player.onTwoTouchRight( self, event )\n\n   table.dump( event )\n\nend; listen( \nonTwoTouchRight\n, player )\n\n\n\n\n\nOne Stick + One Touch Listeners\n\n\n'One Stick + One Touch' objects need both a \nOne Touch Listener\n and a \nOne Stick Listener\n.\n\n\nOne Stick Listeners\n\n\nTwo Stick Listeners\n\n\nThe 'One' and 'Two' stick listeners both produce virtual joystick events.\n\n\nVirtual Joystick Listeners\n\n\nVirtual joysticks produce a custom Runtime event that includes these properties:\n\n\n\n\nangle\n - Angle the stick is pointed in, where 0 is up, 90 is right, etc.\n\n\nvx\n, \nvy\n - Vector x- and y- representations of \nangle\n, where length of vector is a function of how far the 'stick' is from the center of the virtual joystick.\n\n\nnx\n, \nny\n - Normalized version of \nvx\n and \nvy\n respecrtively.\n\n\nONLY IF:\n doNorm was set to \ntrue\n when creating the virtual joystick.\n\n\n\n\n\n\npercent\n - A value between 0 and 100 representing how far along the total stick movement distance the stick has moved away from the center of the virtual joystick.\n\n\nphase\n - \"began\", \"moved,\", or \"ended\".\n\n\nstate\n - '\"OFF\"' or '\"ON\"', depending on whether the stick is in our out of the 'dead zone' respectively.\n\n\ntime\n - Simulation time of the event.\n\n\n\n\n\n-- Two Touch Function Listener\n\nssk.easyInputs.oneStick.create( group )\n\nlocal function onJoystick( event )\n\n   table.dump( event )\n\nend; listen( \nonJoystick\n, onJoystick )\n\n\n\n\n\n\n\n-- Two Touch Table Listener\n\nssk.easyInputs.oneStick.create( group )\n\nlocal player = newImagRect( group, centerX, centerY, \nimages/player.png\n)\n\nfunction player.onJoystick( self, event )\n\n   table.dump( event )\n\nend; listen( \nonJoystick\n, player )\n\n\n\n\n\nShow Me Examples!\n\n\nDid you read all of the above docs and yet you still find this confusing?  \n\n\nMaybe a few complete examples would help you.\n\n\nIf so, try these:\n\n\n\n\nEFM - Link to recipes, etc.\n\n\nEFM - Link to recipes, etc.\n\n\nEFM - Link to recipes, etc.\n\n\nEFM - Link to recipes, etc.\n\n\nEFM - Link to recipes, etc.\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.easyInputs.*"
        }, 
        {
            "location": "/libraries/easy_inputs/#easy-inputs-sskeasyinputs", 
            "text": "This library provides a number of  factories  create easy input object  instances .  These objects dispatch Runtime events when touched.  To use these events you simply add  listeners  to any part of your code that cares about the input.     One Touch  Two Touch            One Touch  - The entire screen is a button.  Two Touch  -  The screen is split down the middle and each half (left   right) is treated as a button.      One Stick  Two Stick  One Stick + One Touch             One Stick  - A single virtual joystick is created anywhere you touch the screen and tracks your finger till you lift it.   Two Stick  - The screen is split in half horizontally, each side (left   right) hosting a virtual joystick.   One Stick + One Touch  -  One side of the screen is a button, one side hosts a virtual joystick.    Note:  Each of the three 'stick' factories uses the ' Joystick Factory ' to build the virtual joystick(s).", 
            "title": "Easy Inputs (ssk.easyInputs.*)"
        }, 
        {
            "location": "/libraries/easy_inputs/#easy-input-factories", 
            "text": "", 
            "title": "Easy Input Factories"
        }, 
        {
            "location": "/libraries/easy_inputs/#onetouch", 
            "text": "The entire screen is a button.  ssk.easyInputs.oneTouch.create( [ group [ , params ]] )   group  ( display.currentStage ) - Display group to put input display object(s) into.  params  - Parameters used to configure the input object(s).  debugEn  ( false ) - Enable visual feedback to show input instance is working.  fill  ( {1,0,0} ) - Fill color to use for 'touch area'.  alpha  ( 0 ) - Alpha to use for touch area.    If  debugEn  is  true  this defaults to  0.25 .    eventName  ( onOneTouch ) - Touching the 'touch area'  posts  (dispatches) a Runtime event with this name.  See ' Easy Input Listeners ' below to learn about writing listeners.    keyboardEn  ( false ) - If this is  true , you can use the keyboard while on the simulator to dispatch events.  w  and  up  (arrow) both  post   eventName .    appleTVEn  ( false ) - This special setting lets you use the same input object on AppleTV.  Note:  Pressing  buttonZ  on the Apple TV remote/controller  posts   eventName .       \nssk.easyInputs.oneTouch.create( group, { debugEn = true, keyboardEn = true } )", 
            "title": "oneTouch"
        }, 
        {
            "location": "/libraries/easy_inputs/#twotouch", 
            "text": "The screen is split down the middle and each half (left   right) is treated as a button.  ssk.easyInputs.twoTouch.create( [ group [ , params ]] )   group  ( display.currentStage ) - Display group to put input display object(s) into.  params  - Parameters used to configure the input object(s).  debugEn  ( false ) - Enable visual feedback to show input instance is working.  leftFill  ( {0,0,1} ) - Fill color to use for left 'touch area'.  rightFill  ( {1,0,0} ) - Fill color to use for right 'touch area'.  alpha  ( 0 ) - Alpha to use for left   right touch area.    If  debugEn  is  true  this defaults to  0.25 .    leftEventName  ( onTwoTouchLeft ) - Touching the left 'touch area'  posts  (dispatches) a Runtime event with this name.  rightEventName  ( onTwoTouchRight ) - Touching the right 'touch area'  posts  (dispatches) a Runtime event with this name.  See ' Easy Input Listeners ' below to learn about writing listeners.     keyboardEn  ( false ) - If this is  true , you can use the keyboard while on the simulator to dispatch events.  a  and  left  (arrow) both  post   leftEventName .  d  and  right  (arrow) both  post   rightEventName .       \nssk.easyInputs.twoTouch.create( group, { debugEn = true, keyboardEn = true } )", 
            "title": "twoTouch"
        }, 
        {
            "location": "/libraries/easy_inputs/#onestick", 
            "text": "A single virtual joystick is created anywhere you touch the screen and tracks your finger till you lift it.   ssk.easyInputs.oneStick.create( [ group [ , params ]] )   group  ( display.currentStage ) - Display group to put input display object(s) into.  params  - Parameters used to configure the input object(s).  group  ( display.currentStage ) - Display group to put input display object(s) into.  params  - Parameters used to configure the input object(s).  debugEn  ( false ) - Enable visual feedback to show input instance is working.  fill  ( {1,0,0} ) - Fill color to use for 'touch area'.  alpha  ( 0 ) - Alpha to use for touch area.    If  debugEn  is  true  this defaults to  0.25 .    eventName  ( onJoystick ) - Touching the 'touch area'  posts  (dispatches) a Runtime event with this name.  See ' Easy Input Listeners ' below to learn about writing listeners.    joyParams  ( {} ) - A table that is passed to the joystick helper to build joystick.  See ' Joystick Factory ' below for more details on this table.       \nssk.easyInputs.oneStick.create( group, { debugEn = true, joyParams = { doNorm = true } } )", 
            "title": "oneStick"
        }, 
        {
            "location": "/libraries/easy_inputs/#twostick", 
            "text": "The screen is split in half horizontally, each side (left   right) hosting a virtual joystick.   ssk.easyInputs.twoStick.create( [ group [ , params ]] )   group  ( display.currentStage ) - Display group to put input display object(s) into.  params  - Parameters used to configure the input object(s).  debugEn  ( false ) - Enable visual feedback to show input instance is working.  leftFill  ( {0,0,1} ) - Fill color to use for left 'touch area'.  rightFill  ( {1,0,0} ) - Fill color to use for right 'touch area'.  alpha  ( 0 ) - Alpha to use for left   right touch area.    If  debugEn  is  true  this defaults to  0.25 .    leftEventName  ( onLeftJoystick ) - Touching the left 'touch area'  posts  (dispatches) a Runtime event with this name.  rightEventName  ( onRightJoystick ) - Touching the right 'touch area'  posts  (dispatches) a Runtime event with this name.  See ' Easy Input Listeners ' below to learn about writing listeners.     keyboardEn  ( false ) - If this is  true , you can use the keyboard while on the simulator to dispatch events.  a  and  left  (arrow) both  post   leftEventName .  d  and  right  (arrow) both  post   rightEventName .    leftJoyParams  ( {} ) - A table that is passed to the joystick helper to build joystick.  rightJoyParams  ( {} ) - A table that is passed to the joystick helper to build joystick.  See ' Joystick Factory ' below for more details on the joystick parameter tables.       \nssk.easyInputs.twoStick.create( group, { debugEn = true, joyParams = { doNorm = true } } )", 
            "title": "twoStick"
        }, 
        {
            "location": "/libraries/easy_inputs/#onestickonetouch", 
            "text": "One side of the screen is a button, one side hosts a virtual joystick.    By default, the left-side is the joystick and the right is the button, but this can be swapped.  ssk.easyInputs.oneStickOneTouch.create( [ group [ , params ]] )   group  ( display.currentStage ) - Display group to put input display object(s) into.  params  - Parameters used to configure the input object(s).  debugEn  ( false ) - Enable visual feedback to show input instance is working.  leftFill  ( {0,0,1} ) - Fill color to use for left 'touch area'.  rightFill  ( {1,0,0} ) - Fill color to use for right 'touch area'.  alpha  ( 0 ) - Alpha to use for left   right touch area.    If  debugEn  is  true  this defaults to  0.25 .    stickOnRight  ( false ) - If  true  the virtual joystick will be on the right and the button on the left.  touchEventName  ( onOneTouch ) - Touching the left 'touch area'  posts  (dispatches) a Runtime event with this name.  stickEventName  ( onJoystick ) - Touching the right 'touch area'  posts  (dispatches) a Runtime event with this name.  See ' Easy Input Listeners ' below to learn about writing listeners.     keyboardEn  ( false ) - If this is  true , you can use the keyboard while on the simulator to dispatch the button events.  w  and  up  (arrow) both  post   touchEventName .    joyParams  ( {} ) - A table that is passed to the joystick helper to build joystick.  See ' Joystick Factory ' below for more details on this table.       \nssk.easyInputs.oneStickOneTouch.create( group, { debugEn = true, joyParams = { doNorm = true } } )", 
            "title": "oneStickOneTouch"
        }, 
        {
            "location": "/libraries/easy_inputs/#joystick-factory", 
            "text": "This is a helper factory (used by the stick factories) to create a virtual joystick.  Of course, you can call it directly if you want to.  This produces a 'virtual' fixed- or floating- joysticks.  The prior stays in place, while the latter moves to the beginning of the touch event that triggered it.  Virtual joysticks dispatch a Runtime event that can be listened for anywhere and by any object(s).  See ' Easy Input Listeners ' below to learn more about this.  ssk.easyInputs.joystick.create( group, x, y, joyParams  )   group  ( display.currentStage ) - Display group to put input display object(s) into.  x ,  y  -   x, y   position to initially place joystick at.   joyParams  ( {} ) - A table of parameters defining how this virtual joystick looks and behaves.   outerRadius  ( 60 ) - Radius of entire virtual joystick touch area.  outerImg  ( nil ) - Optional image to use for this part of the virtual joystick.  outerFill  ( {1,1,1,0} ) - Fill color.  outerStrokeColor  ( {0.25,0.25,0.25,1} ) - Stroke color.  outerStrokeWidth  ( 4 ) - Stroke width.  outerAlpha  ( 1 ) - Alpha.    params.alpha  - Can be used to set this too.    stickRadius  ( outerRadius/2 ) - Radius of the stick/thumb part of the virtual joystick touch area.  stickImg  ( nil ) - Optional image to use for this part of the virtual joystick.  stickFill  ( {1,1,1,0} ) - Fill color.  stickStrokeColor  ( {0.25,0.25,0.25,1} ) - Stroke color.  stickStrokeWidth  ( 4 ) - Stroke width.  stickAlpha  ( 1 ) - Alpha.    params.alpha  - Can be used to set this too.    outerRadius  ( outerRadius/2 ) - Radius of dead zone. \n    Touches within this space are registered, but given the event  state  of `off.  deadZoneImg  ( nil ) - Optional image to use for this part of the virtual joystick.  deadZoneFill  ( {1,1,1,0} ) - Fill color.  deadZoneStrokeColor  ( {0.25,0.25,0.25,1} ) - Stroke color.  deadZoneStrokeWidth  ( 4 ) - Stroke width.   deadZoneAlpha  ( 1 ) - Alpha.     params.alpha  - Can be used to set this too.     eventName  ( onJoystick ) - The virtual joystick  posts  (dispatches) a Runtime event with this name when it is used.   inputObj  ( nil ) - Object to use as touch proxy for joystick.  If this object  IS NOT PROVIDED , the joystick is stationary and acts as its own touch catching object.  If this object  IS PROVIDED  the virtual joystick  floats .  That is, it moves to wherever the touch 'begins', then stays in place till the touch ends.    inUseAlpha  ( 1 ) - The alpha property of the virtual joystick rises to this value when you activate it.  notInUseAlpha  ( 0 ) - This is the alpha for the virtual joystick when it is not inuse.  useAlphaFadeTime  ( 0 ) - This controls how long alpha in-use/not-in-use changes take to complete.  doNorm  ( false ) - By default, the virtual joystick does not include the normalized vector representation of the joystick pointing vector.  However, if you need this, you can set this property to  true .    If this is  true , the virtual joystick event will include two fields,  nx  and  ny  which are the normalized versions of  vx  and  vy  respectively.       \njoystick.create( nil, left + 30, bottom - 30 )", 
            "title": "Joystick Factory"
        }, 
        {
            "location": "/libraries/easy_inputs/#easy-input-instances", 
            "text": "", 
            "title": "Easy Input Instances"
        }, 
        {
            "location": "/libraries/easy_inputs/#one-touch-instance", 
            "text": "The 'One Touch Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime event.  This event can the be listed for for anywhere and by any object(s).  Additionally, this 'instance' has these methods:   destroy()  - Destroys and cleans up the object listeners entirely.  sleep()  - Temorarily ignore inputs.  wake()  - Resume listenting for inputs.  getPressed()  - Returns  true  if the instance is currently being 'touched'.  finalize()  - The factory adds its own ' finalize ' method, so don't add one yourself.", 
            "title": "One Touch Instance"
        }, 
        {
            "location": "/libraries/easy_inputs/#two-touch-instance", 
            "text": "The 'Two Touch Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime events.  These events can the be listed for for anywhere and by any object(s).  Additionally, this 'instance' has these methods:   destroy()  - Destroys and cleans up the object listeners entirely.  sleep()  - Temorarily ignore inputs.  wake()  - Resume listenting for inputs.  finalize()  - The factory adds its own ' finalize ' method, so don't add one yourself.", 
            "title": "Two Touch Instance"
        }, 
        {
            "location": "/libraries/easy_inputs/#one-stick-instance", 
            "text": "The 'One Stick Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime event.  This event can the be listed for for anywhere and by any object(s).  Additionally, this 'instance' has this methods:   destroy()  - Destroys and cleans up the object listeners entirely.", 
            "title": "One Stick Instance"
        }, 
        {
            "location": "/libraries/easy_inputs/#two-stick-instance", 
            "text": "The 'Two Stick Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime events.  These events can the be listed for for anywhere and by any object(s).  Additionally, this 'instance' has this methods:   destroy()  - Destroys and cleans up the object listeners entirely.", 
            "title": "Two Stick Instance"
        }, 
        {
            "location": "/libraries/easy_inputs/#one-stick-one-touch-instance", 
            "text": "The 'One Stick + One Touch Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime events.  These events can the be listed for for anywhere and by any object(s).  Additionally, this 'instance' has these methods:   destroy()  - Destroys and cleans up the object listeners entirely.  sleep()  - Temorarily ignore inputs.  wake()  - Resume listenting for inputs.  getPressed()  - Returns  true  if the button side of the instance is currently being 'touched'.  finalize()  - The factory adds its own ' finalize ' method, so don't add one yourself.", 
            "title": "One Stick + One Touch Instance"
        }, 
        {
            "location": "/libraries/easy_inputs/#joystick-instance", 
            "text": "The 'Joystick Instance' is a composite object contained in display group that catches touches and converts them into a custom Runtime events.  These events can the be listed for for anywhere and by any object(s).  It has no special methods attached to it.", 
            "title": "Joystick Instance"
        }, 
        {
            "location": "/libraries/easy_inputs/#easy-input-listeners", 
            "text": "", 
            "title": "Easy Input Listeners"
        }, 
        {
            "location": "/libraries/easy_inputs/#one-touch-listeners", 
            "text": "One Touch objects produce a custom Runtime event with all the same properties as the standard Corona SDK  touch event .  Exception:  The  name  field has been changed from  \"touch\"  to whatever custom event name the instance is using (Ex:  \"onOneTouch\" ).  \n-- One Touch Function Listener\n\nssk.easyInputs.oneTouch.create( group )\n\nlocal function onOneTouch( event )\n\n   table.dump( event )\n\nend; listen(  onOneTouch , onOneTouch )  \n-- One Touch Table Listener\n\nssk.easyInputs.oneTouch.create( group )\n\nlocal player = newImagRect( group, centerX, centerY,  images/player.png )\n\nfunction player.onOneTouch( self, event )\n\n   table.dump( event )\n\nend; listen(  onOneTouch , player )", 
            "title": "One Touch Listeners"
        }, 
        {
            "location": "/libraries/easy_inputs/#two-touch-listeners", 
            "text": "Two Touch objects produce a custom Runtime event with all the same properties as the standard Corona SDK  touch event .  Exception:  The  name  field has been changed from  \"touch\"  to whatever custom event name the instance is using (Ex:  \"onTwoTouchLeft\"  or  \"onTwoTouchRight\"  ).  \n-- Two Touch Function Listener\n\nssk.easyInputs.twoTouch.create( group )\n\nlocal function onTwoTouchLeft( event )\n\n   table.dump( event )\n\nend; listen(  onTwoTouchLeft , onTwoTouchLeft )\n\nlocal function onTwoTouchRight( event )\n\n   table.dump( event )\n\nend; listen(  onTwoTouchRight , onTwoTouchRight )  \n-- Two Touch Table Listener\n\nssk.easyInputs.twoTouch.create( group )\n\nlocal player = newImagRect( group, centerX, centerY,  images/player.png )\n\nfunction player.onTwoTouchLeft( self, event )\n\n   table.dump( event )\n\nend; listen(  onTwoTouchLeft , player )\n\nfunction player.onTwoTouchRight( self, event )\n\n   table.dump( event )\n\nend; listen(  onTwoTouchRight , player )", 
            "title": "Two Touch Listeners"
        }, 
        {
            "location": "/libraries/easy_inputs/#one-stick-one-touch-listeners", 
            "text": "'One Stick + One Touch' objects need both a  One Touch Listener  and a  One Stick Listener .", 
            "title": "One Stick + One Touch Listeners"
        }, 
        {
            "location": "/libraries/easy_inputs/#one-stick-listeners", 
            "text": "", 
            "title": "One Stick Listeners"
        }, 
        {
            "location": "/libraries/easy_inputs/#two-stick-listeners", 
            "text": "The 'One' and 'Two' stick listeners both produce virtual joystick events.", 
            "title": "Two Stick Listeners"
        }, 
        {
            "location": "/libraries/easy_inputs/#virtual-joystick-listeners", 
            "text": "Virtual joysticks produce a custom Runtime event that includes these properties:   angle  - Angle the stick is pointed in, where 0 is up, 90 is right, etc.  vx ,  vy  - Vector x- and y- representations of  angle , where length of vector is a function of how far the 'stick' is from the center of the virtual joystick.  nx ,  ny  - Normalized version of  vx  and  vy  respecrtively.  ONLY IF:  doNorm was set to  true  when creating the virtual joystick.    percent  - A value between 0 and 100 representing how far along the total stick movement distance the stick has moved away from the center of the virtual joystick.  phase  - \"began\", \"moved,\", or \"ended\".  state  - '\"OFF\"' or '\"ON\"', depending on whether the stick is in our out of the 'dead zone' respectively.  time  - Simulation time of the event.   \n-- Two Touch Function Listener\n\nssk.easyInputs.oneStick.create( group )\n\nlocal function onJoystick( event )\n\n   table.dump( event )\n\nend; listen(  onJoystick , onJoystick )  \n-- Two Touch Table Listener\n\nssk.easyInputs.oneStick.create( group )\n\nlocal player = newImagRect( group, centerX, centerY,  images/player.png )\n\nfunction player.onJoystick( self, event )\n\n   table.dump( event )\n\nend; listen(  onJoystick , player )", 
            "title": "Virtual Joystick Listeners"
        }, 
        {
            "location": "/libraries/easy_inputs/#show-me-examples", 
            "text": "Did you read all of the above docs and yet you still find this confusing?    Maybe a few complete examples would help you.  If so, try these:   EFM - Link to recipes, etc.  EFM - Link to recipes, etc.  EFM - Link to recipes, etc.  EFM - Link to recipes, etc.  EFM - Link to recipes, etc.      Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Show Me Examples!"
        }, 
        {
            "location": "/libraries/files/", 
            "text": "Files Library (ssk.files.*)\n\n\nThis library came out of my need to achieve a number of file operations that I required to implement tools like: EAT, RG Particle Editor, and others.\n\n\nThe operations you are allowed to do vary by operating system and environment.  This library is orgnized to reflect that.\n\n\nDocuments Folder (ssk.files.documents.*)\n\n\n\n\ngetRoot()\n - EFM\n\n\ngetPath( path )\n - EFM\n\n\n\n\nResource Folder (ssk.files.resource.*)\n\n\n\n\ngetRoot()\n - EFM\n\n\ngetPath( path )\n - EFM\n\n\n\n\nTemporary Folder (ssk.files.temporary.*)\n\n\n\n\ngetRoot()\n - EFM\n\n\ngetPath( path )\n - EFM\n\n\n\n\nDesktop (OS X and Windows) (ssk.files.desktop.*)\n\n\n\n\ngetDesktopRoot()\n - EFM\n\n\ngetDesktopPath( path )\n - EFM\n\n\ngetMyDocumentsRoot()\n - EFM\n\n\ngetMyDocumentsPath( path )\n - EFM\n\n\ngetDrivePath( path )\n - EFM\n\n\nexplore( path )\n - EFM\n\n\n\n\nUtilities (ssk.files.util.*)\n\n\n\n\nexists( path )\n - EFM\n\n\ndumpAttributes()\n - EFM\n\n\nisFile( path )\n - EFM\n\n\nreadFile( path )\n - EFM\n\n\nreadFileToTable( path )\n - EFM\n\n\nwriteFile( data,  path )\n - EFM\n\n\nappendFile( data,  path )\n - EFM\n\n\nrmFile( path )\n - EFM\n\n\nmvFile( src, dst )\n - EFM\n\n\ncpFile( src, dst )\n - EFM\n\n\nisFolder( path )\n - EFM\n\n\nrepairPath( path, forceForward )\n - EFM\n\n\nrmFolder( path )\n - EFM\n\n\nmkFolder( path )\n - EFM\n\n\nmvFolder( src, dst )\n - EFM\n\n\ncpFolder( src, dst )\n - EFM\n\n\nsaveTable( tbl, path, secure )\n - EFM\n\n\nloadTable( path, secure )\n - EFM\n\n\n\n\nBonus Utilities (ssk.files.util.*)\n\n\n\n\ngetFilesInFolder( path )\n - EFM\n\n\nkeepFileTypes( files, extensions )\n - EFM\n\n\ngetLuaFiles( files )\n - EFM\n\n\ngetResourceFiles( files )\n - EFM\n\n\nflattenNames( t, sep, prefix )\n - EFM\n\n\nfindAllFiles( path )\n - EFM\n\n\n\n\nfindFileInPath( fileToFind, folderToSearch )\n - EFM\n\n\n\n\n\n\nEFM\n - EFM\n\n\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\n\n\nEFM EFM EFM\n\n\ncaptureBackButton\n\n\nSyntax:\n\n\nssk.android.captureBackButton( [ noCB, [ yesCB ]] )\n\n\n\n\nSummary:\n\nEFM EFM EFM\n\n\nEFM EFM\n\n\nUsage:\n\n\nlocal onNo()\n   print(\nPressed No\n)   \nend\n\nlocal onYes()\n   print(\nPressed Yes\n)\nend\n\nssk.android.captureBackButton( onNo, onYes )\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.files.*"
        }, 
        {
            "location": "/libraries/files/#files-library-sskfiles", 
            "text": "This library came out of my need to achieve a number of file operations that I required to implement tools like: EAT, RG Particle Editor, and others.  The operations you are allowed to do vary by operating system and environment.  This library is orgnized to reflect that.", 
            "title": "Files Library (ssk.files.*)"
        }, 
        {
            "location": "/libraries/files/#documents-folder-sskfilesdocuments", 
            "text": "getRoot()  - EFM  getPath( path )  - EFM", 
            "title": "Documents Folder (ssk.files.documents.*)"
        }, 
        {
            "location": "/libraries/files/#resource-folder-sskfilesresource", 
            "text": "getRoot()  - EFM  getPath( path )  - EFM", 
            "title": "Resource Folder (ssk.files.resource.*)"
        }, 
        {
            "location": "/libraries/files/#temporary-folder-sskfilestemporary", 
            "text": "getRoot()  - EFM  getPath( path )  - EFM", 
            "title": "Temporary Folder (ssk.files.temporary.*)"
        }, 
        {
            "location": "/libraries/files/#desktop-os-x-and-windows-sskfilesdesktop", 
            "text": "getDesktopRoot()  - EFM  getDesktopPath( path )  - EFM  getMyDocumentsRoot()  - EFM  getMyDocumentsPath( path )  - EFM  getDrivePath( path )  - EFM  explore( path )  - EFM", 
            "title": "Desktop (OS X and Windows) (ssk.files.desktop.*)"
        }, 
        {
            "location": "/libraries/files/#utilities-sskfilesutil", 
            "text": "exists( path )  - EFM  dumpAttributes()  - EFM  isFile( path )  - EFM  readFile( path )  - EFM  readFileToTable( path )  - EFM  writeFile( data,  path )  - EFM  appendFile( data,  path )  - EFM  rmFile( path )  - EFM  mvFile( src, dst )  - EFM  cpFile( src, dst )  - EFM  isFolder( path )  - EFM  repairPath( path, forceForward )  - EFM  rmFolder( path )  - EFM  mkFolder( path )  - EFM  mvFolder( src, dst )  - EFM  cpFolder( src, dst )  - EFM  saveTable( tbl, path, secure )  - EFM  loadTable( path, secure )  - EFM", 
            "title": "Utilities (ssk.files.util.*)"
        }, 
        {
            "location": "/libraries/files/#bonus-utilities-sskfilesutil", 
            "text": "getFilesInFolder( path )  - EFM  keepFileTypes( files, extensions )  - EFM  getLuaFiles( files )  - EFM  getResourceFiles( files )  - EFM  flattenNames( t, sep, prefix )  - EFM  findAllFiles( path )  - EFM   findFileInPath( fileToFind, folderToSearch )  - EFM    EFM  - EFM   EFM  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM   EFM EFM EFM", 
            "title": "Bonus Utilities (ssk.files.util.*)"
        }, 
        {
            "location": "/libraries/files/#capturebackbutton", 
            "text": "Syntax:  ssk.android.captureBackButton( [ noCB, [ yesCB ]] )  Summary: \nEFM EFM EFM  EFM EFM  Usage:  local onNo()\n   print( Pressed No )   \nend\n\nlocal onYes()\n   print( Pressed Yes )\nend\n\nssk.android.captureBackButton( onNo, onYes )     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "captureBackButton"
        }, 
        {
            "location": "/libraries/math2D/", 
            "text": "2D Math (ssk.math2d.*)\n\n\nSSK 2 comes with a complete library of fundamental 2D operations.\n\n\nAdditionally, if you own the \nMath2D Plugin\n, SSK can use that instead.\n\n\n\n-- Use Math2D Plugin if you own it!\n_G.ssk.init( { math2DPlugin = true } )\n\n\n\n\n\nTip:\n The paid version of the \nMath2D Plugin\n is both faster than the SSK 2 (Pure Lua) version and incorporates a number of additional features, so you should definitely check it out!\n\n\nVector Representations\n\n\nIn the context of these docs, a vector is any table or object with both an x- and a y-field.  Additionally, we often deal with vectors as discrete collections of \nx\n and \ny\n values. \n\n\n-- A table as a 2d-vector: \n 10, 15 \n\nlocal v1 = { x = 10, y = 15 } \n\n-- A circle display object; Also a 2d-vector: \n 10, 15 \n\nlocal circ = display.newCircle( 10, 15, 5 )\n\n-- Four discrete values repsenting the vectors: \n 10, 15 \n and \n -1, 0 \n\nlocal x1 = 10\nlocal y1 = 15\nlocal x2 = -1\nlocal y2 = 0\n\n\n\n\nAddition\n\n\nTable/Object Vectors\n\n\nmath2d.add( v1, v2 [, altRet ] )\n\n\n\n\nAdds two vectors \nv1\n and \nv2\n and returns a (table) vector unless \naltRet\n is \ntrue\n.  \n\n\n\n\nv1, v2 - Vectors one and two.\n\n\naltRet\n - If this is \ntrue\n, the function returns two discrete values.\n\n\n\n\nlocal circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.add( circ, rect ) -- Return a table\nprint(\nResults: \n, vec.x, vec.y )\n\nlocal vx,vy = math2d.add( circ, rect, true ) -- Return two numbers\nprint(\nResults: \n, vx, vy ) \n\n\n\n\nDiscrete Value Vectors\n\n\nmath2d.add( x1, y1, x2, y2 [, altRet ] )\n\n\n\n\nAdds two vectors \n \nx1\n, \ny1\n \n and \n \nx2\n, \ny2\n \n and returns two discrete values unless \naltRet\n is \ntrue\n.  \n\n\n\n\nx1, y1, x2, y2 - Four discrete values representing the two vectors: \n \nx1\n, \ny1\n \n and \n \nx2\n, \ny2\n \n.\n\n\naltRet\n - If this is \ntrue\n, the function returns a (table) vector.\n\n\n\n\nlocal circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vx,vy = math2d.add( circ.x, circ.y, rect.x, rect.y ) -- Return two numbers\nprint(\nResults: \n, vx, vy ) \n\nlocal vec = math2d.add( math2d.add( circ.x, circ.y, rect.x, rect.y, true ) -- Return a table\nprint(\nResults: \n, vec.x, vec.y )\n\n\n\n\nSubtraction\n\n\nTable/Object Vectors\n\n\nmath2d.sub( v1, v2 [, altRet ] )\n\n\n\n\nSubtracts vector \nv2\n from vector \nv1\n  ( \nv1\n - \nv2\n ) and returns a (table) vector unless \naltRet\n is \ntrue\n.  \n\n\nNote:\n The returned value represents a direction vector equivalent to the direction from \nv2\n to \nv1\n translated to \n 0, 0 \n.  Adding this vector to \nv2\n gives you \nv1\n.\n\n\n\n\nv1, v2 - Vectors one and two.\n\n\naltRet\n - If this is \ntrue\n, the function returns two discrete values.\n\n\n\n\nlocal circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.sub( circ, rect ) -- Return a table\nprint(\nResults: \n, vec.x, vec.y )\n\nlocal vx,vy = math2d.sub( circ, rect, true ) -- Return two numbers\nprint(\nResults: \n, vx, vy ) \n\n\n\n\nDiscrete Value Vectors\n\n\nmath2d.sub( x1, y1, x2, y2 [, altRet ] )\n\n\n\n\nSubtracts vector \n \nx2\n, \ny2\n \n from vector \n \nx1\n, \ny1\n \n ( \n \nx1\n - \nx2\n, \ny1\n - \ny2\n \n ) and returns two discrete values unless \naltRet\n is \ntrue\n.  \n\n\nNote:\n The returned value represents a direction vector equivalent to the direction from \nv2\n to \nv1\n translated to \n 0, 0 \n.  Adding this vector to \nv2\n gives you \nv1\n.\n\n\n\n\nx1, y1, x2, y2 - Four discrete values representing the two vectors: \n \nx1\n, \ny1\n \n and \n \nx2\n, \ny2\n \n.\n\n\naltRet\n - If this is \ntrue\n, the function returns a (table) vector.\n\n\n\n\nlocal x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nlocal vx,vy = math2d.sub( x1, y1, x2, y2 ) -- Return two numbers\nprint(\nResults: \n, vx, vy ) \n\nlocal vec = math2d.sub( x1, y1, x2, y2, true ) -- Return a table\nprint(\nResults: \n, vec.x, vec.y ) \n\n\n\n\nDifference\n\n\nTable/Object Vectors\n\n\nmath2d.diff( v1, v2 [, altRet ] )\n\n\n\n\nSubtracts vector \nv1\n from vector \nv2\n  ( \nv2\n - \nv1\n ) and returns a (table) vector unless \naltRet\n is \ntrue\n.  \n\n\nNote:\n The returned value represents a direction vector equivalent to the direction from \nv1\n to \nv2\n translated to \n 0, 0 \n.  Adding this vector to \nv1\n gives you \nv2\n.\n\n\n\n\nv1, v2 - Vectors one and two.\n\n\naltRet\n - If this is \ntrue\n, the function returns two discrete values.\n\n\n\n\nlocal circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.sub( circ, rect ) -- Return a table\nprint(\nResults: \n, vec.x, vec.y )\n\nlocal vx,vy = math2d.sub( circ, rect, true ) -- Return two numbers\nprint(\nResults: \n, vx, vy ) \n\n\n\n\n\nDiscrete Value Vectors\n\n\nmath2d.diff( x1, y1, x2, y2 [, altRet ] )\n\n\n\n\nSubtracts vector \n \nx1\n, \ny1\n \n from vector \n \nx2\n, \ny2\n \n ( \n \nx2\n - \nx1\n, \ny2\n - \ny1\n \n ) and returns two discrete values unless \naltRet\n is \ntrue\n.  \n\n\nNote:\n The returned value represents a direction vector equivalent to the direction from \nv1\n to \nv2\n translated to \n 0, 0 \n.  Adding this vector to \nv1\n gives you \nv2\n.\n\n\n\n\nx1, y1, x2, y2 - Four discrete values representing the two vectors: \n \nx1\n, \ny1\n \n and \n \nx2\n, \ny2\n \n.\n\n\naltRet\n - If this is \ntrue\n, the function returns a (table) vector.\n\n\n\n\nlocal x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nlocal vx,vy = math2d.sub( x1, y1, x2, y2 ) -- Return two numbers\nprint(\nResults: \n, vx, vy ) \n\nlocal vec = math2d.sub( x1, y1, x2, y2, true ) -- Return a table\nprint(\nResults: \n, vec.x, vec.y ) \n\n\n\n\nLength\n\n\nTable/Object Vectors\n\n\nmath2d.length( v1 )\n\n\n\n\nCalculates the length (magnitude) of scalar (encoded) vector.\n\n\n\n\nv1 - Vectors whose length we want to calculate.\n\n\n\n\nlocal circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.sub( circ, rect ) -- Return a table\n\nprint(\nResult: \n, math2d.length(vec) )\n\n\n\n\nDiscrete Value Vectors\n\n\nmath2d.length( x1, y1 )\n\n\n\n\nAdds two vectors \n \nx1\n, \ny1\n \n and \n \nx2\n, \ny2\n \n and returns two discrete values unless \naltRet\n is \ntrue\n.  \n\n\n\n\nx1, y1 - Two discrete values representing the vector \n \nx1\n, \ny1\n \n whose length we want to calculate.\n\n\n\n\nlocal x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nlocal vx,vy = math2d.sub( x1, y1, x2, y2 ) -- Return two numbers\n\nprint(\nResult: \n, math2d.length(vx, vy) )\n\n\n\n\nSquared Length\n\n\nTable/Object Vectors\n\n\nmath2d.length2( v1,  )\n\n\n\n\nCalculates the squared length of a vector.\n\n\n\n\nv1 - Vectors whose squared length we want to calculate.\n\n\n\n\nlocal circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.sub( circ, rect ) -- Return a table\n\nprint(\nResult: \n, math2d.length2(vec) )\n\n\n\n\nDiscrete Value Vectors\n\n\nmath2d.length2( x1, y1 )\n\n\n\n\nCalculates the squared length of a vector.\n\n\n\n\nx1, y1 - Two discrete values representing the vector \n \nx1\n, \ny1\n \n whose squared length we want to calculate.\n\n\n\n\nlocal x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nlocal vx,vy = math2d.sub( x1, y1, x2, y2 ) -- Return two numbers\n\nprint(\nResult: \n, math2d.length2(vx, vy) )\n\n\n\n\nScaling\n\n\nTable/Object Vectors\n\n\nmath2d.scale( obj, scaleBy [, altRet]  )\n\n\n\n\nMultiply \n x, y \n components of a vector by scaleBy.\n\n\n\n\nv1 - Vector we wish to scale.\n\n\naltRet\n - If this is \ntrue\n, the function returns two discrete values.\n\n\n\n\nlocal vec = { x = 1, y = 0 }\n\nvec = math2d.scale( vec, 30 ) -- Vector is now \n 30, 0 \n\n\n\n\n\nDiscrete Value Vectors\n\n\nmath2d.scale( vx, vy, scaleBy [, altRet ] )\n\n\n\n\nMultiply \nvx\n and \nvy\n components of a vector by scaleBy.\n\n\n\n\nx1, y1 - Two discrete values representing the vector \n \nx1\n, \ny1\n \n we wish to scale.\n\n\naltRet\n - If this is \ntrue\n, the function returns a table.\n\n\n\n\nlocal vx = 1, vy = 0\n\nvx, vy = math2d.scale( vx, vy, 30 ) -- Vector is now \n 30, 0 \n\n\n\n\n\nNormalizing\n\n\nTable/Object Vectors\n\n\nmath2d.normalize( v1 [, altRet ] )\n\n\n\n\nConverts the input vector into a unit length (one) vector.\n\n\n\n\nv1 - The vector we wish to normalize.\n\n\naltRet\n - If this is \ntrue\n, the function returns two discrete values.\n\n\n\n\nlocal vec = { x = 30, y = 30 }\n\nvec = math2d.normalize( vec ) -- Vector is now \n 0.707..., 0.707... \n\n\n\n\n\nDiscrete Value Vectors\n\n\nmath2d.normalize( x1, y1 [, altRet ] )\n\n\n\n\nConverts the input vector into a unit length (one) vector.\n\n\n\n\nx1, y1 - Two discrete values representing the vector \n \nx1\n, \ny1\n \n we wish to normalize.\n\n\naltRet\n - If this is \ntrue\n, the function returns a (table) vector.\n\n\n\n\nlocal vx = 30, vy = 30\n\nvx, vy = math2d.normalize( vx, vy ) -- Vector is now \n 0.707..., 0.707... \n\n\n\n\n\nDot Product\n\n\nTable/Object Vectors\n\n\nmath2d.dot( v1, v2 )\n\n\n\n\nCalculates the inner product of two vectors \nv1\n and \nv2\n and returns a scalar value.\n\n\n\n\nv1, v2 - Vectors one and two.\n\n\n\n\nlocal circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nprint(\nResult: \n, math2d.dot( circ, rect ) )\n\n\n\n\nDiscrete Value Vectors\n\n\nmath2d.dot( x1, y1, x2, y2 )\n\n\n\n\nCalculates the inner product of two vectors \n \nx1\n, \ny1\n \n and \n \nx2\n, \ny2\n \n and returns a scalar value.\n\n\n\n\nx1, y1, x2, y2 - Four discrete values representing the two vectors: \n \nx1\n, \ny1\n \n and \n \nx2\n, \ny2\n \n.\n\n\n\n\nlocal x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nprint(\nResult: \n, math2d.dot( x1, y1, x2, y2 ) )\n\n\n\n\nCross Product\n\n\nTable/Object Vectors\n\n\nmath2d.cross( v1, v2 )\n\n\n\n\nCalculates the cross product of two vectors \nv1\n and \nv2\n and returns a scalar value.\n\n\n\n\nv1, v2 - Vectors one and two.\n\n\n\n\nlocal circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nprint(\nResult: \n, math2d.cross( circ, rect ) )\n\n\n\n\nDiscrete Value Vectors\n\n\nmath2d.cross( x1, y1, x2, y2 )\n\n\n\n\nCalculates the cross product of two vectors \n \nx1\n, \ny1\n \n and \n \nx2\n, \ny2\n \n and returns a scalar value.\n\n\n\n\nx1, y1, x2, y2 - Four discrete values representing the two vectors: \n \nx1\n, \ny1\n \n and \n \nx2\n, \ny2\n \n.\n\n\n\n\nlocal x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nprint(\nResult: \n, math2d.cross( x1, y1, x2, y2 ) )\n\n\n\n\nNormals\n\n\nTable/Object Vectors\n\n\nmath2d.normals( v1 [, altRet ] )\n\n\n\n\nReturns two normal vectors \nn1\n and \nn2\n for the given vector \nv1\n unless \naltRet\n is \ntrue\n.  \n\n\nWarning:\n The returned normals are not normalized (unit length) to save computation time.\n\n\n\n\nv1 - Vector for which we want the two normal vectors.\n\n\naltRet\n - If this is \ntrue\n, the function returns four discrete values representing two vectors.\n\n\n\n\nlocal vec = { x = 1, y = 0 }\n\nlocal n1, n2 = math2d.normals( vec ) \n\n-- n1 and n2 will contain the two vectors:\n--   \n 0, -1 \n and \n 0, 1 \n (order may vary).\n\n\n\n\nDiscrete Value Vectors\n\n\nmath2d.normals( x1, y1 [, altRet ] )\n\n\n\n\nReturns two normal vectors \n \nnx1\n, \nny1\n \n and \n \nnx2\n, \nny2\n \n for the given vector \n \nx1\n, \ny1\n \n unless \naltRet\n is \ntrue\n.  \n\n\nWarning:\n The returned normals are not normalized (unit length) to save computation time.\n\n\n\n\nx1, y1 - Two discrete values representing the vector: \n \nx1\n, \ny1\n \n for which we want two normals.\n\n\naltRet\n - If this is \ntrue\n, the function returns two tables representing two vectors.\n\n\n\n\nlocal x1 = 1, y1 = 0\n\nlocal nx1, ny1, nx2, ny2 = math2d.normals( x1, y1 ) \n\n-- \n nx1, ny1 \n and \n nx2, ny2 \n will be equivalent to: \n--   \n 0, -1 \n and \n 0, 1 \n (order may vary).\n\n\n\n\nAngle To Vector\n\n\nmath2d.angle2Vector( angle [, altRet ] )\n\n\n\n\nConverts a (screen) angle into a normalized direction vector of the form \n vx, vy \n.  \n\n\nWarning:\n This library uses screen angles NOT Cartesian or polar.\n\n\n\n\nangle - Angle whose value we wish to convert to a unit length direction vector.\n\n\naltRet\n - If this is \ntrue\n, the function returns a table otherwise it returns two scalar values.\n\n\n\n\nlocal angle = 135\n\nlocal vec = math2d.angle2Vector( angle, true ) -- Return a table\nprint(\nThe vector: \n .. vec.x .. \n, \n .. vec.y  )\n\nlocal vx,vy = math2d.angle2Vector( angle ) -- Return two numbers\nprint(\nThe vector: \n .. vx .. \n, \n .. vy  )\n\n\n\n\nVector To Angle\n\n\nTable/Object Vectors\n\n\nmath2d.vector2Angle( v1 )\n\n\n\n\nTakes a table vector and returns a screen angle.\nWarning: This library uses screen angles NOT Cartesian or polar. \n\n\n\n\nv1 - Vector we wish to calculate the angle (direction) for.\n\n\n\n\nlocal circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.sub( circ, rect ) -- Return a table\n\nprint(\nResult: \n, math2d.vector2Angle(vec) )\n\n\n\n\nDiscrete Value Vectors\n\n\nmath2d.vector2Angle( vx, vy )\n\n\n\n\nTakes a two discrete values representing a vector and returns a screen angle.\n\n\n\n\nvx, vy - Two discrete values representing a vector \n \nx1\n, \ny1\n \n we wish to calculate the angle (direction) for.\n\n\n\n\nlocal x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nlocal vx,vy = math2d.sub( x1, y1, x2, y2 ) -- Return two numbers\n\nprint(\nResult: \n, math2d.vector2Angle(vx, vy) )\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.math2d.*"
        }, 
        {
            "location": "/libraries/math2D/#2d-math-sskmath2d", 
            "text": "SSK 2 comes with a complete library of fundamental 2D operations.  Additionally, if you own the  Math2D Plugin , SSK can use that instead.  \n-- Use Math2D Plugin if you own it!\n_G.ssk.init( { math2DPlugin = true } )  Tip:  The paid version of the  Math2D Plugin  is both faster than the SSK 2 (Pure Lua) version and incorporates a number of additional features, so you should definitely check it out!", 
            "title": "2D Math (ssk.math2d.*)"
        }, 
        {
            "location": "/libraries/math2D/#vector-representations", 
            "text": "In the context of these docs, a vector is any table or object with both an x- and a y-field.  Additionally, we often deal with vectors as discrete collections of  x  and  y  values.   -- A table as a 2d-vector:   10, 15  \nlocal v1 = { x = 10, y = 15 } \n\n-- A circle display object; Also a 2d-vector:   10, 15  \nlocal circ = display.newCircle( 10, 15, 5 )\n\n-- Four discrete values repsenting the vectors:   10, 15   and   -1, 0  \nlocal x1 = 10\nlocal y1 = 15\nlocal x2 = -1\nlocal y2 = 0", 
            "title": "Vector Representations"
        }, 
        {
            "location": "/libraries/math2D/#addition", 
            "text": "", 
            "title": "Addition"
        }, 
        {
            "location": "/libraries/math2D/#tableobject-vectors", 
            "text": "math2d.add( v1, v2 [, altRet ] )  Adds two vectors  v1  and  v2  and returns a (table) vector unless  altRet  is  true .     v1, v2 - Vectors one and two.  altRet  - If this is  true , the function returns two discrete values.   local circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.add( circ, rect ) -- Return a table\nprint( Results:  , vec.x, vec.y )\n\nlocal vx,vy = math2d.add( circ, rect, true ) -- Return two numbers\nprint( Results:  , vx, vy )", 
            "title": "Table/Object Vectors"
        }, 
        {
            "location": "/libraries/math2D/#discrete-value-vectors", 
            "text": "math2d.add( x1, y1, x2, y2 [, altRet ] )  Adds two vectors    x1 ,  y1    and    x2 ,  y2    and returns two discrete values unless  altRet  is  true .     x1, y1, x2, y2 - Four discrete values representing the two vectors:    x1 ,  y1    and    x2 ,  y2   .  altRet  - If this is  true , the function returns a (table) vector.   local circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vx,vy = math2d.add( circ.x, circ.y, rect.x, rect.y ) -- Return two numbers\nprint( Results:  , vx, vy ) \n\nlocal vec = math2d.add( math2d.add( circ.x, circ.y, rect.x, rect.y, true ) -- Return a table\nprint( Results:  , vec.x, vec.y )", 
            "title": "Discrete Value Vectors"
        }, 
        {
            "location": "/libraries/math2D/#subtraction", 
            "text": "", 
            "title": "Subtraction"
        }, 
        {
            "location": "/libraries/math2D/#tableobject-vectors_1", 
            "text": "math2d.sub( v1, v2 [, altRet ] )  Subtracts vector  v2  from vector  v1   (  v1  -  v2  ) and returns a (table) vector unless  altRet  is  true .    Note:  The returned value represents a direction vector equivalent to the direction from  v2  to  v1  translated to   0, 0  .  Adding this vector to  v2  gives you  v1 .   v1, v2 - Vectors one and two.  altRet  - If this is  true , the function returns two discrete values.   local circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.sub( circ, rect ) -- Return a table\nprint( Results:  , vec.x, vec.y )\n\nlocal vx,vy = math2d.sub( circ, rect, true ) -- Return two numbers\nprint( Results:  , vx, vy )", 
            "title": "Table/Object Vectors"
        }, 
        {
            "location": "/libraries/math2D/#discrete-value-vectors_1", 
            "text": "math2d.sub( x1, y1, x2, y2 [, altRet ] )  Subtracts vector    x2 ,  y2    from vector    x1 ,  y1    (    x1  -  x2 ,  y1  -  y2    ) and returns two discrete values unless  altRet  is  true .    Note:  The returned value represents a direction vector equivalent to the direction from  v2  to  v1  translated to   0, 0  .  Adding this vector to  v2  gives you  v1 .   x1, y1, x2, y2 - Four discrete values representing the two vectors:    x1 ,  y1    and    x2 ,  y2   .  altRet  - If this is  true , the function returns a (table) vector.   local x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nlocal vx,vy = math2d.sub( x1, y1, x2, y2 ) -- Return two numbers\nprint( Results:  , vx, vy ) \n\nlocal vec = math2d.sub( x1, y1, x2, y2, true ) -- Return a table\nprint( Results:  , vec.x, vec.y )", 
            "title": "Discrete Value Vectors"
        }, 
        {
            "location": "/libraries/math2D/#difference", 
            "text": "", 
            "title": "Difference"
        }, 
        {
            "location": "/libraries/math2D/#tableobject-vectors_2", 
            "text": "math2d.diff( v1, v2 [, altRet ] )  Subtracts vector  v1  from vector  v2   (  v2  -  v1  ) and returns a (table) vector unless  altRet  is  true .    Note:  The returned value represents a direction vector equivalent to the direction from  v1  to  v2  translated to   0, 0  .  Adding this vector to  v1  gives you  v2 .   v1, v2 - Vectors one and two.  altRet  - If this is  true , the function returns two discrete values.   local circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.sub( circ, rect ) -- Return a table\nprint( Results:  , vec.x, vec.y )\n\nlocal vx,vy = math2d.sub( circ, rect, true ) -- Return two numbers\nprint( Results:  , vx, vy )", 
            "title": "Table/Object Vectors"
        }, 
        {
            "location": "/libraries/math2D/#discrete-value-vectors_2", 
            "text": "math2d.diff( x1, y1, x2, y2 [, altRet ] )  Subtracts vector    x1 ,  y1    from vector    x2 ,  y2    (    x2  -  x1 ,  y2  -  y1    ) and returns two discrete values unless  altRet  is  true .    Note:  The returned value represents a direction vector equivalent to the direction from  v1  to  v2  translated to   0, 0  .  Adding this vector to  v1  gives you  v2 .   x1, y1, x2, y2 - Four discrete values representing the two vectors:    x1 ,  y1    and    x2 ,  y2   .  altRet  - If this is  true , the function returns a (table) vector.   local x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nlocal vx,vy = math2d.sub( x1, y1, x2, y2 ) -- Return two numbers\nprint( Results:  , vx, vy ) \n\nlocal vec = math2d.sub( x1, y1, x2, y2, true ) -- Return a table\nprint( Results:  , vec.x, vec.y )", 
            "title": "Discrete Value Vectors"
        }, 
        {
            "location": "/libraries/math2D/#length", 
            "text": "", 
            "title": "Length"
        }, 
        {
            "location": "/libraries/math2D/#tableobject-vectors_3", 
            "text": "math2d.length( v1 )  Calculates the length (magnitude) of scalar (encoded) vector.   v1 - Vectors whose length we want to calculate.   local circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.sub( circ, rect ) -- Return a table\n\nprint( Result:  , math2d.length(vec) )", 
            "title": "Table/Object Vectors"
        }, 
        {
            "location": "/libraries/math2D/#discrete-value-vectors_3", 
            "text": "math2d.length( x1, y1 )  Adds two vectors    x1 ,  y1    and    x2 ,  y2    and returns two discrete values unless  altRet  is  true .     x1, y1 - Two discrete values representing the vector    x1 ,  y1    whose length we want to calculate.   local x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nlocal vx,vy = math2d.sub( x1, y1, x2, y2 ) -- Return two numbers\n\nprint( Result:  , math2d.length(vx, vy) )", 
            "title": "Discrete Value Vectors"
        }, 
        {
            "location": "/libraries/math2D/#squared-length", 
            "text": "", 
            "title": "Squared Length"
        }, 
        {
            "location": "/libraries/math2D/#tableobject-vectors_4", 
            "text": "math2d.length2( v1,  )  Calculates the squared length of a vector.   v1 - Vectors whose squared length we want to calculate.   local circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.sub( circ, rect ) -- Return a table\n\nprint( Result:  , math2d.length2(vec) )", 
            "title": "Table/Object Vectors"
        }, 
        {
            "location": "/libraries/math2D/#discrete-value-vectors_4", 
            "text": "math2d.length2( x1, y1 )  Calculates the squared length of a vector.   x1, y1 - Two discrete values representing the vector    x1 ,  y1    whose squared length we want to calculate.   local x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nlocal vx,vy = math2d.sub( x1, y1, x2, y2 ) -- Return two numbers\n\nprint( Result:  , math2d.length2(vx, vy) )", 
            "title": "Discrete Value Vectors"
        }, 
        {
            "location": "/libraries/math2D/#scaling", 
            "text": "", 
            "title": "Scaling"
        }, 
        {
            "location": "/libraries/math2D/#tableobject-vectors_5", 
            "text": "math2d.scale( obj, scaleBy [, altRet]  )  Multiply   x, y   components of a vector by scaleBy.   v1 - Vector we wish to scale.  altRet  - If this is  true , the function returns two discrete values.   local vec = { x = 1, y = 0 }\n\nvec = math2d.scale( vec, 30 ) -- Vector is now   30, 0", 
            "title": "Table/Object Vectors"
        }, 
        {
            "location": "/libraries/math2D/#discrete-value-vectors_5", 
            "text": "math2d.scale( vx, vy, scaleBy [, altRet ] )  Multiply  vx  and  vy  components of a vector by scaleBy.   x1, y1 - Two discrete values representing the vector    x1 ,  y1    we wish to scale.  altRet  - If this is  true , the function returns a table.   local vx = 1, vy = 0\n\nvx, vy = math2d.scale( vx, vy, 30 ) -- Vector is now   30, 0", 
            "title": "Discrete Value Vectors"
        }, 
        {
            "location": "/libraries/math2D/#normalizing", 
            "text": "", 
            "title": "Normalizing"
        }, 
        {
            "location": "/libraries/math2D/#tableobject-vectors_6", 
            "text": "math2d.normalize( v1 [, altRet ] )  Converts the input vector into a unit length (one) vector.   v1 - The vector we wish to normalize.  altRet  - If this is  true , the function returns two discrete values.   local vec = { x = 30, y = 30 }\n\nvec = math2d.normalize( vec ) -- Vector is now   0.707..., 0.707...", 
            "title": "Table/Object Vectors"
        }, 
        {
            "location": "/libraries/math2D/#discrete-value-vectors_6", 
            "text": "math2d.normalize( x1, y1 [, altRet ] )  Converts the input vector into a unit length (one) vector.   x1, y1 - Two discrete values representing the vector    x1 ,  y1    we wish to normalize.  altRet  - If this is  true , the function returns a (table) vector.   local vx = 30, vy = 30\n\nvx, vy = math2d.normalize( vx, vy ) -- Vector is now   0.707..., 0.707...", 
            "title": "Discrete Value Vectors"
        }, 
        {
            "location": "/libraries/math2D/#dot-product", 
            "text": "", 
            "title": "Dot Product"
        }, 
        {
            "location": "/libraries/math2D/#tableobject-vectors_7", 
            "text": "math2d.dot( v1, v2 )  Calculates the inner product of two vectors  v1  and  v2  and returns a scalar value.   v1, v2 - Vectors one and two.   local circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nprint( Result:  , math2d.dot( circ, rect ) )", 
            "title": "Table/Object Vectors"
        }, 
        {
            "location": "/libraries/math2D/#discrete-value-vectors_7", 
            "text": "math2d.dot( x1, y1, x2, y2 )  Calculates the inner product of two vectors    x1 ,  y1    and    x2 ,  y2    and returns a scalar value.   x1, y1, x2, y2 - Four discrete values representing the two vectors:    x1 ,  y1    and    x2 ,  y2   .   local x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nprint( Result:  , math2d.dot( x1, y1, x2, y2 ) )", 
            "title": "Discrete Value Vectors"
        }, 
        {
            "location": "/libraries/math2D/#cross-product", 
            "text": "", 
            "title": "Cross Product"
        }, 
        {
            "location": "/libraries/math2D/#tableobject-vectors_8", 
            "text": "math2d.cross( v1, v2 )  Calculates the cross product of two vectors  v1  and  v2  and returns a scalar value.   v1, v2 - Vectors one and two.   local circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nprint( Result:  , math2d.cross( circ, rect ) )", 
            "title": "Table/Object Vectors"
        }, 
        {
            "location": "/libraries/math2D/#discrete-value-vectors_8", 
            "text": "math2d.cross( x1, y1, x2, y2 )  Calculates the cross product of two vectors    x1 ,  y1    and    x2 ,  y2    and returns a scalar value.   x1, y1, x2, y2 - Four discrete values representing the two vectors:    x1 ,  y1    and    x2 ,  y2   .   local x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nprint( Result:  , math2d.cross( x1, y1, x2, y2 ) )", 
            "title": "Discrete Value Vectors"
        }, 
        {
            "location": "/libraries/math2D/#normals", 
            "text": "", 
            "title": "Normals"
        }, 
        {
            "location": "/libraries/math2D/#tableobject-vectors_9", 
            "text": "math2d.normals( v1 [, altRet ] )  Returns two normal vectors  n1  and  n2  for the given vector  v1  unless  altRet  is  true .    Warning:  The returned normals are not normalized (unit length) to save computation time.   v1 - Vector for which we want the two normal vectors.  altRet  - If this is  true , the function returns four discrete values representing two vectors.   local vec = { x = 1, y = 0 }\n\nlocal n1, n2 = math2d.normals( vec ) \n\n-- n1 and n2 will contain the two vectors:\n--     0, -1   and   0, 1   (order may vary).", 
            "title": "Table/Object Vectors"
        }, 
        {
            "location": "/libraries/math2D/#discrete-value-vectors_9", 
            "text": "math2d.normals( x1, y1 [, altRet ] )  Returns two normal vectors    nx1 ,  ny1    and    nx2 ,  ny2    for the given vector    x1 ,  y1    unless  altRet  is  true .    Warning:  The returned normals are not normalized (unit length) to save computation time.   x1, y1 - Two discrete values representing the vector:    x1 ,  y1    for which we want two normals.  altRet  - If this is  true , the function returns two tables representing two vectors.   local x1 = 1, y1 = 0\n\nlocal nx1, ny1, nx2, ny2 = math2d.normals( x1, y1 ) \n\n--   nx1, ny1   and   nx2, ny2   will be equivalent to: \n--     0, -1   and   0, 1   (order may vary).", 
            "title": "Discrete Value Vectors"
        }, 
        {
            "location": "/libraries/math2D/#angle-to-vector", 
            "text": "math2d.angle2Vector( angle [, altRet ] )  Converts a (screen) angle into a normalized direction vector of the form   vx, vy  .    Warning:  This library uses screen angles NOT Cartesian or polar.   angle - Angle whose value we wish to convert to a unit length direction vector.  altRet  - If this is  true , the function returns a table otherwise it returns two scalar values.   local angle = 135\n\nlocal vec = math2d.angle2Vector( angle, true ) -- Return a table\nprint( The vector:   .. vec.x ..  ,   .. vec.y  )\n\nlocal vx,vy = math2d.angle2Vector( angle ) -- Return two numbers\nprint( The vector:   .. vx ..  ,   .. vy  )", 
            "title": "Angle To Vector"
        }, 
        {
            "location": "/libraries/math2D/#vector-to-angle", 
            "text": "", 
            "title": "Vector To Angle"
        }, 
        {
            "location": "/libraries/math2D/#tableobject-vectors_10", 
            "text": "math2d.vector2Angle( v1 )  Takes a table vector and returns a screen angle.\nWarning: This library uses screen angles NOT Cartesian or polar.    v1 - Vector we wish to calculate the angle (direction) for.   local circ = display.newCircle( 100, 100, 30 )\nlocal rect = display.newRect( 150, 250, 60, 60 )\n\nlocal vec = math2d.sub( circ, rect ) -- Return a table\n\nprint( Result:  , math2d.vector2Angle(vec) )", 
            "title": "Table/Object Vectors"
        }, 
        {
            "location": "/libraries/math2D/#discrete-value-vectors_10", 
            "text": "math2d.vector2Angle( vx, vy )  Takes a two discrete values representing a vector and returns a screen angle.   vx, vy - Two discrete values representing a vector    x1 ,  y1    we wish to calculate the angle (direction) for.   local x1,y1 = 10,10\nlocal x2,y2 = 15,-10\n\nlocal vx,vy = math2d.sub( x1, y1, x2, y2 ) -- Return two numbers\n\nprint( Result:  , math2d.vector2Angle(vx, vy) )     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Discrete Value Vectors"
        }, 
        {
            "location": "/libraries/misc/", 
            "text": "Miscellaneous (ssk.misc.*)\n\n\nThis is a grab bag of functions that simply didn't fit anywhere else.  \n\n\nHaving said that, I find many of these functions to be indispensable and I think you will too.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nblockTouchesForDuration\n\n\ncreateEasyMeter\n\n\ncountLocals\n\n\n\n\n\n\neasyAlert\n\n\neasyBlur\n\n\neasyRemoteImage\n\n\n\n\n\n\neasyShake\n\n\neasyUnderline\n\n\nfitText\n\n\n\n\n\n\ngetImageSize\n\n\nisConnectedToWWW\n\n\nisValidEmail\n\n\n\n\n\n\noBottom\n\n\noHorizCenter\n\n\noLeft\n\n\n\n\n\n\noRight\n\n\noTop\n\n\noVertCenter\n\n\n\n\n\n\nrotateAbout\n\n\nsecondsToTimer\n\n\n\n\n\n\n\n\n\n\n\n\nblockTouchesForDuration( [ duration [ , subtle ] ] )\n - Creates a temporary display object that will block all touches for \nduration\n (\n1000\n).      \n\n\nBy default, the blocker is black and up-fades from 0% to 50% opaque over 350 ms.  However, if you want to hide this effect, set subtle to \ntrue\n.\n\n\n\n\n\n\n\n\n\n\n\n\ncreateEasyMeter( [ x , [ y, [ width, [ fontSize ] ] ] ] )\n - Creates a memory + texture memory meter in the middle of the screen.  You can place it elsewhere and change the size by supplying values for the parameters.\n\n\n\n\n\n\n\n\ncountLocals()\n - This debug feature prints out the number of local variables that are in scope at the line where you call the function.  \n\n\nLua has a limit of 200 locals in scope at any one time.  This function lets you check for how close you are.\n\n\nOnly works in simulator since it requires the 'debug' library which is not included on devices.\n\n\n\n\n\n\n\n\n\n\n\n\neasyAlert( title, msg, buttons )\n - A simplified 'dialog' builder that uses \nnative.showAlert()\n to create a pop-up dialog.  \n\n\ntitle\n - Text at top of dialog box.  \n\n\nmsg\n - Body of message.  Multiple lines and line-breaks (\n\\n\n) allowed.\n\n\nbuttons - Table of buttons and optional functions they call when pressed.\n\n\n\n\n\n\n\n\n\nlocal function doDelete()\n    -- Delete the player.\nend\n\neasyAlert( \nDelete Player\n, \n            \nAre you sure you want to delete this player?\n,\n             { { \nYes!\n, doDelete }, {\nNever Mind\n, nil } } )\n\n\n\n\n\n\n\n\n\neasyBlur( [ group, [ time, [ color, [ params ] ] ]  )\n - Create a display object that is a blurred image of what was on the screen when this function was called.\n\n\ngroup\n (\ndisplay.currentStage\n) - Insert blur object into this group.\n\n\ntime\n (\n0\n) - Time it takes (in millseconds) for the blur to fade in from \nalpha == 0\n.\n\n\ncolor\n (\n{0.5,0.5,0.5}\n) - Shade blur object with this fill color.\n\n\nparams\n (\n{ touchEn = true }\n) - Table of additional options.\n\n\ntouchEn\n - If \ntrue\n, touching the screen will fade the blur object our over \ntime\n then delete it.\n\n\nonComplete( obj )\n - Reference to custom function that is called when blur is about to be removed.\n\n\nblurGaussian\n properties.  The blur uses this filter and you can adjust all of its properties if you want.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\neasyRemoteImage( curImg, fileName, imageURL, baseDirectory )\n - With this function you can fill an existing display object with a remote image.  You simply call this function and when the download is complete, the existing \ncurImg\n object will be filled with the remote image file.  \n\n\ncurImg\n - Display object to be filled with remote image.  \n\n\nTip:\n I usually fill this object with a local placeholder image so it looks professional till the image is received.\n\n\n\n\n\n\nfileName\n - Name to save image in.\n\n\nimageURL\n - Web path to image.\n\n\nbaseDirectory\n (\nsystem.TemporaryDirectory\n) - Base type of directory.\n\n\n\n\n\n\n\n\n\n\n\n\neasyShake( obj, amplitude, time )\n - Shake any object of the entire screen.  Nice juicy effect!\n\n\nobj\n (\ndisplay.currentStage\n) - Object or group to shake.\n\n\namplitude\n (\n100\n) - How much to shake.\n\n\ntime\n (\n1000\n) - How long to shake for.\n\n\nCredit: http://forums.coronalabs.com/topic/53736-simple-shake-easing-code-and-demo/\n\n\n\n\n\n\n\n\n\n\n\n\neasyUnderline( obj, [ color, [ strokeWidth, [ extraWidth, [ yOffset ]]]] )\n - Draw a line under any object. I use this for text objects mostly.\n\n\nobj\n - Object to 'underline'.  Line length is automatically as wide as this object.\n\n\ncolor\n (\n_W_\n) - Color of line.\n\n\nstrokeWidth\n (\n1\n) - Stroke width of line.   \n\n\nextraWidth\n (\n0\n) - Make the line longer by this many pixels.\n\n\nyOffset\n (\n0\n) - Adjust the calculated y-position by this many pixels.  By default, the line is aligned to the bottom edge of the display object \nobj\n.\n\n\n\n\n\n\n\n\n\n\n\n\nfitText( obj, origText, maxWidth )\n - Reduces the length of a string till the text object \nobj\n fits \nmaxWidth\n (pixels). \norigText\n is the initial string value of \nobj\n.\n\n\n\n\n\n\n\n\ngetImageSize ( path [ , basePath ] )\n - Returns \nwidth\n, \nheight\n of an image.\n\n\npath\n - File name path including name of file.\n\n\nbasePath\n (\nsystem.ResourceDirectory\n) - Base type of file path.\n\n\n\n\n\n\n\n\n\n\n\n\nisConnectedToWWW( [url] )\n - Checks to see if \nurl\n can be reached.  Default is \n\"www.google.com\"\n\n\n\n\n\n\n\n\nisValidEmail ( val )\n - Returns true if \nval\n \nseems\n like a valid email address.\n\n\n\n\n\n\nTip:\n The following x-/y- position finders do not care what the anchors are.\n\n\n\n\noBottom( obj )\n - Returns pixel y-position object \nobj\n bottom.\n\n\noHorizCenter( obj )\n - Returns pixel x-position of object \nobj\n center.\n\n\noLeft( obj )\n - Returns pixel x-position of object \nobj\n left.\n\n\noRight( obj )\n - Returns pixel x-position of object \nobj\n right.\n\n\noTop( obj )\n - Returns pixel y-position of object \nobj\n top.\n\n\noVertCenter( obj )\n - Returns pixel y-position of object \nobj\n center.\n\n\n\n\n\n\n\n\nrotateAbout( obj, [ x, [ y, [ params ]]] )\n - Rotate object \nobj\n about the position \n \nx\n, \ny\n \n.\n\n\nobj\n - Object to rotate about a point.\n\n\nx\n, \ny\n (\ncenterX\n, \ncenterY\n) - The point.\n\n\nparams\n - Table of options controlling the rotate:\n\n\nradius\n (\n50\n) - Radius of rotation path.\n\n\nstartA\n (\n0\n) - Start at this rotation angle, where \n0\n is up, \n90\n is right, etc.\n\n\nendA\n (\nstartA + 360\n) - End at this rotation angle.\n\n\ntime\n (\n1000\n) - Take this long to rotate.\n\n\ndelay\n (\n0\n) - Wait this long to start rotating.\n\n\nmyEasing\n (\neasing.linear\n) - Use this transition easing.\n\n\ndebugEn\n (\nfalse\n) - Draw circles along path as rotation occurs.\n\n\nonComplete( obj )\n (\nnil\n) - Call this function when the rotation completes.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsecondsToTimer( [ seconds, [ version ] ] )\n - Converts \nseconds\n into one of three different time formats.\n\n\nseconds\n (\n0\n) - Count of seconds to convert to a timer format.\n\n\nseconds\n (\n1\n) - Timer format to produce.\n\n\n1\n - Return string with this format: \n\"minutes:seconds\"\n\n\n2\n - Return string with this format: \n\"hours:minutes.seconds\"\n\n\n3\n - Return four strings: \n\"days\"\n, \n\"hours\"\n, \n\"minutes\"\n, \n\"seconds\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.misc.*"
        }, 
        {
            "location": "/libraries/misc/#miscellaneous-sskmisc", 
            "text": "This is a grab bag of functions that simply didn't fit anywhere else.    Having said that, I find many of these functions to be indispensable and I think you will too.            blockTouchesForDuration  createEasyMeter  countLocals    easyAlert  easyBlur  easyRemoteImage    easyShake  easyUnderline  fitText    getImageSize  isConnectedToWWW  isValidEmail    oBottom  oHorizCenter  oLeft    oRight  oTop  oVertCenter    rotateAbout  secondsToTimer       blockTouchesForDuration( [ duration [ , subtle ] ] )  - Creates a temporary display object that will block all touches for  duration  ( 1000 ).        By default, the blocker is black and up-fades from 0% to 50% opaque over 350 ms.  However, if you want to hide this effect, set subtle to  true .       createEasyMeter( [ x , [ y, [ width, [ fontSize ] ] ] ] )  - Creates a memory + texture memory meter in the middle of the screen.  You can place it elsewhere and change the size by supplying values for the parameters.     countLocals()  - This debug feature prints out the number of local variables that are in scope at the line where you call the function.    Lua has a limit of 200 locals in scope at any one time.  This function lets you check for how close you are.  Only works in simulator since it requires the 'debug' library which is not included on devices.       easyAlert( title, msg, buttons )  - A simplified 'dialog' builder that uses  native.showAlert()  to create a pop-up dialog.    title  - Text at top of dialog box.    msg  - Body of message.  Multiple lines and line-breaks ( \\n ) allowed.  buttons - Table of buttons and optional functions they call when pressed.     \nlocal function doDelete()\n    -- Delete the player.\nend\n\neasyAlert(  Delete Player , \n             Are you sure you want to delete this player? ,\n             { {  Yes! , doDelete }, { Never Mind , nil } } )    easyBlur( [ group, [ time, [ color, [ params ] ] ]  )  - Create a display object that is a blurred image of what was on the screen when this function was called.  group  ( display.currentStage ) - Insert blur object into this group.  time  ( 0 ) - Time it takes (in millseconds) for the blur to fade in from  alpha == 0 .  color  ( {0.5,0.5,0.5} ) - Shade blur object with this fill color.  params  ( { touchEn = true } ) - Table of additional options.  touchEn  - If  true , touching the screen will fade the blur object our over  time  then delete it.  onComplete( obj )  - Reference to custom function that is called when blur is about to be removed.  blurGaussian  properties.  The blur uses this filter and you can adjust all of its properties if you want.         easyRemoteImage( curImg, fileName, imageURL, baseDirectory )  - With this function you can fill an existing display object with a remote image.  You simply call this function and when the download is complete, the existing  curImg  object will be filled with the remote image file.    curImg  - Display object to be filled with remote image.    Tip:  I usually fill this object with a local placeholder image so it looks professional till the image is received.    fileName  - Name to save image in.  imageURL  - Web path to image.  baseDirectory  ( system.TemporaryDirectory ) - Base type of directory.       easyShake( obj, amplitude, time )  - Shake any object of the entire screen.  Nice juicy effect!  obj  ( display.currentStage ) - Object or group to shake.  amplitude  ( 100 ) - How much to shake.  time  ( 1000 ) - How long to shake for.  Credit: http://forums.coronalabs.com/topic/53736-simple-shake-easing-code-and-demo/       easyUnderline( obj, [ color, [ strokeWidth, [ extraWidth, [ yOffset ]]]] )  - Draw a line under any object. I use this for text objects mostly.  obj  - Object to 'underline'.  Line length is automatically as wide as this object.  color  ( _W_ ) - Color of line.  strokeWidth  ( 1 ) - Stroke width of line.     extraWidth  ( 0 ) - Make the line longer by this many pixels.  yOffset  ( 0 ) - Adjust the calculated y-position by this many pixels.  By default, the line is aligned to the bottom edge of the display object  obj .       fitText( obj, origText, maxWidth )  - Reduces the length of a string till the text object  obj  fits  maxWidth  (pixels).  origText  is the initial string value of  obj .     getImageSize ( path [ , basePath ] )  - Returns  width ,  height  of an image.  path  - File name path including name of file.  basePath  ( system.ResourceDirectory ) - Base type of file path.       isConnectedToWWW( [url] )  - Checks to see if  url  can be reached.  Default is  \"www.google.com\"     isValidEmail ( val )  - Returns true if  val   seems  like a valid email address.    Tip:  The following x-/y- position finders do not care what the anchors are.   oBottom( obj )  - Returns pixel y-position object  obj  bottom.  oHorizCenter( obj )  - Returns pixel x-position of object  obj  center.  oLeft( obj )  - Returns pixel x-position of object  obj  left.  oRight( obj )  - Returns pixel x-position of object  obj  right.  oTop( obj )  - Returns pixel y-position of object  obj  top.  oVertCenter( obj )  - Returns pixel y-position of object  obj  center.     rotateAbout( obj, [ x, [ y, [ params ]]] )  - Rotate object  obj  about the position    x ,  y   .  obj  - Object to rotate about a point.  x ,  y  ( centerX ,  centerY ) - The point.  params  - Table of options controlling the rotate:  radius  ( 50 ) - Radius of rotation path.  startA  ( 0 ) - Start at this rotation angle, where  0  is up,  90  is right, etc.  endA  ( startA + 360 ) - End at this rotation angle.  time  ( 1000 ) - Take this long to rotate.  delay  ( 0 ) - Wait this long to start rotating.  myEasing  ( easing.linear ) - Use this transition easing.  debugEn  ( false ) - Draw circles along path as rotation occurs.  onComplete( obj )  ( nil ) - Call this function when the rotation completes.         secondsToTimer( [ seconds, [ version ] ] )  - Converts  seconds  into one of three different time formats.  seconds  ( 0 ) - Count of seconds to convert to a timer format.  seconds  ( 1 ) - Timer format to produce.  1  - Return string with this format:  \"minutes:seconds\"  2  - Return string with this format:  \"hours:minutes.seconds\"  3  - Return four strings:  \"days\" ,  \"hours\" ,  \"minutes\" ,  \"seconds\"          Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Miscellaneous (ssk.misc.*)"
        }, 
        {
            "location": "/libraries/persist/", 
            "text": "Easy Persistance (ssk.persist.*)\n\n\n\n\nsetSecure()\n - EFM\n\n\nget( fileName, fieldName, params )\n - EFM\n\n\nset( fileName, fieldName, value, params )\n - EFM\n\n\n\n\nsetDefault( fileName, fieldName, value, params )\n - EFM\n\n\n\n\n\n\nEFM\n - EFM\n\n\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\n\n\nEFM EFM EFM\n\n\ncaptureBackButton\n\n\nSyntax:\n\n\nssk.android.captureBackButton( [ noCB, [ yesCB ]] )\n\n\n\n\nSummary:\n\nEFM EFM EFM\n\n\nEFM EFM\n\n\nUsage:\n\n\nlocal onNo()\n   print(\nPressed No\n)   \nend\n\nlocal onYes()\n   print(\nPressed Yes\n)\nend\n\nssk.android.captureBackButton( onNo, onYes )\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.persist.*"
        }, 
        {
            "location": "/libraries/persist/#easy-persistance-sskpersist", 
            "text": "setSecure()  - EFM  get( fileName, fieldName, params )  - EFM  set( fileName, fieldName, value, params )  - EFM   setDefault( fileName, fieldName, value, params )  - EFM    EFM  - EFM   EFM  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM   EFM EFM EFM", 
            "title": "Easy Persistance (ssk.persist.*)"
        }, 
        {
            "location": "/libraries/persist/#capturebackbutton", 
            "text": "Syntax:  ssk.android.captureBackButton( [ noCB, [ yesCB ]] )  Summary: \nEFM EFM EFM  EFM EFM  Usage:  local onNo()\n   print( Pressed No )   \nend\n\nlocal onYes()\n   print( Pressed Yes )\nend\n\nssk.android.captureBackButton( onNo, onYes )     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "captureBackButton"
        }, 
        {
            "location": "/libraries/points/", 
            "text": "Points Library (ssk.points.*)\n\n\n\n\n\n\nnew( ... )\n - EFM\n\n\n\n\nadd(...)\n - EFM\n\n\ninsert(index, ...)\n - EFM\n\n\nget(index)\n - EFM\n\n\nremove(index)\n - EFM\n\n\npush(...)\n - EFM\n\n\npeek()\n - EFM\n\n\npop()\n - EFM\n\n\nh_head(...)\n - Treats points list like a queue/FIFO and pushes one or more point sets (in reverse order) onto the points list front. Like calling insert(1, x1,y1), insert(1, x2,y2), ..., insert(1, xN,yN), \n\n\npeek_head()\n - Treats points list like a queue/FIFO and retrieves the point at the front of the points list. Like a get at 1.\n\n\npop_head(x,y)\n - Treats points list like a queue/FIFO and pops the point at the front off the points list. Like a remove at 1.\n\n\n\n\n\n\n\n\nEFM\n - EFM\n\n\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\nEFM\n - EFM\n\n\n\n\nEFM EFM EFM\n\n\ncaptureBackButton\n\n\nSyntax:\n\n\nssk.android.captureBackButton( [ noCB, [ yesCB ]] )\n\n\n\n\nSummary:\n\nEFM EFM EFM\n\n\nEFM EFM\n\n\nUsage:\n\n\nlocal onNo()\n   print(\nPressed No\n)   \nend\n\nlocal onYes()\n   print(\nPressed Yes\n)\nend\n\nssk.android.captureBackButton( onNo, onYes )\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.points.*"
        }, 
        {
            "location": "/libraries/points/#points-library-sskpoints", 
            "text": "new( ... )  - EFM   add(...)  - EFM  insert(index, ...)  - EFM  get(index)  - EFM  remove(index)  - EFM  push(...)  - EFM  peek()  - EFM  pop()  - EFM  h_head(...)  - Treats points list like a queue/FIFO and pushes one or more point sets (in reverse order) onto the points list front. Like calling insert(1, x1,y1), insert(1, x2,y2), ..., insert(1, xN,yN),   peek_head()  - Treats points list like a queue/FIFO and retrieves the point at the front of the points list. Like a get at 1.  pop_head(x,y)  - Treats points list like a queue/FIFO and pops the point at the front off the points list. Like a remove at 1.     EFM  - EFM   EFM  - EFM  EFM  - EFM  EFM  - EFM  EFM  - EFM   EFM EFM EFM", 
            "title": "Points Library (ssk.points.*)"
        }, 
        {
            "location": "/libraries/points/#capturebackbutton", 
            "text": "Syntax:  ssk.android.captureBackButton( [ noCB, [ yesCB ]] )  Summary: \nEFM EFM EFM  EFM EFM  Usage:  local onNo()\n   print( Pressed No )   \nend\n\nlocal onYes()\n   print( Pressed Yes )\nend\n\nssk.android.captureBackButton( onNo, onYes )     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "captureBackButton"
        }, 
        {
            "location": "/libraries/security/", 
            "text": "ssk.android.*\n\n\nEFM EFM EFM\n\n\ncaptureBackButton\n\n\nSyntax:\n\n\nssk.android.captureBackButton( [ noCB, [ yesCB ]] )\n\n\n\n\nSummary:\n\nEFM EFM EFM\n\n\nEFM EFM\n\n\nUsage:\n\n\nlocal onNo()\n   print(\nPressed No\n)   \nend\n\nlocal onYes()\n   print(\nPressed Yes\n)\nend\n\nssk.android.captureBackButton( onNo, onYes )\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.security.*"
        }, 
        {
            "location": "/libraries/security/#sskandroid", 
            "text": "EFM EFM EFM", 
            "title": "ssk.android.*"
        }, 
        {
            "location": "/libraries/security/#capturebackbutton", 
            "text": "Syntax:  ssk.android.captureBackButton( [ noCB, [ yesCB ]] )  Summary: \nEFM EFM EFM  EFM EFM  Usage:  local onNo()\n   print( Pressed No )   \nend\n\nlocal onYes()\n   print( Pressed Yes )\nend\n\nssk.android.captureBackButton( onNo, onYes )     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "captureBackButton"
        }, 
        {
            "location": "/libraries/social/", 
            "text": "ssk.easySocial.*\n\n\nThis module contains a couple 'helper' functions to simplify sharing and rating apps.\n\n\nrate\n\n\nOpen rate interface in appropriate store for app identified \nid\n.\n\n\nssk.easySocial.rate( id )\n\n\n\n\n\n\nid\n - A platform specific ID for the platform you want to rate on.\n\n\n\n\nExample:\n\n\n\n-- Rate Sudoku For.. game on Android  or iOS\nif( onAndroid ) then\n\n   ssk.easySocial.rate( 'com.roaminggamer.sudoku4' ) -- Google Play ID\n\nelseif( oniOS ) then\n\n   ssk.easySocial.rate( '1150939979' ) -- iTunes Connect ID\n\nend\n\n\n\n\n\nshare\n\n\nShare a message and other optional information via e-mail, facebook, ...\n\n\nWARNING:\n This fuction is being updated and validated.  15 NOV 2016\n\n\nssk.easySocial.share( msg [, url [, params ] ] )\n\n\n\n\n\n\nmsg\n - The message to 'share'.\n\n\nurl\n - EFM\n\n\nparams\n - EFM\n\n\n\n\nExample:\n\n\n\n-- https://play.google.com/store/apps/details?id=com.roaminggamer.sudoku4\n-- https://itunes.apple.com/us/app/sudoku-for/id1150939979?mt=8\n\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "ssk.social.*"
        }, 
        {
            "location": "/libraries/social/#sskeasysocial", 
            "text": "This module contains a couple 'helper' functions to simplify sharing and rating apps.", 
            "title": "ssk.easySocial.*"
        }, 
        {
            "location": "/libraries/social/#rate", 
            "text": "Open rate interface in appropriate store for app identified  id .  ssk.easySocial.rate( id )   id  - A platform specific ID for the platform you want to rate on.   Example:  \n-- Rate Sudoku For.. game on Android  or iOS\nif( onAndroid ) then\n\n   ssk.easySocial.rate( 'com.roaminggamer.sudoku4' ) -- Google Play ID\n\nelseif( oniOS ) then\n\n   ssk.easySocial.rate( '1150939979' ) -- iTunes Connect ID\n\nend", 
            "title": "rate"
        }, 
        {
            "location": "/libraries/social/#share", 
            "text": "Share a message and other optional information via e-mail, facebook, ...  WARNING:  This fuction is being updated and validated.  15 NOV 2016  ssk.easySocial.share( msg [, url [, params ] ] )   msg  - The message to 'share'.  url  - EFM  params  - EFM   Example:  \n-- https://play.google.com/store/apps/details?id=com.roaminggamer.sudoku4\n-- https://itunes.apple.com/us/app/sudoku-for/id1150939979?mt=8     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "share"
        }, 
        {
            "location": "/help/", 
            "text": "Help!\n\n\nDon't Panic\n\n\nAre you having a problem with SSK 2?  If so, don't panic.\n\n\nI regularly update SSK 2 and its co-products.  Most of the time problems can simply be traced back to not having the most up-to-date version of SSK 2.\n\n\nSo, let's find out whatversion you have:\n\n\nrequire \nssk2.loadSSK\n\n\nprint( \nSSK VERSION: \n .. ssk.getVersion() )\n\n_G.ssk.init()\n\n\n\n\nIf this prints out \nSSK VERSION: 2016.001\n it is time to panic.  OK, not really.  You do have the latest version of SSK 2, but maybe you are using a co-product that is out-of-date?  Please go check to the co-product page and check its version too.\n\n\nSSK.someFunction()\n\n\nYou may have noticed that while this is called SSK \n2\n, I still use the old naming convention \nssk.someFunction()\n in my samples.  \n\n\n\"Why,\" you ask?\n\n\nI am a lazy coder and proud of it. Even one extra letter is too much repetetive typing for me.\n\n\nSo, if you have been doing this: \nssk2.someFunction()\n, it will not work.  Get rid of that \n2\n and you should be back in business.\n\n\nSSK 2 Not Compatible With SSK\n\n\nSome folks may try to use the old free version of SSK with SSK 2, and/or they may try to replace the old SSK with SSK 2 in an existing project.\n\n\nWell, ...\n\n\n\n\nSSK 2 replaces and supercedes SSK\n\n\nSSK 2 cannot be used with SSK in the same project.\n\n\nSSK 2 is mostly backward compatible, but that is not a guarantee.  Sorry, but I had to make a break from some bad practices in SSK.  \n\n\n\n\nIf you're trying to shoehorn SSK 2 into an old project that used SSK, you may need to do a little housekeeping to make it work.  \n\n\nRight now, I do not have a 'conversion' guide, but if I get enough calls for it I will do one.\n\n\nI Read All That!  Now What?\n\n\nEFM TBD.\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "Help!"
        }, 
        {
            "location": "/help/#help", 
            "text": "", 
            "title": "Help!"
        }, 
        {
            "location": "/help/#dont-panic", 
            "text": "Are you having a problem with SSK 2?  If so, don't panic.  I regularly update SSK 2 and its co-products.  Most of the time problems can simply be traced back to not having the most up-to-date version of SSK 2.  So, let's find out whatversion you have:  require  ssk2.loadSSK \n\nprint(  SSK VERSION:   .. ssk.getVersion() )\n\n_G.ssk.init()  If this prints out  SSK VERSION: 2016.001  it is time to panic.  OK, not really.  You do have the latest version of SSK 2, but maybe you are using a co-product that is out-of-date?  Please go check to the co-product page and check its version too.", 
            "title": "Don't Panic"
        }, 
        {
            "location": "/help/#ssksomefunction", 
            "text": "You may have noticed that while this is called SSK  2 , I still use the old naming convention  ssk.someFunction()  in my samples.    \"Why,\" you ask?  I am a lazy coder and proud of it. Even one extra letter is too much repetetive typing for me.  So, if you have been doing this:  ssk2.someFunction() , it will not work.  Get rid of that  2  and you should be back in business.", 
            "title": "SSK.someFunction()"
        }, 
        {
            "location": "/help/#ssk-2-not-compatible-with-ssk", 
            "text": "Some folks may try to use the old free version of SSK with SSK 2, and/or they may try to replace the old SSK with SSK 2 in an existing project.  Well, ...   SSK 2 replaces and supercedes SSK  SSK 2 cannot be used with SSK in the same project.  SSK 2 is mostly backward compatible, but that is not a guarantee.  Sorry, but I had to make a break from some bad practices in SSK.     If you're trying to shoehorn SSK 2 into an old project that used SSK, you may need to do a little housekeeping to make it work.    Right now, I do not have a 'conversion' guide, but if I get enough calls for it I will do one.", 
            "title": "SSK 2 Not Compatible With SSK"
        }, 
        {
            "location": "/help/#i-read-all-that-now-what", 
            "text": "EFM TBD.     Copyright   Roaming Gamer, LLC. 2008-2016; All Rights Reserved", 
            "title": "I Read All That!  Now What?"
        }
    ]
}