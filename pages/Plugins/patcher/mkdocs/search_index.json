{
    "docs": [
        {
            "location": "/", 
            "text": "Patcher\n\n\n\n\nPatcher\n is a plugin that allows you to execute downloaded scripts as if they were part of your app/game distribution.\n\n\n\n\nHave you ever wondered, \"Is there a drop-dead easy way to download and execute scripts in my released app/game?\"  \n\n\nIf so, the answer is, \"Yes!\".\n\n\nWith patcher you can download scripts to effectively supercede scripts bundled with your app.  You can also download new code and execute it.\n\n\n\n\nBasic Usage\n\n\nA. Activate Plugin\n\n\nFirst, purchase the plugin on \nCorona Marketplace\n to activate it.\n\n\nB. Update build.settings\n\n\nSecond, ensure your build.settings file has this code in it:\n\n\nsettings =\n{\n    plugins =\n    {\n        [\nplugin.patcher\n] = { publisherId = \ncom.roaminggamer\n },\n    },      \n}\n\n\n\n\nC. Enable Patcher\n\n\nOnce you have downloaded replacement scripts you can enable it by doing this at the very top of \nmain.lua\n.\n\n\nlocal patcher = require \nplugin.patcher\n\npatcher.export()\n\n\n\n\nNow, you can use the \nrequire()\n function as you normally would and any 'downloaded scripts' will automatically be used in place of the ones in the \nsystem.ResourceDirectory\n.\n\n\n(Please see the \nDocs\n below for more details.)\n\n\n\n\nDocs Index\n\n\nAlphabetical Function Index \n\n\n\n\n\n\n\n\nFunction\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npatcher.caching\n\n\nThis function allows you to enable/disable script caching.\n\n\n\n\n\n\npatcher.debug\n\n\nThis feature allows you to enable/debug verbose debug messaging.\n\n\n\n\n\n\npatcher.dump\n\n\nThis feature dumps a list of all cached scripts to the console (if verbose mode enabled).  It also returns a alphabetically sorted table listing the the script names.\n\n\n\n\n\n\npatcher.enabled\n\n\nThis function allows you to enable and disable patching without purging or removing patches.\n\n\n\n\n\n\npatcher.export\n\n\nThis function allows you to replace the global \nrequire()\n function with \npatcher.require()\n.\n\n\n\n\n\n\npatcher.get\n\n\nThis is a helper function that allows you download scripts to the correct path and file for superceding existing scripts.\n\n\n\n\n\n\npatcher.getSettings\n\n\nReturns a table of the current settings ( caching, enabled, verbose) and their values.\n\n\n\n\n\n\npatcher.mkFolder\n\n\nThis helper function can be used to create any folders you need prior to generating or downloading scripts in the system.DocumentsDirectory.\n\n\n\n\n\n\npatcher.patched\n\n\nReturns \ntrue\n if the named script has been patched.\n\n\n\n\n\n\npatcher.purge\n\n\nAllows you to purge a single named script, or all scripts if no specific script is specfied.\n\n\n\n\n\n\npatcher.reset\n\n\nThis function restores the global \n_G.require()\n reference to the standard function.\n\n\n\n\n\n\npatcher.remove\n\n\nThis function deletes a named patch (script) from the specified system.DocumentsDirectory folder.\n\n\n\n\n\n\npatcher.require\n\n\nThis is the replacement for Corona's standard \nrequire()\n function\n\n\n\n\n\n\npatcher.write\n\n\nThis helper function allows you to write a script to a specific location in the system.DocumentsDirectory.\n\n\n\n\n\n\n\n\nInitialization\n\n\nexport()\n\n\nReplaces the global \nrequire()\n function with \npatcher.require()\n.\n\n\nTip:\n This should be done ONCE at the very top of \nmain.lua\n.\n\n\nlocal patcher = require \nplugin.patcher\n\npatcher.export()\n\n-- Now, all future calls to require() will use the patcher version of this function.\n\n\n\n\nindex \n\n\nreset()\n\n\nRestore the global reference to the standard function \n_G.require()\n.\n\n\nlocal patcher = require \nplugin.patcher\n\npatcher.reset()\n\n-- Now, all future calls to require() will use the original version of this function.\n\n\n\n\nindex \n\n\nSettings\n\n\ncaching( [ en ] )\n\n\n\n\nen\n  - \ntrue\n to enable; \nfalse\n to disable.  Caching is enabled by default.\n\n\n\n\nTip: While caching is disabled, scripts are re-evaluated on each require().  This still updates the cache.\n\n\nlocal patcher = require \nplugin.patcher\n\npatcher.caching( false ) -- Disable patching\n\n-- Now, all future calls to require() will reload scripts from file.\n\n\n\n\nindex \n\n\ndebug( [ en ] )\n\n\n\n\nen\n  - \ntrue\n to enable verbose debug messaging; \nfalse\n to disable verbose debug messaging.  Verbose mode is diasbled by default.\n\n\n\n\nlocal patcher = require \nplugin.patcher\n\npatcher.debug( true ) -- Turn on 'verbose' debug output for this plugin.\n\n\n\n\nindex \n\n\nenabled( [ en ] )\n\n\n\n\nen\n  - \ntrue\n to enable; \nfalse\n to disable.  Patching is enabled by default.\n\n\n\n\nlocal patcher = require \nplugin.patcher\n\npatcher.enabled( false ) -- Disable patching\n\n-- Now, all future calls to require() will return references to original scripts.\n\n\n\n\nindex \n\n\ngetSettings()\n\n\nReturns a table containing the names and values of the current settings: caching, enabled, verbose.\n\n\nlocal patcher = require \nplugin.patcher\n\nlocal patcherSettings = patcher.getSettings()\n\n\n\n\nindex \n\n\nPatching\n\n\nPatching\n is a fancy way of saying, we are going to generate or download a script into the system.DocumentsFolder and then use it instead of a script we have in the system.ResourceDirectory.  \n\n\nThis plugin also allows you to generate/download new scripts that were never part of your original app, thus extending it.\n\n\nrequire( path )\n\n\n\n\npath\n  - Path to script (minus lua extension) just like a normal call to require\n\n\n\n\nlocal patcher = require \nplugin.patcher\n\n\n-- Load the patched version of 'myModule' if it is in system.DocumentsDirectory:\n-- \n scripts/myModule.lua \n-- \n-- Alternately, if no file is found use the original script.\n--\nlocal myModule = patcher.require( \nscripts.myModule\n )\n\n\n\n\n\nTip\n:  While are free to use the long-hand version of this, it is far better and easier to simply \nexport\n patcher's replacement function and then call \nrequire()\n as you normally would.\n\n\nindex \n\n\nUtilities\n\n\ndump( )\n\n\nIf \nverbose debugging\n mode is enable, this will print a list of patched scripts to the console.\n\n\nThis always returns an alphabetized table of the patched script names too.\n\n\nlocal patcher = require \nplugin.patcher\n\nlocal patchedList = patcher.dump() \n\n\n\n\nindex \n\n\npatched( path )\n\n\n\n\npath\n  - Normal path to a script.\n\n\n\n\nReturns \ntrue\n if the specified script has been patched and stored in the patcher's cache.\n\n\nlocal patcher = require \nplugin.patcher\n\nlocal isPatched = patcher.patched( \nscripts.myModule\n )\n\n\n\n\nindex \n\n\npurge( [ path ] )\n\n\n\n\npath\n  - An optional path to a script to purge from the patcher's cache.\n\n\n\n\nlocal patcher = require \nplugin.patcher\n\n\n-- Purge a single script:\n--\npatcher.purge( \nscripts.myModule\n )\n\n-- Purge entire cache:\n--\npatcher.purge( )\n\n\n\n\nindex \n\n\nremove( path )\n\n\n\n\npath\n  - Normal path to a script. \n\n\n\n\nDeletes a file if found at the specified path (assumes the file is a .lua script).\n\n\nWarning!\n: Do not use this as some kind of general file helper.  It should only be used for patch files.\n\n\nlocal patcher = require \nplugin.patcher\n\n\n-- Delete the patch for `myModule.lua`\n--\npatcher.remove( \nscripts.myModule\n )\n\n\n\n\n\nindex \n\n\nHelpers\n\n\nget( src, dst [, onSuccess [, onFail [, onProgress ]]] )\n\n\n\n\nsrc\n  - Full http: or https: path to script.\n\n\ndst - Normal path to script as you would specify for \nrequire()\n calls.\n\n\nonSuccess\n - An optional function that is called when the file is 'successfully' downloaded.\n\n\nonFail\n - An optional function that is called when the file fails to download.\n\n\nonProgress\n - An optional function that is called when the file is downloading.  This can be used to give 'progress' feedback if you need it.  Most people will not use this.\n\n\n\n\nWarning!\n: Do not use this as some kind of general file download helper.  It should only be used for patch files.\n\n\nlocal patcher = require \nplugin.patcher\n\n\n-- Download a patch for 'myModule.lua'\n--\nlocal testPatch = \nhttps://raw.githubusercontent.com/roaminggamer/RG_FreeStuff/master/myPluginSamples/patcher/myModule.lua\n\n\nlocal function onSuccess( event )\n    print(\nSuccess!\n)\nend\n\nlocal function onFail( event )\n    print(\nFailure!\n)\n    for k,v in pairs(event) do\n        print(k,v)\n    end\nend\n\npatcher.get( testPatch, \nscripts.myModule\n, onSuccess, onFail )\n\n\n\n\nindex \n\n\nwrite( script, path )\n\n\n\n\nscript\n  - A lua standard script (usually a module).\n\n\npath\n  - Normal path to script as you would specify for \nrequire()\n calls.\n\n\n\n\nWhile the typical usage for patcher is to download scripts, there is no reason why you can generate them locally.  This helper gives you an easy way to save those 'generated' scripts.\n\n\nTip:\n Remember to make any folders you need before attempting to write scripts to them.\n\n\nlocal patcher = require \nplugin.patcher\n\n\nlocal patchedScript = \n    \nlocal m = {}\\n\n ..\n    \nlocal cx,cy = display.contentCenterX, display.contentCenterY\\n\n ..\n    \nlocal mRand = math.random\\n\n ..\n    \nfunction m.run( group )\\n\n ..\n    \n   local tmp = display.newRect( group, cx + mRand(-200,200), cy + mRand(-20,80), 40, 40 )\\n\n ..\n    \n   tmp:setFillColor(1,mRand(),mRand())\\n\n ..\n    \ndisplay.newText( group, 'patch v2 - scripts.myModule', cx, cy + 160,  'Lato-Black.ttf', 22 )\\n\n ..\n    \nend\\n\n ..\n    \nreturn m\n\n\npatcher.mkFolder( \nscripts\n )\n\npatcher.write( patchedScript, \nscripts.myModule\n )\n\n\n\n\n\nindex \n\n\nmkFolder( path )\n\n\n\n\npath\n  - A standard file path as you would specify it for regular file operations.\n\n\n\n\nWarning!\n This is the only case in patcher where paths are specified using forward slashes if needed.  \n\n\nlocal patcher = require \nplugin.patcher\n\n\n-- Make a scripts folder and a sub-folder 'other' in scripts\n--\npatcher.mkFolder( \nscripts\n )\npatcher.mkFolder( \nscripts/other\n )\n\n\n\n\nindex \n\n\nComplete Example\n\n\nYou can download a complete example that tests the features of the plugin here:\n\n\npatcher-example.zip\n\n\nbuild.settings\n\n\n-- =============================================================\n-- https://docs.coronalabs.com/daily/guide/distribution/buildSettings/index.html\n-- https://docs.coronalabs.com/daily/guide/tvos/index.html\n-- https://docs.coronalabs.com/daily/guide/distribution/win32Build/index.html\n-- https://docs.coronalabs.com/daily/guide/distribution/osxBuild/index.html\n-- =============================================================\nlocal orientation = 'portrait' -- portrait, landscapeRight, ...\nsettings = {\n-------------------------------------------------------------------------------\n--  Orientation Settings \n-------------------------------------------------------------------------------\n   orientation = {\n      default     = orientation,\n      supported   = { orientation },\n   },\n    android =\n   {\n      usesPermissions =\n      {\n         \nandroid.permission.INTERNET\n,\n      },\n   },\n   iphone =\n    {\n        plist =\n        {\n            UIStatusBarHidden = false,\n            CFBundleIconFiles =\n            {\n                \nIcon-40.png\n,\n                \nIcon-58.png\n,\n                \nIcon-76.png\n,\n                \nIcon-80.png\n,\n                \nIcon-87.png\n,\n                \nIcon-120.png\n,\n                \nIcon-152.png\n,\n                \nIcon-167.png\n,\n                \nIcon-180.png\n,\n            },\n        },\n    },\n}\n\n\n\n\nmain.lua\n\n\n-- =============================================================\nio.output():setvbuf(\nno\n)\ndisplay.setStatusBar(display.HiddenStatusBar)\n-- =============================================================\n-- Code To Create Example Buttons ++\n-- =============================================================\nlocal widget = require( \nwidget\n )\nwidget.setTheme( \nwidget_theme_ios\n )\n--widget.setTheme( \nwidget_theme_android_holo_light\n )\n--widget.setTheme( \nwidget_theme_android_holo_dark\n )\n--\nlocal cx,cy = display.contentCenterX, display.contentCenterY\nlocal uw = display.actualContentWidth - display.contentWidth\nlocal uh = display.actualContentHeight - display.contentHeight\nlocal left = (uw == 0) and 0 or (0 - uw/2)\nlocal right = left + display.actualContentWidth\nlocal top = (uh == 0) and 0 or (0 - uh/2)\nlocal bottom = top + display.actualContentHeight\n--\nlocal group \n--\nlocal myModule\n--\nlocal bw = 200\nlocal bh = 30\nlocal bh2 = 80\nlocal function makeButton( x, y, text, action )\n    local button = display.newRect( x, y, bw, bh )\n    button:setFillColor(1,1,1,0.1)\n    button:setStrokeColor(1,1,1,0.5)\n    button.strokeWidth = 2\n    button.label = display.newText( text, x, y,  \nLato-Black.ttf\n, 16 )\n    button.action = action or function() end\n    function button.touch( self, event )\n        if( event.phase == \nended\n ) then \n            self:setStrokeColor(0.5,1,0.5,1)\n            timer.performWithDelay( 60, \n                function() \n                    self:setStrokeColor(1,1,1,0.5)\n                    self.action()\n                end )       \n        end\n        return true\n    end\n    button:addEventListener(\ntouch\n)\n    return button\nend\n--\nlocal function makeToggleButton( x, y, text1, text2, text3, offAction, onAction )\n    local topLabel = display.newText( text1, x, y, \nLato-Black.ttf\n, 22 )\n\n    -- Question: why is the logic opposite?  Bug in widget.*?\n    local function listener( event )\n        if( event.target.isOn ) then\n            offAction()\n        else\n            onAction()\n        end\n    end\n\n    -- Create a default on/off switch (using widget.setTheme)\n    local button = widget.newSwitch \n    {\n        x = x,\n        y =  y,\n        onRelease = listener,\n    }\n    button.x = x\n    button.y = topLabel.y + topLabel.contentHeight/2 + button.contentHeight/2\n\n    local onLabel = display.newText( text2, button.x + button.contentWidth/2 + 10, button.y, \nLato-Black.ttf\n, 18 )\n    onLabel.anchorX = 0\n    onLabel:setTextColor(0,1,0)\n    local offLabel = display.newText( text3, button.x - button.contentWidth/2 - 10, button.y, \nLato-Black.ttf\n, 18 )\n    offLabel.anchorX = 1\n    offLabel:setTextColor(1,0,0)\n\n    return button\nend\n--\nlocal function easyAlert( title, msg, buttons )\n    buttons = buttons or { {\nOK\n} }\n    local function onComplete( event )\n        local action = event.action\n        local index = event.index\n        if( action == \nclicked\n ) then\n            local func = buttons[index][2]\n            if( func ) then func() end \n        end\n    end\n    local names = {}\n    for i = 1, #buttons do\n        names[i] = buttons[i][1]\n    end\n    local alert = native.showAlert( title, msg, names, onComplete )\n    return alert\nend\n\n-- =============================================================\n--  Load patcher and start disabled, quiet, etc.\n-- =============================================================\nlocal patcher = require \nplugin.patcher\n\npatcher.debug(false)\npatcher.enabled(false)\npatcher.caching(false)\n\n-- =============================================================\n--  Patcher Tests\n-- =============================================================\nlocal function createTestPatch()\n    local patchedScript = \n        \nlocal m = {}\\n\n ..\n        \nlocal cx,cy = display.contentCenterX, display.contentCenterY\\n\n ..\n        \nlocal mRand = math.random\\n\n ..\n        \nfunction m.run( group )\\n\n ..\n        \n   local tmp = display.newRect( group, cx + mRand(-200,200), cy + mRand(-20,80), 120, 120 )\\n\n ..\n        \n   tmp:setFillColor(1,mRand(),mRand())\\n\n ..\n        \ndisplay.newText( group, 'patch v1 - scripts.myModule', cx, cy + 160,  'Lato-Black.ttf', 22 )\\n\n ..\n        \nend\\n\n ..\n        \nreturn m\n\n    patcher.mkFolder( \nscripts\n )\n    patcher.write( patchedScript, \nscripts.myModule\n )\nend\n\nlocal function createTestPatch2()\n    local patchedScript = \n        \nlocal m = {}\\n\n ..\n        \nlocal cx,cy = display.contentCenterX, display.contentCenterY\\n\n ..\n        \nlocal mRand = math.random\\n\n ..\n        \nfunction m.run( group )\\n\n ..\n        \n   local tmp = display.newRect( group, cx + mRand(-200,200), cy + mRand(-20,80), 40, 40 )\\n\n ..\n        \n   tmp:setFillColor(1,mRand(),mRand())\\n\n ..\n        \ndisplay.newText( group, 'patch v2 - scripts.myModule', cx, cy + 160,  'Lato-Black.ttf', 22 )\\n\n ..\n        \nend\\n\n ..\n        \nreturn m\n\n    patcher.mkFolder( \nscripts\n )\n    patcher.write( patchedScript, \nscripts.myModule\n )\nend\n\nlocal function downloadPatch()\n    patcher.mkFolder( \nscripts\n )\n    local function onSuccess( event )\n        easyAlert(\nSuccess\n, \nPatch downloaded!\n )\n    end\n    local function onFail( event )\n        easyAlert(\nFailure\n, \nPatch not downloaded?\\n\\nSee console\n )\n        for k,v in pairs(event) do\n            print(k,v)\n        end\n    end\n    local function onProgress( event )\n        --for k,v in pairs(event) do\n            --print(k,v)\n        --end\n    end\n\n    local testPatch = \nhttps://raw.githubusercontent.com/roaminggamer/RG_FreeStuff/master/myPluginSamples/patcher/myModule.lua\n\n    patcher.get( testPatch, \nscripts.myModule\n, onSuccess, onFail, onProgress )\nend\n\nlocal function destroyPatch()\n    patcher.remove( \nscripts.myModule\n )\nend\n\nlocal function loadMyModule()\n    myModule = require \nscripts.myModule\n\nend\n\nlocal function testMyModule()\n    if( not myModule ) then return end\n    display.remove(group)\n    group = display.newGroup()\n    myModule.run( group )\nend\n\nlocal function printPatcherSettings()\n    local settings = patcher.getSettings()\n\n    print(\n=============================\n)\n    for k,v in pairs(settings) do\n        print(k,v)\n    end\n    print(\n=============================\\n\n)\nend\n\n\n-- =============================================================\n--  Create Buttons to Run Tests\n-- =============================================================\nlocal by = top + 20\nlocal button = makeToggleButton( cx, by, \nrequire() using\n, \npatcher.require()\n, \n_G.require()\n,\n                   function() patcher.export() end,\n                   function() patcher.reset() end )\nby = by + bh2\n\nlocal button = makeToggleButton( cx, by, \npatcher.enabled()\n, \ntrue\n, \nfalse\n,\n                   function() patcher.enabled(true) end,\n                   function() patcher.enabled(false) end )\nby = by + bh2\n\nlocal button = makeToggleButton( cx, by, \npatcher.debug()\n, \ntrue\n, \nfalse\n,\n                   function() patcher.debug(true) end,\n                   function() patcher.debug(false) end )\nby = by + bh2\n\nlocal button = makeToggleButton( cx, by, \npatcher.caching()\n, \ntrue\n, \nfalse\n,\n                   function() patcher.caching(true) end,\n                   function() patcher.caching(false) end )\nby = by + bh2\n\nmakeButton( cx, by, \nPrint Patcher Settings\n, printPatcherSettings )\n\nby = bottom - 240\nlocal bx = cx - 200\nmakeButton( bx, by, \nCreate Patch File v1\n, createTestPatch ); by = by + bh + 10\nmakeButton( bx, by, \nCreate Patch File v2\n, createTestPatch2 ); by = by + bh + 10\nmakeButton( bx, by, \nDownload Patch File v3\n, downloadPatch ); by = by + bh * 3\n\nmakeButton( bx, by, \nDestroy Patch File\n, destroyPatch )\n\nby = bottom - 240\nlocal bx = cx + 200\nmakeButton( bx, by, \nDump Cache\n, function() patcher.dump() end); by = by + bh + 10\nmakeButton( bx, by, \nPurge Cache\n, function() patcher.purge() end ); by = by + bh * 3\n\nmakeButton( bx, by, \nLoad Module\n, loadMyModule ); by = by + bh + 10\nmakeButton( bx, by, \nTest Module\n, testMyModule ); by = by + bh * 3\n\n\n\n\n\nscripts/myModule.lua\n\n\nlocal m = {}\nlocal cx,cy = display.contentCenterX, display.contentCenterY\nlocal mRand = math.random\nfunction m.run( group )\n    local tmp = display.newCircle( group, cx + mRand(-200,200), cy + mRand(-20,80), 60 )\n    tmp:setFillColor(1,mRand(),mRand())\n    display.newText( group, 'original - scripts.myModule', cx, cy + 160,  'Lato-Black.ttf', 22 )\nend\nreturn m\n\n\n\n\n\n\n  Copyright \n Roaming Gamer, LLC. 2008-2017; All Rights Reserved", 
            "title": "About"
        }, 
        {
            "location": "/#patcher", 
            "text": "Patcher  is a plugin that allows you to execute downloaded scripts as if they were part of your app/game distribution.   Have you ever wondered, \"Is there a drop-dead easy way to download and execute scripts in my released app/game?\"    If so, the answer is, \"Yes!\".  With patcher you can download scripts to effectively supercede scripts bundled with your app.  You can also download new code and execute it.", 
            "title": "Patcher"
        }, 
        {
            "location": "/#basic-usage", 
            "text": "", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/#a-activate-plugin", 
            "text": "First, purchase the plugin on  Corona Marketplace  to activate it.", 
            "title": "A. Activate Plugin"
        }, 
        {
            "location": "/#b-update-buildsettings", 
            "text": "Second, ensure your build.settings file has this code in it:  settings =\n{\n    plugins =\n    {\n        [ plugin.patcher ] = { publisherId =  com.roaminggamer  },\n    },      \n}", 
            "title": "B. Update build.settings"
        }, 
        {
            "location": "/#c-enable-patcher", 
            "text": "Once you have downloaded replacement scripts you can enable it by doing this at the very top of  main.lua .  local patcher = require  plugin.patcher \npatcher.export()  Now, you can use the  require()  function as you normally would and any 'downloaded scripts' will automatically be used in place of the ones in the  system.ResourceDirectory .  (Please see the  Docs  below for more details.)", 
            "title": "C. Enable Patcher"
        }, 
        {
            "location": "/#docs-index", 
            "text": "Alphabetical Function Index      Function  Description      patcher.caching  This function allows you to enable/disable script caching.    patcher.debug  This feature allows you to enable/debug verbose debug messaging.    patcher.dump  This feature dumps a list of all cached scripts to the console (if verbose mode enabled).  It also returns a alphabetically sorted table listing the the script names.    patcher.enabled  This function allows you to enable and disable patching without purging or removing patches.    patcher.export  This function allows you to replace the global  require()  function with  patcher.require() .    patcher.get  This is a helper function that allows you download scripts to the correct path and file for superceding existing scripts.    patcher.getSettings  Returns a table of the current settings ( caching, enabled, verbose) and their values.    patcher.mkFolder  This helper function can be used to create any folders you need prior to generating or downloading scripts in the system.DocumentsDirectory.    patcher.patched  Returns  true  if the named script has been patched.    patcher.purge  Allows you to purge a single named script, or all scripts if no specific script is specfied.    patcher.reset  This function restores the global  _G.require()  reference to the standard function.    patcher.remove  This function deletes a named patch (script) from the specified system.DocumentsDirectory folder.    patcher.require  This is the replacement for Corona's standard  require()  function    patcher.write  This helper function allows you to write a script to a specific location in the system.DocumentsDirectory.", 
            "title": "Docs Index"
        }, 
        {
            "location": "/#initialization", 
            "text": "", 
            "title": "Initialization"
        }, 
        {
            "location": "/#export", 
            "text": "Replaces the global  require()  function with  patcher.require() .  Tip:  This should be done ONCE at the very top of  main.lua .  local patcher = require  plugin.patcher \npatcher.export()\n\n-- Now, all future calls to require() will use the patcher version of this function.  index", 
            "title": "export()"
        }, 
        {
            "location": "/#reset", 
            "text": "Restore the global reference to the standard function  _G.require() .  local patcher = require  plugin.patcher \npatcher.reset()\n\n-- Now, all future calls to require() will use the original version of this function.  index", 
            "title": "reset()"
        }, 
        {
            "location": "/#settings", 
            "text": "", 
            "title": "Settings"
        }, 
        {
            "location": "/#caching-en", 
            "text": "en   -  true  to enable;  false  to disable.  Caching is enabled by default.   Tip: While caching is disabled, scripts are re-evaluated on each require().  This still updates the cache.  local patcher = require  plugin.patcher \npatcher.caching( false ) -- Disable patching\n\n-- Now, all future calls to require() will reload scripts from file.  index", 
            "title": "caching( [ en ] )"
        }, 
        {
            "location": "/#debug-en", 
            "text": "en   -  true  to enable verbose debug messaging;  false  to disable verbose debug messaging.  Verbose mode is diasbled by default.   local patcher = require  plugin.patcher \npatcher.debug( true ) -- Turn on 'verbose' debug output for this plugin.  index", 
            "title": "debug( [ en ] )"
        }, 
        {
            "location": "/#enabled-en", 
            "text": "en   -  true  to enable;  false  to disable.  Patching is enabled by default.   local patcher = require  plugin.patcher \npatcher.enabled( false ) -- Disable patching\n\n-- Now, all future calls to require() will return references to original scripts.  index", 
            "title": "enabled( [ en ] )"
        }, 
        {
            "location": "/#getsettings", 
            "text": "Returns a table containing the names and values of the current settings: caching, enabled, verbose.  local patcher = require  plugin.patcher \nlocal patcherSettings = patcher.getSettings()  index", 
            "title": "getSettings()"
        }, 
        {
            "location": "/#patching", 
            "text": "Patching  is a fancy way of saying, we are going to generate or download a script into the system.DocumentsFolder and then use it instead of a script we have in the system.ResourceDirectory.    This plugin also allows you to generate/download new scripts that were never part of your original app, thus extending it.", 
            "title": "Patching"
        }, 
        {
            "location": "/#require-path", 
            "text": "path   - Path to script (minus lua extension) just like a normal call to require   local patcher = require  plugin.patcher \n\n-- Load the patched version of 'myModule' if it is in system.DocumentsDirectory:\n--   scripts/myModule.lua \n-- \n-- Alternately, if no file is found use the original script.\n--\nlocal myModule = patcher.require(  scripts.myModule  )  Tip :  While are free to use the long-hand version of this, it is far better and easier to simply  export  patcher's replacement function and then call  require()  as you normally would.  index", 
            "title": "require( path )"
        }, 
        {
            "location": "/#utilities", 
            "text": "", 
            "title": "Utilities"
        }, 
        {
            "location": "/#dump", 
            "text": "If  verbose debugging  mode is enable, this will print a list of patched scripts to the console.  This always returns an alphabetized table of the patched script names too.  local patcher = require  plugin.patcher \nlocal patchedList = patcher.dump()   index", 
            "title": "dump( )"
        }, 
        {
            "location": "/#patched-path", 
            "text": "path   - Normal path to a script.   Returns  true  if the specified script has been patched and stored in the patcher's cache.  local patcher = require  plugin.patcher \nlocal isPatched = patcher.patched(  scripts.myModule  )  index", 
            "title": "patched( path )"
        }, 
        {
            "location": "/#purge-path", 
            "text": "path   - An optional path to a script to purge from the patcher's cache.   local patcher = require  plugin.patcher \n\n-- Purge a single script:\n--\npatcher.purge(  scripts.myModule  )\n\n-- Purge entire cache:\n--\npatcher.purge( )  index", 
            "title": "purge( [ path ] )"
        }, 
        {
            "location": "/#remove-path", 
            "text": "path   - Normal path to a script.    Deletes a file if found at the specified path (assumes the file is a .lua script).  Warning! : Do not use this as some kind of general file helper.  It should only be used for patch files.  local patcher = require  plugin.patcher \n\n-- Delete the patch for `myModule.lua`\n--\npatcher.remove(  scripts.myModule  )  index", 
            "title": "remove( path )"
        }, 
        {
            "location": "/#helpers", 
            "text": "", 
            "title": "Helpers"
        }, 
        {
            "location": "/#get-src-dst-onsuccess-onfail-onprogress", 
            "text": "src   - Full http: or https: path to script.  dst - Normal path to script as you would specify for  require()  calls.  onSuccess  - An optional function that is called when the file is 'successfully' downloaded.  onFail  - An optional function that is called when the file fails to download.  onProgress  - An optional function that is called when the file is downloading.  This can be used to give 'progress' feedback if you need it.  Most people will not use this.   Warning! : Do not use this as some kind of general file download helper.  It should only be used for patch files.  local patcher = require  plugin.patcher \n\n-- Download a patch for 'myModule.lua'\n--\nlocal testPatch =  https://raw.githubusercontent.com/roaminggamer/RG_FreeStuff/master/myPluginSamples/patcher/myModule.lua \n\nlocal function onSuccess( event )\n    print( Success! )\nend\n\nlocal function onFail( event )\n    print( Failure! )\n    for k,v in pairs(event) do\n        print(k,v)\n    end\nend\n\npatcher.get( testPatch,  scripts.myModule , onSuccess, onFail )  index", 
            "title": "get( src, dst [, onSuccess [, onFail [, onProgress ]]] )"
        }, 
        {
            "location": "/#write-script-path", 
            "text": "script   - A lua standard script (usually a module).  path   - Normal path to script as you would specify for  require()  calls.   While the typical usage for patcher is to download scripts, there is no reason why you can generate them locally.  This helper gives you an easy way to save those 'generated' scripts.  Tip:  Remember to make any folders you need before attempting to write scripts to them.  local patcher = require  plugin.patcher \n\nlocal patchedScript = \n     local m = {}\\n  ..\n     local cx,cy = display.contentCenterX, display.contentCenterY\\n  ..\n     local mRand = math.random\\n  ..\n     function m.run( group )\\n  ..\n        local tmp = display.newRect( group, cx + mRand(-200,200), cy + mRand(-20,80), 40, 40 )\\n  ..\n        tmp:setFillColor(1,mRand(),mRand())\\n  ..\n     display.newText( group, 'patch v2 - scripts.myModule', cx, cy + 160,  'Lato-Black.ttf', 22 )\\n  ..\n     end\\n  ..\n     return m \n\npatcher.mkFolder(  scripts  )\n\npatcher.write( patchedScript,  scripts.myModule  )  index", 
            "title": "write( script, path )"
        }, 
        {
            "location": "/#mkfolder-path", 
            "text": "path   - A standard file path as you would specify it for regular file operations.   Warning!  This is the only case in patcher where paths are specified using forward slashes if needed.    local patcher = require  plugin.patcher \n\n-- Make a scripts folder and a sub-folder 'other' in scripts\n--\npatcher.mkFolder(  scripts  )\npatcher.mkFolder(  scripts/other  )  index", 
            "title": "mkFolder( path )"
        }, 
        {
            "location": "/#complete-example", 
            "text": "You can download a complete example that tests the features of the plugin here:  patcher-example.zip", 
            "title": "Complete Example"
        }, 
        {
            "location": "/#buildsettings", 
            "text": "-- =============================================================\n-- https://docs.coronalabs.com/daily/guide/distribution/buildSettings/index.html\n-- https://docs.coronalabs.com/daily/guide/tvos/index.html\n-- https://docs.coronalabs.com/daily/guide/distribution/win32Build/index.html\n-- https://docs.coronalabs.com/daily/guide/distribution/osxBuild/index.html\n-- =============================================================\nlocal orientation = 'portrait' -- portrait, landscapeRight, ...\nsettings = {\n-------------------------------------------------------------------------------\n--  Orientation Settings \n-------------------------------------------------------------------------------\n   orientation = {\n      default     = orientation,\n      supported   = { orientation },\n   },\n    android =\n   {\n      usesPermissions =\n      {\n          android.permission.INTERNET ,\n      },\n   },\n   iphone =\n    {\n        plist =\n        {\n            UIStatusBarHidden = false,\n            CFBundleIconFiles =\n            {\n                 Icon-40.png ,\n                 Icon-58.png ,\n                 Icon-76.png ,\n                 Icon-80.png ,\n                 Icon-87.png ,\n                 Icon-120.png ,\n                 Icon-152.png ,\n                 Icon-167.png ,\n                 Icon-180.png ,\n            },\n        },\n    },\n}", 
            "title": "build.settings"
        }, 
        {
            "location": "/#mainlua", 
            "text": "-- =============================================================\nio.output():setvbuf( no )\ndisplay.setStatusBar(display.HiddenStatusBar)\n-- =============================================================\n-- Code To Create Example Buttons ++\n-- =============================================================\nlocal widget = require(  widget  )\nwidget.setTheme(  widget_theme_ios  )\n--widget.setTheme(  widget_theme_android_holo_light  )\n--widget.setTheme(  widget_theme_android_holo_dark  )\n--\nlocal cx,cy = display.contentCenterX, display.contentCenterY\nlocal uw = display.actualContentWidth - display.contentWidth\nlocal uh = display.actualContentHeight - display.contentHeight\nlocal left = (uw == 0) and 0 or (0 - uw/2)\nlocal right = left + display.actualContentWidth\nlocal top = (uh == 0) and 0 or (0 - uh/2)\nlocal bottom = top + display.actualContentHeight\n--\nlocal group \n--\nlocal myModule\n--\nlocal bw = 200\nlocal bh = 30\nlocal bh2 = 80\nlocal function makeButton( x, y, text, action )\n    local button = display.newRect( x, y, bw, bh )\n    button:setFillColor(1,1,1,0.1)\n    button:setStrokeColor(1,1,1,0.5)\n    button.strokeWidth = 2\n    button.label = display.newText( text, x, y,   Lato-Black.ttf , 16 )\n    button.action = action or function() end\n    function button.touch( self, event )\n        if( event.phase ==  ended  ) then \n            self:setStrokeColor(0.5,1,0.5,1)\n            timer.performWithDelay( 60, \n                function() \n                    self:setStrokeColor(1,1,1,0.5)\n                    self.action()\n                end )       \n        end\n        return true\n    end\n    button:addEventListener( touch )\n    return button\nend\n--\nlocal function makeToggleButton( x, y, text1, text2, text3, offAction, onAction )\n    local topLabel = display.newText( text1, x, y,  Lato-Black.ttf , 22 )\n\n    -- Question: why is the logic opposite?  Bug in widget.*?\n    local function listener( event )\n        if( event.target.isOn ) then\n            offAction()\n        else\n            onAction()\n        end\n    end\n\n    -- Create a default on/off switch (using widget.setTheme)\n    local button = widget.newSwitch \n    {\n        x = x,\n        y =  y,\n        onRelease = listener,\n    }\n    button.x = x\n    button.y = topLabel.y + topLabel.contentHeight/2 + button.contentHeight/2\n\n    local onLabel = display.newText( text2, button.x + button.contentWidth/2 + 10, button.y,  Lato-Black.ttf , 18 )\n    onLabel.anchorX = 0\n    onLabel:setTextColor(0,1,0)\n    local offLabel = display.newText( text3, button.x - button.contentWidth/2 - 10, button.y,  Lato-Black.ttf , 18 )\n    offLabel.anchorX = 1\n    offLabel:setTextColor(1,0,0)\n\n    return button\nend\n--\nlocal function easyAlert( title, msg, buttons )\n    buttons = buttons or { { OK } }\n    local function onComplete( event )\n        local action = event.action\n        local index = event.index\n        if( action ==  clicked  ) then\n            local func = buttons[index][2]\n            if( func ) then func() end \n        end\n    end\n    local names = {}\n    for i = 1, #buttons do\n        names[i] = buttons[i][1]\n    end\n    local alert = native.showAlert( title, msg, names, onComplete )\n    return alert\nend\n\n-- =============================================================\n--  Load patcher and start disabled, quiet, etc.\n-- =============================================================\nlocal patcher = require  plugin.patcher \npatcher.debug(false)\npatcher.enabled(false)\npatcher.caching(false)\n\n-- =============================================================\n--  Patcher Tests\n-- =============================================================\nlocal function createTestPatch()\n    local patchedScript = \n         local m = {}\\n  ..\n         local cx,cy = display.contentCenterX, display.contentCenterY\\n  ..\n         local mRand = math.random\\n  ..\n         function m.run( group )\\n  ..\n            local tmp = display.newRect( group, cx + mRand(-200,200), cy + mRand(-20,80), 120, 120 )\\n  ..\n            tmp:setFillColor(1,mRand(),mRand())\\n  ..\n         display.newText( group, 'patch v1 - scripts.myModule', cx, cy + 160,  'Lato-Black.ttf', 22 )\\n  ..\n         end\\n  ..\n         return m \n    patcher.mkFolder(  scripts  )\n    patcher.write( patchedScript,  scripts.myModule  )\nend\n\nlocal function createTestPatch2()\n    local patchedScript = \n         local m = {}\\n  ..\n         local cx,cy = display.contentCenterX, display.contentCenterY\\n  ..\n         local mRand = math.random\\n  ..\n         function m.run( group )\\n  ..\n            local tmp = display.newRect( group, cx + mRand(-200,200), cy + mRand(-20,80), 40, 40 )\\n  ..\n            tmp:setFillColor(1,mRand(),mRand())\\n  ..\n         display.newText( group, 'patch v2 - scripts.myModule', cx, cy + 160,  'Lato-Black.ttf', 22 )\\n  ..\n         end\\n  ..\n         return m \n    patcher.mkFolder(  scripts  )\n    patcher.write( patchedScript,  scripts.myModule  )\nend\n\nlocal function downloadPatch()\n    patcher.mkFolder(  scripts  )\n    local function onSuccess( event )\n        easyAlert( Success ,  Patch downloaded!  )\n    end\n    local function onFail( event )\n        easyAlert( Failure ,  Patch not downloaded?\\n\\nSee console  )\n        for k,v in pairs(event) do\n            print(k,v)\n        end\n    end\n    local function onProgress( event )\n        --for k,v in pairs(event) do\n            --print(k,v)\n        --end\n    end\n\n    local testPatch =  https://raw.githubusercontent.com/roaminggamer/RG_FreeStuff/master/myPluginSamples/patcher/myModule.lua \n    patcher.get( testPatch,  scripts.myModule , onSuccess, onFail, onProgress )\nend\n\nlocal function destroyPatch()\n    patcher.remove(  scripts.myModule  )\nend\n\nlocal function loadMyModule()\n    myModule = require  scripts.myModule \nend\n\nlocal function testMyModule()\n    if( not myModule ) then return end\n    display.remove(group)\n    group = display.newGroup()\n    myModule.run( group )\nend\n\nlocal function printPatcherSettings()\n    local settings = patcher.getSettings()\n\n    print( ============================= )\n    for k,v in pairs(settings) do\n        print(k,v)\n    end\n    print( =============================\\n )\nend\n\n\n-- =============================================================\n--  Create Buttons to Run Tests\n-- =============================================================\nlocal by = top + 20\nlocal button = makeToggleButton( cx, by,  require() using ,  patcher.require() ,  _G.require() ,\n                   function() patcher.export() end,\n                   function() patcher.reset() end )\nby = by + bh2\n\nlocal button = makeToggleButton( cx, by,  patcher.enabled() ,  true ,  false ,\n                   function() patcher.enabled(true) end,\n                   function() patcher.enabled(false) end )\nby = by + bh2\n\nlocal button = makeToggleButton( cx, by,  patcher.debug() ,  true ,  false ,\n                   function() patcher.debug(true) end,\n                   function() patcher.debug(false) end )\nby = by + bh2\n\nlocal button = makeToggleButton( cx, by,  patcher.caching() ,  true ,  false ,\n                   function() patcher.caching(true) end,\n                   function() patcher.caching(false) end )\nby = by + bh2\n\nmakeButton( cx, by,  Print Patcher Settings , printPatcherSettings )\n\nby = bottom - 240\nlocal bx = cx - 200\nmakeButton( bx, by,  Create Patch File v1 , createTestPatch ); by = by + bh + 10\nmakeButton( bx, by,  Create Patch File v2 , createTestPatch2 ); by = by + bh + 10\nmakeButton( bx, by,  Download Patch File v3 , downloadPatch ); by = by + bh * 3\n\nmakeButton( bx, by,  Destroy Patch File , destroyPatch )\n\nby = bottom - 240\nlocal bx = cx + 200\nmakeButton( bx, by,  Dump Cache , function() patcher.dump() end); by = by + bh + 10\nmakeButton( bx, by,  Purge Cache , function() patcher.purge() end ); by = by + bh * 3\n\nmakeButton( bx, by,  Load Module , loadMyModule ); by = by + bh + 10\nmakeButton( bx, by,  Test Module , testMyModule ); by = by + bh * 3", 
            "title": "main.lua"
        }, 
        {
            "location": "/#scriptsmymodulelua", 
            "text": "local m = {}\nlocal cx,cy = display.contentCenterX, display.contentCenterY\nlocal mRand = math.random\nfunction m.run( group )\n    local tmp = display.newCircle( group, cx + mRand(-200,200), cy + mRand(-20,80), 60 )\n    tmp:setFillColor(1,mRand(),mRand())\n    display.newText( group, 'original - scripts.myModule', cx, cy + 160,  'Lato-Black.ttf', 22 )\nend\nreturn m     Copyright   Roaming Gamer, LLC. 2008-2017; All Rights Reserved", 
            "title": "scripts/myModule.lua"
        }, 
        {
            "location": "/ssk2/", 
            "text": "Redirecting to homepage now...", 
            "title": "SSK2"
        }
    ]
}